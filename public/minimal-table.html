<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PokerGeek - Minimal Table</title>
  <style>
    /* Design Tokens */
    :root {
      --bg: #0b0b12;
      --text: #e9eef7;
      --muted: #9aa3b2;
      --accent: #ff5100;
      --teal: #00d4aa;
      --error: #ff3b3b;
      --felt-current: #197a45;
      --font-main: "Inter", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      --font-mono: "JetBrains Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --shadow-md: 0 8px 18px rgba(0,0,0,.35);
      --shadow-lg: 0 12px 28px rgba(0,0,0,.45);
      --shadow-xl: 0 18px 44px rgba(0,0,0,.55);
    }

    /* Felt color presets */
    body[data-felt="green"] { --felt-current: #197a45; }
    body[data-felt="red"] { --felt-current: #6b1414; }
    body[data-felt="black"] { --felt-current: #1a1a1a; }
    body[data-felt="blue"] { --felt-current: #0f2942; }
    body[data-felt="grey"] { --felt-current: #2a2a2a; }
    body[data-felt="tan"] { --felt-current: #6b5642; }
    body[data-felt="purple"] { --felt-current: #3a1450; }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      background: #0b0b12;
      color: #e9eef7;
      font-family: 'Inter', system-ui, -apple-system, Arial, sans-serif;
      padding: 20px;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
    }
    
    /* ============================================ */
    /* ZOOM LOCK TABLE WRAPPER */
    /* ============================================ */
    .table-wrapper {
      width: 100%;
      min-height: 600px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--bg);
      position: relative;
      overflow: hidden;
      margin-bottom: 30px;
    }

    .poker-table {
      position: absolute;
      width: 1680px;
      height: 800px;
      transform-origin: top left;
      pointer-events: auto;
    }

    /* Oval Felt Background */
    .table-felt {
      position: absolute;
      inset: 24px;
      border-radius: 360px;
      border: 2px solid #0d1117;
      background: var(--felt-current);
      box-shadow: 
        inset 0 0 0 16px rgba(0,0,0,.35), 
        inset 0 0 80px rgba(0,0,0,.45);
      z-index: 0;
    }

    .table-felt::after {
      content: "";
      position: absolute;
      inset: -24px;
      border-radius: inherit;
      box-shadow: 0 16px 56px rgba(0,0,0,.55);
      pointer-events: none;
    }

    /* Board Center (Community Cards + Pot) */
    .board-center {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 16px;
      z-index: 5;
      pointer-events: none;
    }

    .community-cards-center {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      justify-content: center;
    }
    
    /* Community card styling */
    .community-cards-center .card-img {
      width: 110px;
      aspect-ratio: 5/7;
      border-radius: 10px;
      box-shadow: 
        0 0 30px rgba(255, 255, 255, 0.15),
        0 12px 40px rgba(0, 0, 0, 0.8);
      object-fit: cover;
      border: 2px solid rgba(255,255,255,0.3);
      transition: all 0.3s ease;
    }
    
    .community-cards-center .card-img:hover {
      transform: translateY(-4px);
      box-shadow: 
        0 0 40px rgba(255, 255, 255, 0.25),
        0 16px 50px rgba(0, 0, 0, 0.9);
    }
    
    /* Card entrance animation */
    @keyframes cardFlip {
      0% {
        transform: rotateY(90deg) scale(0.8);
        opacity: 0;
      }
      50% {
        transform: rotateY(45deg) scale(1.05);
      }
      100% {
        transform: rotateY(0deg) scale(1);
        opacity: 1;
      }
    }
    
    .community-cards-center .card-img {
      animation: cardFlip 0.5s ease-out forwards;
    }

    .pot-display-center {
      padding: 28px 56px;
      border-radius: 24px;
      background: linear-gradient(135deg, rgba(0,0,0,.98) 0%, rgba(20,20,30,.98) 100%);
      border: 3px solid rgba(255,215,0,.6);
      text-align: center;
      box-shadow: 
        inset 0 0 40px -10px rgba(255, 215, 0, 0.3),
        0 0 0 1px rgba(255,215,0,.3),
        0 0 60px rgba(255,215,0,.4),
        var(--shadow-xl);
      pointer-events: auto;
      backdrop-filter: blur(10px);
    }

    .pot-label {
      font-size: 14px;
      color: var(--muted);
      letter-spacing: .2em;
      font-weight: 800;
      margin-bottom: 8px;
      text-transform: uppercase;
      text-shadow: 0 2px 4px rgba(0,0,0,0.6);
    }

    .pot-amount {
      font-family: var(--font-mono);
      font-size: 52px;
      color: #ffd700;
      font-weight: 900;
      text-shadow: 
        0 0 20px rgba(255, 215, 0, 0.8),
        0 4px 12px rgba(0, 0, 0, 0.8);
      letter-spacing: 0.05em;
    }

    /* Seats Layer */
    .seats-layer {
      position: absolute;
      inset: 0;
      z-index: 10;
    }
    
    h1 {
      color: #ff5100;
      margin-bottom: 10px;
    }
    
    .room-info {
      background: rgba(255,255,255,0.05);
      padding: 15px;
      border-radius: 10px;
      margin-bottom: 30px;
    }
    
    .room-code {
      color: #00d4aa;
      font-size: 1.5rem;
      font-weight: bold;
    }
    
    .seats-grid {
      position: relative;
      width: 100%;
      height: 100%;
    }
    
    .seat {
      position: absolute;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, rgba(20,20,40,0.95) 0%, rgba(30,30,50,0.95) 100%);
      border: 2px solid rgba(255,255,255,0.2);
      border-radius: 16px;
      padding: 24px;
      width: 220px;
      min-height: 180px;
      transition: all 0.3s ease;
      backdrop-filter: blur(20px) saturate(120%);
      box-shadow: 
        inset 0 0 20px -5px rgba(255, 255, 255, 0.1),
        0 10px 30px rgba(0, 0, 0, 0.6);
    }
    
    /* YOUR seat - wider for better card display */
    .seat.me {
      width: 320px;
      min-height: 200px;
      padding: 28px;
      border: 3px solid var(--teal);
      background: linear-gradient(135deg, rgba(0, 212, 170, 0.15) 0%, rgba(0, 180, 140, 0.15) 100%);
      box-shadow: 
        inset 0 0 30px -6px rgba(0, 212, 170, 0.3), 
        0 0 0 3px rgba(0,212,170,.5),
        0 0 50px rgba(0,212,170,.6),
        0 12px 40px rgba(0, 0, 0, 0.8);
    }
    
    .seat.empty {
      border: 2px dashed rgba(0, 212, 170, 0.5);
      background: linear-gradient(135deg, rgba(0, 212, 170, 0.03) 0%, rgba(0, 180, 140, 0.03) 100%);
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .seat.empty:hover {
      background: linear-gradient(135deg, rgba(0, 212, 170, 0.15) 0%, rgba(0, 180, 140, 0.15) 100%);
      border: 2px solid var(--teal);
      box-shadow: 
        inset 0 0 30px -6px rgba(0, 212, 170, 0.25),
        0 0 0 2px rgba(0,212,170,.4),
        0 0 40px rgba(0, 212, 170, 0.5),
        0 12px 35px rgba(0, 0, 0, 0.7);
      transform: scale(1.02);
    }
    
    .seat.taken {
      border: 2px solid rgba(255,215,0,0.6);
      background: linear-gradient(135deg, rgba(255,215,0,0.08) 0%, rgba(255,195,0,0.08) 100%);
      box-shadow: 
        inset 0 0 20px -5px rgba(255, 215, 0, 0.15),
        0 10px 30px rgba(0, 0, 0, 0.6);
    }
    
    .seat.me {
      border-color: #ff5100;
      background: rgba(255,81,0,0.1);
    }
    
    .seat.winner {
      border-color: gold;
      background: rgba(255,215,0,0.2);
      box-shadow: 0 0 20px rgba(255,215,0,0.5);
      animation: winnerPulse 1.5s ease-in-out infinite;
    }
    
    @keyframes winnerPulse {
      0%, 100% {
        box-shadow: 0 0 20px rgba(255,215,0,0.5);
      }
      50% {
        box-shadow: 0 0 30px rgba(255,215,0,0.8);
      }
    }
    
    .seat-label {
      font-size: 0.9rem;
      color: #9aa3b2;
      margin-bottom: 10px;
      letter-spacing: 0.3px;
    }
    
    .seat-player {
      font-size: 1.3rem;
      font-weight: 700;
      margin-bottom: 8px;
      color: var(--teal);
      text-shadow: 0 2px 8px rgba(0, 212, 170, 0.4);
      letter-spacing: 0.5px;
    }
    
    .seat-chips {
      color: #ffd700;
      font-weight: 600;
      font-size: 1.2rem;
      text-shadow: 0 2px 6px rgba(255, 215, 0, 0.5);
      letter-spacing: 0.5px;
    }
    
    /* üÉè SEAT CARD BACKINGS */
    .seat-cards {
      display: flex;
      gap: 12px;
      margin-top: 15px;
      justify-content: center;
      min-height: 98px;
    }
    
    .seat-card-back, .seat-card-front {
      width: 70px;
      height: 98px;
      border-radius: 6px;
      box-shadow: 0 6px 18px rgba(0,0,0,0.6);
      transition: all 0.3s;
      object-fit: cover;
    }
    
    .seat-card-back.folded, .seat-card-front.folded {
      opacity: 0.3;
      filter: grayscale(100%);
    }
    
    .seat-card-back.hidden {
      display: none;
    }
    
    /* üé∞ DEALER & BLIND BADGES */
    .position-badges {
      display: flex;
      gap: 4px;
      margin-top: 4px;
      justify-content: center;
    }
    
    .position-badge {
      font-size: 0.7rem;
      padding: 2px 6px;
      border-radius: 4px;
      font-weight: 600;
      border: 1px solid;
    }
    
    .position-badge.dealer {
      background: linear-gradient(135deg, #ffaa00, #ff8800);
      color: #0b0b12;
      border-color: #ffcc44;
    }
    
    .position-badge.sb {
      background: linear-gradient(135deg, #00aaff, #0088ff);
      color: white;
      border-color: #44ccff;
    }
    
    .position-badge.bb {
      background: linear-gradient(135deg, #ff3b3b, #ff0000);
      color: white;
      border-color: #ff6666;
    }
    
    /* üèÜ WINNER BANNER */
    .winner-banner {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, rgba(255,215,0,0.95), rgba(255,165,0,0.95));
      border: 3px solid gold;
      border-radius: 16px;
      padding: 30px 50px;
      font-size: 2rem;
      font-weight: 700;
      color: #0b0b12;
      box-shadow: 0 10px 40px rgba(255,215,0,0.6);
      z-index: 1000;
      animation: winnerBannerPop 0.5s ease-out;
      display: none;
    }
    
    @keyframes winnerBannerPop {
      0% {
        transform: translate(-50%, -50%) scale(0.5);
        opacity: 0;
      }
      100% {
        transform: translate(-50%, -50%) scale(1);
        opacity: 1;
      }
    }
    
    .winner-banner.show {
      display: block;
    }
    
    /* üÉè SHOW/MUCK CONTROLS */
    .showdown-controls {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, rgba(15,15,25,0.95), rgba(20,20,30,0.95));
      border: 2px solid #ff5100;
      border-radius: 12px;
      padding: 20px;
      display: none;
      z-index: 999;
      box-shadow: 0 8px 24px rgba(0,0,0,0.5);
    }
    
    .showdown-controls.show {
      display: block;
    }
    
    .showdown-controls h3 {
      margin: 0 0 12px 0;
      color: #ff5100;
      font-size: 1rem;
      text-align: center;
    }
    
    .showdown-controls .button-group {
      display: flex;
      gap: 12px;
    }
    
    .showdown-controls button {
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 0.9rem;
    }
    
    .showdown-controls button.show-btn {
      background: linear-gradient(135deg, #00dd88, #00aa66);
      color: white;
    }
    
    .showdown-controls button.show-btn:hover {
      background: linear-gradient(135deg, #00ff99, #00cc77);
      transform: scale(1.05);
    }
    
    .showdown-controls button.muck-btn {
      background: linear-gradient(135deg, #666, #444);
      color: white;
    }
    
    .showdown-controls button.muck-btn:hover {
      background: linear-gradient(135deg, #777, #555);
      transform: scale(1.05);
    }
    
    /* üéõÔ∏è HOST CONTROLS PANEL */
    .host-controls-panel {
      background: linear-gradient(135deg, rgba(255,81,0,0.1), rgba(255,81,0,0.05));
      border: 2px solid #ff5100;
      border-radius: 12px;
      padding: 0;
      margin-bottom: 20px;
      display: none; /* Hidden by default, shown for host only */
      overflow: hidden;
    }
    
    .host-controls-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px 20px;
      background: rgba(255,81,0,0.15);
      cursor: pointer;
      user-select: none;
      transition: background 0.2s;
    }
    
    .host-controls-header:hover {
      background: rgba(255,81,0,0.2);
    }
    
    .host-controls-header h3 {
      color: #ff5100;
      font-size: 1.1rem;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .host-badge {
      background: #ff5100;
      color: white;
      padding: 4px 10px;
      border-radius: 6px;
      font-size: 0.75rem;
      font-weight: 700;
    }
    
    .host-controls-content {
      max-height: 0;
      opacity: 0;
      transition: all 0.3s ease;
      pointer-events: none;
    }
    
    .host-controls-content.expanded {
      max-height: 600px;
      opacity: 1;
      pointer-events: auto;
      padding: 20px;
    }
    
    .host-section {
      background: rgba(255,255,255,0.05);
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 15px;
    }
    
    .host-section:last-child {
      margin-bottom: 0;
    }
    
    .host-section h4 {
      color: #00d4aa;
      font-size: 0.95rem;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .player-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .player-item {
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      padding: 12px 15px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border: 1px solid rgba(255,255,255,0.1);
    }
    
    .player-item-info {
      flex: 1;
    }
    
    .player-item-name {
      color: #e9eef7;
      font-weight: 600;
      font-size: 1rem;
      margin-bottom: 4px;
    }
    
    .player-item-details {
      color: #999;
      font-size: 0.85rem;
      display: flex;
      gap: 15px;
    }
    
    .player-item-chips {
      color: gold;
    }
    
    .host-btn {
      padding: 8px 16px;
      border-radius: 6px;
      border: none;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      white-space: nowrap;
    }
    
    .host-btn.kick {
      background: #ff3b3b;
      color: white;
    }
    
    .host-btn.kick:hover {
      background: #ff5555;
      transform: scale(1.05);
    }
    
    .blinds-controls {
      display: flex;
      gap: 15px;
      align-items: center;
      flex-wrap: wrap;
    }
    
    .blind-input-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .blind-input-group label {
      color: #9aa3b2;
      font-weight: 600;
      font-size: 0.9rem;
    }
    
    .blind-input-group input {
      width: 90px;
      padding: 10px;
      border-radius: 6px;
      border: 2px solid #333;
      background: rgba(0,0,0,0.4);
      color: #e9eef7;
      font-size: 1rem;
      font-weight: 600;
    }
    
    .blind-input-group input:focus {
      outline: none;
      border-color: #00d4aa;
    }
    
    .host-btn.update {
      background: #00d4aa;
      color: #0b0b12;
      padding: 10px 20px;
      font-size: 0.95rem;
    }
    
    .host-btn.update:hover {
      background: #00ffcc;
      transform: translateY(-2px);
    }
    
    .empty-state {
      color: #666;
      font-style: italic;
      text-align: center;
      padding: 15px;
    }
    
    .toggle-icon {
      color: #ff5100;
      font-size: 1.2rem;
      transition: transform 0.3s;
    }
    
    .toggle-icon.expanded {
      transform: rotate(180deg);
    }
    
    .controls {
      background: rgba(255,255,255,0.05);
      padding: 20px;
      border-radius: 12px;
      margin-bottom: 30px;
    }
    
    .btn {
      background: linear-gradient(135deg, #ff5100, #ff6a1f);
      color: white;
      border: 2px solid rgba(255, 255, 255, 0.3);
      padding: 18px 40px;
      border-radius: 14px;
      font-size: 1.2rem;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      box-shadow: 
        inset 0 0 20px -5px rgba(255, 255, 255, 0.3),
        0 8px 24px rgba(255, 81, 0, 0.4),
        0 4px 12px rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(10px);
    }
    
    .btn:hover {
      background: linear-gradient(135deg, #ff6a1f, #ff8438);
      transform: translateY(-3px);
      box-shadow: 
        inset 0 0 25px -5px rgba(255, 255, 255, 0.4),
        0 12px 32px rgba(255, 81, 0, 0.6),
        0 6px 16px rgba(0, 0, 0, 0.7);
    }
    
    .btn:active {
      transform: translateY(-1px);
      box-shadow: 
        inset 0 0 20px -5px rgba(255, 255, 255, 0.3),
        0 6px 20px rgba(255, 81, 0, 0.4),
        0 3px 10px rgba(0, 0, 0, 0.6);
    }
    
    .btn:disabled {
      background: linear-gradient(135deg, #333, #444);
      border-color: rgba(255, 255, 255, 0.1);
      cursor: not-allowed;
      transform: none;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
      opacity: 0.5;
    }
    
    .my-cards {
      background: rgba(0,212,170,0.1);
      border: 2px solid #00d4aa;
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 30px;
    }
    
    .my-cards h3 {
      color: #00d4aa;
      margin-bottom: 15px;
    }
    
    .cards-display {
      display: flex;
      gap: 10px;
    }
    
    .card {
      width: 80px;
      height: 112px;
      background-size: cover;
      background-position: center;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }
    
    .debug {
      background: rgba(255,255,255,0.03);
      padding: 15px;
      border-radius: 8px;
      font-family: 'Courier New', monospace;
      font-size: 0.85rem;
      color: #9aa3b2;
      max-height: 300px;
      overflow-y: auto;
    }
    
    .debug h4 {
      color: #ff5100;
      margin-bottom: 10px;
    }
    
    .status {
      padding: 8px 12px;
      border-radius: 6px;
      display: inline-block;
      margin-top: 10px;
    }
    
    .status.connected {
      background: rgba(0,212,170,0.2);
      color: #00d4aa;
    }
    
    .status.disconnected {
      background: rgba(255,59,59,0.2);
      color: #ff3b3b;
    }
  </style>
</head>
<body>
  <!-- üèÜ WINNER BANNER (hidden by default) -->
  <div class="winner-banner" id="winnerBanner"></div>
  
  <!-- üÉè SHOW/MUCK CONTROLS (showdown only) -->
  <div class="showdown-controls" id="showdownControls">
    <h3>üÉè Show your cards or muck?</h3>
    <div class="button-group">
      <button class="show-btn" onclick="showCards()">SHOW CARDS</button>
      <button class="muck-btn" onclick="muckCards()">MUCK</button>
    </div>
  </div>
  
  <div class="container">
    <h1>üé∞ PokerGeek Minimal Table</h1>
    
    <div class="room-info">
      <div>Room Code: <span class="room-code" id="roomCode">Loading...</span></div>
      <div>Room ID: <span id="roomId">-</span></div>
      <div>Your ID: <span id="userId">-</span> <span id="authBadge"></span></div>
      <div class="status disconnected" id="socketStatus">üî¥ Disconnected</div>
    </div>
    
    <!-- üéõÔ∏è HOST CONTROLS PANEL -->
    <div class="host-controls-panel" id="hostControlsPanel">
      <div class="host-controls-header" onclick="toggleHostControls()">
        <h3>
          üéõÔ∏è HOST CONTROLS
          <span class="host-badge">ONLY YOU</span>
        </h3>
        <span class="toggle-icon" id="hostToggleIcon">‚ñº</span>
      </div>
      <div class="host-controls-content" id="hostControlsContent">
        <!-- CURRENT PLAYERS -->
        <div class="host-section">
          <h4>üë• Current Players (<span id="hostPlayerCount">0</span>/9)</h4>
          <div class="player-list" id="hostPlayerList">
            <div class="empty-state">No players seated</div>
          </div>
        </div>
        
        <!-- BLIND CONTROLS -->
        <div class="host-section">
          <h4>üí∞ Blind Controls</h4>
          <div class="blinds-controls">
            <div class="blind-input-group">
              <label>Small Blind:</label>
              <input type="number" id="hostSmallBlindInput" value="10" min="1">
            </div>
            <div class="blind-input-group">
              <label>Big Blind:</label>
              <input type="number" id="hostBigBlindInput" value="20" min="2">
            </div>
            <button class="host-btn update" onclick="updateBlinds()">UPDATE BLINDS</button>
          </div>
        </div>
      </div>
    </div>
    
    <div class="controls">
      <button class="btn" id="startBtn" style="display:none">üéÆ START HAND</button>
      <button class="btn" id="refreshBtn">üîÑ REFRESH</button>
    </div>
    
    <!-- HIDDEN: Old top sections (deprecated - info now on table) -->
    <div style="display: none !important;">
      <div class="my-cards" id="communitySection">
        <div class="cards-display"></div>
        <span id="currentBet">0</span>
        <span id="currentBetDisplay">0</span>
      </div>
      
      <div class="my-cards" id="myCardsSection">
        <span id="turnIndicator"></span>
        <div class="cards-display" id="myCards"></div>
        <div id="handStrength">
          <div id="handStrengthText"></div>
        </div>
      </div>
    </div>
    
    <h2 style="margin-bottom: 15px;">Seats <span id="currentActor" style="font-size: 0.9rem; color: #ff5100; font-weight: normal;"></span></h2>
    
    <!-- üé∞ POKER TABLE (Zoom-Locked) -->
    <div class="table-wrapper" id="tableWrapper">
      <div class="poker-table" id="pokerTable">
        <!-- Oval Felt Background -->
        <div class="table-felt"></div>
        
        <!-- Board Center (Community Cards + Pot) -->
        <div class="board-center">
          <div class="community-cards-center" id="communityCards"></div>
          <div class="pot-display-center">
            <div class="pot-label">POT</div>
            <div class="pot-amount" id="potAmount">$0</div>
          </div>
        </div>
        
        <!-- Seats Layer -->
        <div class="seats-layer">
          <div class="seats-grid" id="seats"></div>
        </div>
      </div>
    </div>
    
    <!-- ACTION BUTTONS (Below Table) -->
    <div id="actionButtons" style="display:none; margin-top: 30px; display: flex; justify-content: center; gap: 15px;">
      <button class="btn" id="foldBtn" style="background: #ff3b3b;">FOLD</button>
      <button class="btn" id="callBtn" style="background: #00d4aa;"><span id="callBtnText">CALL</span> $<span id="callAmount">0</span></button>
      <button class="btn" id="raiseBtn" style="background: #ff5100;">RAISE</button>
    </div>
    
    <div class="debug">
      <h4>Debug Console</h4>
      <div id="debugLog"></div>
    </div>
  </div>
  
  <script src="/socket.io/socket.io.js"></script>
  <script>
    // ============================================
    // GLOBAL STATE
    // ============================================
    let roomId = null;
    let userId = null;
    let gameId = null;
    let socket = null;
    let isHost = false; // Track if current user is host
    let isClaimingSeat = false; // Prevent duplicate seat claims
    let currentGameState = null; // Track current game state for UI logic
    let myHoleCards = null; // Track user's hole cards to show on their seat tile
    
    // ============================================
    // UTILITY: DEBUG LOGGING
    // ============================================
    function debug(message, data = null) {
      console.log(message, data);
      const log = document.getElementById('debugLog');
      const time = new Date().toLocaleTimeString();
      const entry = document.createElement('div');
      entry.textContent = `[${time}] ${message}`;
      if (data) {
        entry.textContent += ' ' + JSON.stringify(data, null, 2);
      }
      log.appendChild(entry);
      log.scrollTop = log.scrollHeight;
    }
    
    // ============================================
    // UTILITY: CARD IMAGE PATH CONVERTER
    // ============================================
    function getCardImagePath(card) {
      // Convert "Ah" ‚Üí "hearts_A.png", "Ks" ‚Üí "spades_K.png", "Td" ‚Üí "diamonds_10.png"
      if (!card || card.length < 2) return '/cards/back.png';
      
      const rank = card.slice(0, -1); // "A", "K", "T", "2", etc.
      const suitChar = card.slice(-1); // "h", "s", "d", "c"
      
      const suitMap = {
        'h': 'hearts',
        's': 'spades',
        'd': 'diamonds',
        'c': 'clubs'
      };
      
      const rankMap = {
        'T': '10'
      };
      
      const suit = suitMap[suitChar] || 'hearts';
      const finalRank = rankMap[rank] || rank;
      
      return `/cards/${suit}_${finalRank}.png`;
    }
    
    // ============================================
    // STEP 1: INITIALIZE
    // ============================================
    function init() {
      debug('üé¨ Initializing minimal table...');
      
      // Get room ID from URL
      const urlParams = new URLSearchParams(window.location.search);
      roomId = urlParams.get('room');
      
      // PRIORITY 1: Check if user is authenticated via Supabase
      let isAuthenticated = false;
      
      try {
        // Check localStorage for Supabase session (standard location)
        const supabaseAuth = localStorage.getItem('sb-ztqcpuktihltfepnexcx-auth-token');
        if (supabaseAuth) {
          const authData = JSON.parse(supabaseAuth);
          if (authData && authData.user && authData.user.id) {
            userId = authData.user.id;
            isAuthenticated = true;
            sessionStorage.setItem('userId', userId);
            sessionStorage.setItem('userEmail', authData.user.email || 'Unknown');
            debug('‚úÖ Authenticated user detected:', { userId, email: authData.user.email });
          }
        }
      } catch (e) {
        debug('‚ö†Ô∏è Could not read Supabase auth:', e.message);
      }
      
      // PRIORITY 2: Try window.currentUser (if available)
      if (!userId && window.currentUser && window.currentUser.id) {
        userId = window.currentUser.id;
        isAuthenticated = true;
        sessionStorage.setItem('userId', userId);
        debug('‚úÖ Found window.currentUser:', userId);
      }
      
      // PRIORITY 3: Check sessionStorage
      if (!userId) {
        userId = sessionStorage.getItem('userId');
        
        // Validate UUID format (check if it's actually a UUID)
        const isValidUUID = userId && /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(userId);
        
        if (!isValidUUID) {
          // Clear invalid ID
          if (userId) {
            debug('‚ö†Ô∏è Invalid UUID detected, clearing:', userId);
            sessionStorage.removeItem('userId');
            userId = null;
          }
        }
      }
      
      // LAST RESORT: Generate guest UUID
      if (!userId) {
        userId = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
          const r = Math.random() * 16 | 0;
          const v = c === 'x' ? r : (r & 0x3 | 0x8);
          return v.toString(16);
        });
        sessionStorage.setItem('userId', userId);
        sessionStorage.setItem('isGuest', 'true');
        debug('‚ö†Ô∏è No auth found, generated guest UUID:', userId);
      }
      
      // Validate
      if (!roomId) {
        alert('‚ùå No room ID in URL. Redirecting to lobby...');
        window.location.href = '/play';
        return;
      }
      
      debug('‚úÖ Initialized', { roomId, userId });
      
      // Display IDs and auth status
      document.getElementById('roomId').textContent = roomId;
      document.getElementById('userId').textContent = userId;
      
      const authBadge = document.getElementById('authBadge');
      if (isAuthenticated) {
        const email = sessionStorage.getItem('userEmail');
        authBadge.textContent = `‚úÖ Authenticated (${email})`;
        authBadge.style.color = '#00d4aa';
        authBadge.style.fontWeight = 'bold';
      } else {
        authBadge.textContent = 'üë§ Guest';
        authBadge.style.color = '#FFC107';
      }
      
      // Wire up buttons
      document.getElementById('startBtn').onclick = startHand;
      document.getElementById('refreshBtn').onclick = loadRoom;
      
      // Connect WebSocket
      connectWebSocket();
      
      // CRITICAL: Hydrate game state before loading room
      hydrateGameState();
    }
    
    // ============================================
    // CRITICAL: HYDRATE GAME STATE ON REFRESH
    // ============================================
    async function hydrateGameState() {
      debug('üíß Hydrating game state...');
      
      try {
        const response = await fetch(`/api/engine/hydrate/${roomId}/${userId}`);
        
        if (!response.ok) {
          debug('‚ö†Ô∏è Hydration failed, loading lobby state');
          loadRoom();
          return;
        }
        
        const data = await response.json();
        
        if (!data.hasActiveGame) {
          debug('‚è∏Ô∏è  No active game - loading lobby');
          loadRoom();
          return;
        }
        
        // ACTIVE GAME FOUND - RESTORE STATE
        debug('üéÆ ACTIVE GAME FOUND - RESTORING STATE', {
          handNumber: data.gameState.handNumber,
          street: data.gameState.street,
          pot: data.gameState.pot
        });
        
        gameId = data.gameId;
        currentGameState = data.gameState; // Store for UI logic
        
        // Show community section
        document.getElementById('communitySection').style.display = 'block';
        
        // Render community cards
        if (data.gameState.communityCards && data.gameState.communityCards.length > 0) {
          renderCommunityCards(data.gameState.communityCards);
        }
        
        // Update pot and bet
        document.getElementById('potAmount').textContent = data.gameState.pot || 0;
        document.getElementById('currentBet').textContent = data.gameState.currentBet || 0;
        
        // Show current actor
        const actorText = document.getElementById('currentActor');
        if (data.gameState.currentActorSeat !== undefined) {
          actorText.textContent = `(Seat ${data.gameState.currentActorSeat}'s turn)`;
          actorText.style.display = 'inline';
        }
        
        // Render my hole cards
        if (data.myHoleCards && data.myHoleCards.length === 2) {
          myHoleCards = data.myHoleCards; // Store globally
          renderMyCards(data.myHoleCards);
        }
        
        // Show/hide action buttons based on turn
        const actionButtons = document.getElementById('actionButtons');
        if (data.isMyTurn && data.gameState.status === 'IN_PROGRESS') {
          actionButtons.style.display = 'flex';
          updateActionButtons(data.gameState);
        } else {
          actionButtons.style.display = 'none';
        }
        
        // Hide START button (game is active)
        document.getElementById('startBtn').style.display = 'none';
        
        // Update seat card backings (pass myHoleCards to show on my seat)
        updateSeatCardBackings(data.gameState, myHoleCards);
        
        // Update position badges (dealer, SB, BB)
        updatePositionBadges(data.gameState);
        
        debug('‚úÖ Game state restored successfully');
        
        // Still load room to get seat info
        loadRoom();
        
      } catch (error) {
        debug('‚ùå Hydration error', { error: error.message });
        console.error('Hydration error:', error);
        loadRoom(); // Fallback to normal flow
      }
    }
    
    // ============================================
    // STEP 2: WEBSOCKET CONNECTION
    // ============================================
    function connectWebSocket() {
      debug('üîå Connecting WebSocket...');
      
      socket = io();
      
      socket.on('connect', () => {
        debug('‚úÖ Socket connected', { socketId: socket.id });
        document.getElementById('socketStatus').textContent = 'üü¢ Connected';
        document.getElementById('socketStatus').className = 'status connected';
        
        // Join room
        socket.emit('join_room', { roomId, userId });
        debug('üì° Sent join_room event', { roomId, userId });
      });
      
      socket.on('disconnect', (reason) => {
        debug('üî¥ Socket disconnected', { reason });
        document.getElementById('socketStatus').textContent = 'üî¥ Disconnected';
        document.getElementById('socketStatus').className = 'status disconnected';
      });
      
      socket.on('seat_update', (data) => {
        debug('ü™ë Seat update received', data);
        loadRoom();
      });
      
      socket.on('hand_started', (data) => {
        debug('üÉè Hand started event', data);
        
        // CRITICAL: Clear UI from previous hand (especially for guests)
        document.getElementById('communityCards').innerHTML = '';
        document.getElementById('myCards').innerHTML = '';
        document.getElementById('actionButtons').style.display = 'none';
        document.getElementById('handStrength').style.display = 'none';
        document.getElementById('myCardsSection').style.display = 'none';
        document.getElementById('startBtn').style.display = 'none';
        
        // Store game state ID
        if (data.gameStateId) {
          gameId = data.gameStateId;
        }
        
        // Display public game state
        if (data.gameState) {
          const gs = data.gameState;
          currentGameState = gs; // Store for UI logic
          
          // Show community section
          document.getElementById('communitySection').style.display = 'block';
          document.getElementById('potAmount').textContent = gs.pot || 0;
          document.getElementById('currentBet').textContent = gs.currentBet || 0;
          
          // Show current actor
          const actorText = document.getElementById('currentActor');
          if (gs.currentActorSeat !== undefined) {
            actorText.textContent = `(Seat ${gs.currentActorSeat}'s turn)`;
            actorText.style.display = 'inline';
          }
          
          debug('‚úÖ Game state updated', { pot: gs.pot, currentBet: gs.currentBet, street: gs.street });
          
          // Update seat card backings (pass myHoleCards to show on my seat)
          updateSeatCardBackings(gs, myHoleCards);
          
          // Update position badges (dealer, SB, BB)
          updatePositionBadges(gs);
        }
        
        // Fetch my hole cards (for guests who didn't initiate the hand)
        fetchMyCards();
        
        // Reload to show updated seats/chips
        setTimeout(loadRoom, 500);
      });
      
      // Listen for action processed events
      socket.on('action_processed', (data) => {
        debug('üéÆ Action processed', data);
        
        // Update game state display
        if (data.gameState) {
          const gs = data.gameState;
          currentGameState = gs; // Store for UI logic
          
          document.getElementById('potAmount').textContent = gs.pot || 0;
          document.getElementById('currentBet').textContent = gs.currentBet || 0;
          
          // Update current actor
          const actorText = document.getElementById('currentActor');
          if (gs.currentActorSeat !== undefined) {
            actorText.textContent = `(Seat ${gs.currentActorSeat}'s turn)`;
          }
          
          // Show community cards if any
          if (gs.communityCards && gs.communityCards.length > 0) {
            renderCommunityCards(gs.communityCards);
          }
          
          // CRITICAL: Show/hide action buttons based on whose turn it is
          const actionButtons = document.getElementById('actionButtons');
          const myPlayer = gs.players?.find(p => p.userId === userId);
          const isMyTurn = myPlayer && gs.currentActorSeat === myPlayer.seatIndex;
          
          if (isMyTurn && gs.status === 'IN_PROGRESS') {
            actionButtons.style.display = 'flex';
            updateActionButtons(gs);
            debug('‚úÖ Your turn - action buttons shown');
          } else {
            actionButtons.style.display = 'none';
            debug('‚è∏Ô∏è  Not your turn - action buttons hidden');
          }
          
          // Check if hand is over
          if (gs.status === 'COMPLETED') {
            handleHandComplete(gs);
          }
          
          // Update seat card backings (show folds, etc) (pass myHoleCards to show on my seat)
          updateSeatCardBackings(gs, myHoleCards);
          
          // Update position badges (dealer, SB, BB)
          updatePositionBadges(gs);
          
          // Update chips in real-time (CRITICAL: show chip stacks decreasing as players bet)
          updateSeatChips(gs.players);
        }
      });
      
      // Listen for showdown actions (show/muck)
      socket.on('showdown_action', (data) => {
        debug('üÉè Showdown action received:', data);
        
        const { action, seatIndex, nickname, holeCards } = data;
        
        if (action === 'SHOW' && holeCards) {
          // REPLACE card backs with actual card images
          const cardBacksContainer = document.querySelector(`.seat-cards[data-seat-index="${seatIndex}"]`);
          if (cardBacksContainer) {
            cardBacksContainer.innerHTML = ''; // Clear card backs
            
            // Display actual cards using images
            holeCards.forEach(card => {
              const cardImg = document.createElement('img');
              cardImg.className = 'seat-card-front';
              cardImg.src = getCardImagePath(card);
              cardImg.alt = card;
              cardImg.onerror = function() {
                // Fallback if image doesn't exist
                this.src = '/cards/back.png';
              };
              cardBacksContainer.appendChild(cardImg);
            });
            
            debug(`‚úÖ @${nickname} showed cards: ${holeCards.join(' ')}`);
          }
        } else if (action === 'MUCK') {
          // Grey out card backs (already folded styling)
          const cardBacksContainer = document.querySelector(`.seat-cards[data-seat-index="${seatIndex}"]`);
          if (cardBacksContainer) {
            const cardBacks = cardBacksContainer.querySelectorAll('.seat-card-back');
            cardBacks.forEach(back => {
              back.classList.add('folded'); // Grey them out
            });
            
            debug(`‚úÖ @${nickname} mucked cards`);
          }
        }
      });
      
      // NOTE: Private hole cards are sent via HTTP response in startHand()
      // We'll add WebSocket private emit in Phase 2b
      
      socket.on('game_started', (data) => {
        debug('üéÆ Game started event', data);
        if (data.gameId) {
          gameId = data.gameId;
        }
        setTimeout(loadRoom, 1000);
      });
      
      // Host control events
      socket.on('blinds_updated', (data) => {
        debug('üí∞ Blinds updated by host', data);
        // No blocking alert - blinds update will show in next hand
      });
      
      socket.on('player_kicked', (data) => {
        if (data.userId === userId) {
          alert('‚ùå You have been removed from the game by the host.');
          window.location.href = '/';
        }
      });
    }
    
    // ============================================
    // STEP 3: LOAD ROOM STATE
    // ============================================
    async function loadRoom() {
      debug('üåä Fetching room state...');
      
      try {
        // Get room info
        const roomResponse = await fetch(`/api/engine/room/${roomId}`);
        if (!roomResponse.ok) {
          throw new Error(`Failed to get room: ${roomResponse.status}`);
        }
        const roomData = await roomResponse.json();
        debug('‚úÖ Room data received', roomData);
        
        // Get seats
        const seatsResponse = await fetch(`/api/engine/seats/${roomId}`);
        if (!seatsResponse.ok) {
          throw new Error(`Failed to get seats: ${seatsResponse.status}`);
        }
        const seatsData = await seatsResponse.json();
        debug('‚úÖ Seats data received', seatsData);
        
        // Update room code
        document.getElementById('roomCode').textContent = roomData.room?.code || 'N/A';
        
        // Store game ID if exists
        if (roomData.room?.gameId) {
          gameId = roomData.room.gameId;
        }
        
        // Render seats
        renderSeats(seatsData.seats, roomData.room);
        
        // Show START button ONLY if:
        // 1. Room status is NOT ACTIVE (no game in progress)
        // 2. 2+ players seated
        // 3. User is host (or show "waiting" if not host)
        const seatedCount = seatsData.occupiedCount || 0;
        isHost = roomData.room?.hostId === userId; // Update global isHost
        const roomIsActive = roomData.room?.status === 'ACTIVE';
        
        // CRITICAL: If room is ACTIVE, NEVER show START button (game is in progress)
        if (roomIsActive) {
          document.getElementById('startBtn').style.display = 'none';
          debug('üéÆ Game active - START button hidden');
        } else if (isHost && seatedCount >= 2) {
          document.getElementById('startBtn').style.display = 'inline-block';
          document.getElementById('startBtn').disabled = false;
          document.getElementById('startBtn').textContent = 'üéÆ START HAND';
          debug('üéÆ START HAND button enabled (HOST)', { seatedCount });
        } else if (!isHost && seatedCount >= 2) {
          document.getElementById('startBtn').style.display = 'inline-block';
          document.getElementById('startBtn').disabled = true;
          document.getElementById('startBtn').textContent = '‚è≥ WAITING FOR HOST';
          debug('‚è≥ Waiting for host to start', { hostId: roomData.room?.hostId });
        } else {
          document.getElementById('startBtn').style.display = 'none';
        }
        
        // Load host controls if user is host
        if (isHost) {
          loadHostControls();
        }
        
      } catch (error) {
        debug('‚ùå Load room error', { error: error.message });
        console.error('Load room error:', error);
      }
    }
    
    // ============================================
    // STEP 4: RENDER SEATS
    // ============================================
    function renderSeats(seats, room) {
      debug('üé® Rendering seats...', { seatCount: seats ? seats.length : 0 });
      
      const seatsDiv = document.getElementById('seats');
      seatsDiv.innerHTML = '';
      
      // Check if game is active (hide empty seats during game)
      const isGameActive = currentGameState && (currentGameState.status === 'IN_PROGRESS' || currentGameState.status === 'COMPLETED');
      
      // Create 9 seats (0-8)
      for (let i = 0; i < 9; i++) {
        const seat = seats ? seats[i] : null;
        const isEmpty = !seat || !seat.userId;
        
        // Skip empty seats if game is active
        if (isEmpty && isGameActive) {
          debug(`‚è© Skipping empty seat ${i} (game active)`);
          continue;
        }
        
        const div = document.createElement('div');
        const isMe = seat && seat.userId === userId;
        
        div.className = 'seat';
        div.dataset.seatIndex = i; // Add data attribute for positioning
        if (isEmpty) {
          div.className += ' empty';
        } else if (isMe) {
          div.className += ' taken me';
        } else {
          div.className += ' taken';
        }
        
        const label = document.createElement('div');
        label.className = 'seat-label';
        label.textContent = `Seat ${i}`;
        
        const player = document.createElement('div');
        player.className = 'seat-player';
        
        const chips = document.createElement('div');
        chips.className = 'seat-chips';
        
        // Card backings container
        const cardBacksContainer = document.createElement('div');
        cardBacksContainer.className = 'seat-cards';
        cardBacksContainer.dataset.seatIndex = i;
        
        // Position badges container (dealer, SB, BB)
        const positionBadges = document.createElement('div');
        positionBadges.className = 'position-badges';
        positionBadges.dataset.seatIndex = i;
        
        if (isEmpty) {
          player.textContent = 'ü™ë EMPTY';
          chips.textContent = 'Click to claim';
          div.onclick = () => claimSeat(i);
        } else {
          // Display nickname with @ symbol
          const displayName = seat.nickname || `Guest_${seat.userId.substring(0, 6)}`;
          player.textContent = `@${displayName}`;
          if (isMe) player.textContent += ' (YOU)';
          chips.textContent = `$${(seat.chips || 1000).toLocaleString()}`;
        }
        
        div.appendChild(label);
        div.appendChild(player);
        div.appendChild(chips);
        div.appendChild(cardBacksContainer); // Add card backs container
        div.appendChild(positionBadges); // Add position badges
        
        seatsDiv.appendChild(div);
      }
      
      // Apply circular positions
      applySeatPositions();
      
      // Update card backings if game is active (pass myHoleCards to show on my seat)
      if (currentGameState) {
        updateSeatCardBackings(currentGameState, myHoleCards);
      }
      
      debug('‚úÖ Seats rendered');
    }
    
    // ============================================
    // STEP 4B: UPDATE SEAT CHIPS IN REAL-TIME
    // ============================================
    function updateSeatChips(players) {
      if (!players) return;
      
      debug('üí∞ Updating seat chips', { playerCount: players.length });
      
      players.forEach(player => {
        // Find the seat element
        const seatsDiv = document.getElementById('seats');
        const seatDivs = seatsDiv.querySelectorAll('.seat');
        
        seatDivs.forEach(seatDiv => {
          const label = seatDiv.querySelector('.seat-label');
          if (label && label.textContent === `Seat ${player.seatIndex}`) {
            // Update chips display
            const chipsDiv = seatDiv.querySelector('.seat-chips');
            if (chipsDiv && !chipsDiv.textContent.includes('Click to claim')) {
              chipsDiv.textContent = `$${(player.chips || 0).toLocaleString()}`;
            }
          }
        });
      });
    }
    
    // ============================================
    // STEP 4B2: UPDATE POSITION BADGES (DEALER, SB, BB)
    // ============================================
    function updatePositionBadges(gameState) {
      if (!gameState) return;
      
      debug('üé∞ Updating position badges', { 
        dealer: gameState.dealerPosition, 
        sb: gameState.sbPosition, 
        bb: gameState.bbPosition 
      });
      
      // Clear all existing badges first
      document.querySelectorAll('.position-badges').forEach(container => {
        container.innerHTML = '';
      });
      
      // Show badges during active game or showdown
      if (gameState.status !== 'IN_PROGRESS' && gameState.status !== 'COMPLETED') return;
      
      // Add dealer badge
      if (gameState.dealerPosition !== undefined) {
        const dealerContainer = document.querySelector(`.position-badges[data-seat-index="${gameState.dealerPosition}"]`);
        if (dealerContainer) {
          const badge = document.createElement('span');
          badge.className = 'position-badge dealer';
          badge.textContent = 'D';
          badge.title = 'Dealer';
          dealerContainer.appendChild(badge);
        }
      }
      
      // Add small blind badge
      if (gameState.sbPosition !== undefined) {
        const sbContainer = document.querySelector(`.position-badges[data-seat-index="${gameState.sbPosition}"]`);
        if (sbContainer) {
          const badge = document.createElement('span');
          badge.className = 'position-badge sb';
          badge.textContent = 'SB';
          badge.title = 'Small Blind';
          sbContainer.appendChild(badge);
        }
      }
      
      // Add big blind badge
      if (gameState.bbPosition !== undefined) {
        const bbContainer = document.querySelector(`.position-badges[data-seat-index="${gameState.bbPosition}"]`);
        if (bbContainer) {
          const badge = document.createElement('span');
          badge.className = 'position-badge bb';
          badge.textContent = 'BB';
          badge.title = 'Big Blind';
          bbContainer.appendChild(badge);
        }
      }
    }
    
    // ============================================
    // STEP 4C: UPDATE CARD BACKINGS ON SEATS
    // ============================================
    function updateSeatCardBackings(gameState, myHoleCards = null) {
      if (!gameState || !gameState.players) {
        debug('‚ö†Ô∏è No gameState or players for card backings');
        return;
      }
      
      debug('üÉè Updating seat card backings', { 
        players: gameState.players.length, 
        status: gameState.status,
        playerSeats: gameState.players.map(p => p.seatIndex),
        myHoleCards: myHoleCards
      });
      
      // Loop through all seats
      for (let i = 0; i < 9; i++) {
        const cardBacksContainer = document.querySelector(`.seat-cards[data-seat-index="${i}"]`);
        if (!cardBacksContainer) {
          debug(`‚ö†Ô∏è No card backs container found for seat ${i}`);
          continue;
        }
        
        // Find player in this seat
        const player = gameState.players.find(p => p.seatIndex === i);
        
        // Clear existing card backs
        cardBacksContainer.innerHTML = '';
        
        // Show card backs for IN_PROGRESS or COMPLETED (showdown)
        const shouldShowCards = player && (gameState.status === 'IN_PROGRESS' || gameState.status === 'COMPLETED');
        
        if (shouldShowCards) {
          const isMe = player.userId === userId;
          
          // If it's MY seat and I have hole cards, show actual cards
          if (isMe && myHoleCards && myHoleCards.length === 2) {
            debug(`‚úÖ Adding MY actual cards for seat ${i}`, { cards: myHoleCards });
            myHoleCards.forEach(card => {
              const cardImg = document.createElement('img');
              cardImg.className = 'seat-card-front';
              cardImg.src = getCardImagePath(card);
              cardImg.alt = card;
              cardImg.onerror = function() {
                this.src = '/cards/back.png';
              };
              cardBacksContainer.appendChild(cardImg);
            });
          } else {
            // Other players - show card backs
            debug(`‚úÖ Adding card backs for seat ${i} (folded: ${player.folded}, status: ${gameState.status})`);
            for (let j = 0; j < 2; j++) {
              const cardBack = document.createElement('img');
              cardBack.className = 'seat-card-back';
              cardBack.src = '/cards/back.png';
              cardBack.alt = 'Card';
              
              // Grey out if folded
              if (player.folded) {
                cardBack.classList.add('folded');
              }
              
              cardBacksContainer.appendChild(cardBack);
            }
          }
        } else {
          debug(`‚ùå Not showing cards for seat ${i} (hasPlayer: ${!!player}, status: ${gameState.status})`);
        }
      }
    }
    
    // ============================================
    // STEP 5: CLAIM SEAT
    // ============================================
    async function claimSeat(seatIndex) {
      // Prevent duplicate calls
      if (isClaimingSeat) {
        debug('‚è∏Ô∏è  Already claiming a seat, ignoring duplicate call');
        return;
      }
      
      isClaimingSeat = true;
      debug(`ü™ë Attempting to claim seat ${seatIndex}...`);
      
      // Prompt for nickname
      const nickname = prompt(
        'üéÆ Choose your nickname (3-15 characters):\n\n' +
        'Letters, numbers, and underscores only.\n' +
        'Leave blank for auto-generated name.',
        ''
      );
      
      // User cancelled
      if (nickname === null) {
        isClaimingSeat = false;
        return;
      }
      
      // Validate nickname if provided
      if (nickname && (nickname.length < 3 || nickname.length > 15)) {
        console.error('Nickname must be 3-15 characters');
        isClaimingSeat = false;
        return;
      }
      
      if (nickname && !/^[a-zA-Z0-9_]+$/.test(nickname)) {
        console.error('Nickname can only contain letters, numbers, and underscores');
        isClaimingSeat = false;
        return;
      }
      
      try {
        const response = await fetch(`/api/engine/claim-seat`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            roomId: roomId,
            userId: userId,
            seatIndex: seatIndex,
            nickname: nickname || undefined
          })
        });
        
        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || 'Failed to claim seat');
        }
        
        const data = await response.json();
        const displayName = data.seat.nickname || `Guest_${userId.substring(0, 6)}`;
        debug('‚úÖ Seat claimed successfully', { displayName, seatIndex });
        
        // Reload room state
        setTimeout(() => {
          loadRoom();
          isClaimingSeat = false; // Reset flag after reload
        }, 500);
        
      } catch (error) {
        debug('‚ùå Claim seat error', { error: error.message });
        console.error('Failed to claim seat:', error.message);
        isClaimingSeat = false; // Reset flag on error
      }
    }
    
    // ============================================
    // STEP 6: START HAND / NEXT HAND
    // ============================================
    async function startHand() {
      const btn = document.getElementById('startBtn');
      const isNextHand = btn.textContent.includes('NEXT');
      
      debug(isNextHand ? 'üé¨ Starting NEXT hand...' : 'üéÆ Starting FIRST hand...');
      
      try {
        // Clear UI before starting new hand
        myHoleCards = null; // Clear stored hole cards
        document.getElementById('communityCards').innerHTML = '';
        document.getElementById('myCards').innerHTML = '';
        document.getElementById('potAmount').textContent = '0';
        document.getElementById('currentBet').textContent = '0';
        document.getElementById('actionButtons').style.display = 'none';
        document.getElementById('handStrength').style.display = 'none';
        document.getElementById('myCardsSection').style.display = 'none';
        
        // Use correct endpoint
        const endpoint = isNextHand ? '/api/engine/next-hand' : '/api/engine/deal-cards';
        
        const response = await fetch(endpoint, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            roomId: roomId,
            userId: userId
          })
        });
        
        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || 'Failed to start hand');
        }
        
        const data = await response.json();
        debug('‚úÖ Hand started', data);
        
        // Store game state ID
        if (data.gameStateId) {
          gameId = data.gameStateId;
        }
        
        // Show game state immediately
        if (data.gameState) {
          const gs = data.gameState;
          
          document.getElementById('communitySection').style.display = 'block';
          document.getElementById('potAmount').textContent = gs.pot || 0;
          document.getElementById('currentBet').textContent = gs.currentBet || 0;
          
          const actorText = document.getElementById('currentActor');
          if (gs.currentActorSeat !== undefined) {
            actorText.textContent = `(Seat ${gs.currentActorSeat}'s turn)`;
            actorText.style.display = 'inline';
          }
          
          // Show hand number
          if (gs.handNumber) {
            debug(`üìä Hand #${gs.handNumber}`);
          }
          
          debug('‚úÖ Game state displayed', { pot: gs.pot, currentBet: gs.currentBet, handNumber: gs.handNumber });
        }
        
        // Show cards
        if (data.cards && data.cards.length === 2) {
          myHoleCards = data.cards; // Store globally
          renderMyCards(data.cards);
        }
        
        // Reset button text
        btn.textContent = 'üéÆ START HAND';
        btn.style.display = 'none';
        
        // Reload seats to show updated chips
        setTimeout(loadRoom, 500);
        
      } catch (error) {
        debug('‚ùå Start hand error', { error: error.message });
        alert('‚ùå Failed to start hand: ' + error.message);
      }
    }
    
    // ============================================
    // STEP 7: RENDER MY CARDS
    // ============================================
    async function renderMyCards(cards) {
      debug('üÉè Rendering hole cards', { cards });
      
      const section = document.getElementById('myCardsSection');
      const cardsDiv = document.getElementById('myCards');
      
      section.style.display = 'block';
      cardsDiv.innerHTML = '';
      
      cards.forEach(card => {
        const cardImg = document.createElement('img');
        cardImg.className = 'card card-img';
        cardImg.src = getCardImagePath(card);
        cardImg.alt = card;
        cardImg.onerror = function() {
          // Fallback if image doesn't exist
          this.src = '/cards/back.png';
        };
        cardsDiv.appendChild(cardImg);
      });
      
      // Show action buttons
      document.getElementById('actionButtons').style.display = 'flex';
      
      // Fetch game state to calculate correct call amount
      try {
        const gameStateResponse = await fetch(`/api/engine/game/${roomId}`);
        if (gameStateResponse.ok) {
          const gameData = await gameStateResponse.json();
          
          // Find my player
          const myPlayer = gameData.players?.find(p => p.userId === userId);
          const currentBet = gameData.currentBet || 0;
          const myBet = myPlayer?.bet || 0;
          const callAmount = currentBet - myBet;
          
          // Update call button text - CHECK or CALL
          const callBtn = document.getElementById('callBtn');
          const callBtnText = document.getElementById('callBtnText');
          const callAmountSpan = document.getElementById('callAmount');
          
          if (callAmount === 0) {
            // It's a check
            callBtnText.textContent = 'CHECK';
            callAmountSpan.style.display = 'none';
            callBtn.onclick = () => performAction('CHECK', 0);
          } else {
            // It's a call
            callBtnText.textContent = 'CALL';
            callAmountSpan.style.display = 'inline';
            callAmountSpan.textContent = callAmount;
            callBtn.onclick = () => performAction('CALL', callAmount);
          }
          
          // Wire up other buttons
          document.getElementById('foldBtn').onclick = () => performAction('FOLD', 0);
          document.getElementById('raiseBtn').onclick = () => {
            const minRaise = currentBet * 2 || 20;
            const amount = prompt(`Raise to how much? (min: $${minRaise})`, minRaise.toString());
            if (amount) performAction('RAISE', parseInt(amount));
          };
          
          // Evaluate and display hand strength
          evaluateHandStrength(cards, gameData.communityCards || []);
        }
      } catch (error) {
        debug('‚ö†Ô∏è Could not fetch game state for call amount', error);
        // Fallback
        document.getElementById('foldBtn').onclick = () => performAction('FOLD', 0);
        document.getElementById('callBtn').onclick = () => performAction('CHECK', 0);
        document.getElementById('raiseBtn').onclick = () => {
          const amount = prompt('Raise to how much?', '20');
          if (amount) performAction('RAISE', parseInt(amount));
        };
      }
      
      debug('‚úÖ Cards rendered, actions enabled');
    }
    
    // ============================================
    // STEP 7B: FETCH MY HOLE CARDS
    // ============================================
    async function fetchMyCards() {
      debug('üîí Fetching my hole cards...');
      
      try {
        const response = await fetch(`/api/engine/my-cards/${roomId}/${userId}`);
        
        if (!response.ok) {
          const error = await response.json();
          console.log('‚ö†Ô∏è Could not fetch cards:', error.error);
          return; // Not an error - might not be in this hand
        }
        
        const data = await response.json();
        debug('‚úÖ My cards fetched', data);
        
        if (data.cards && data.cards.length === 2) {
          myHoleCards = data.cards; // Store globally
          renderMyCards(data.cards);
        }
        
      } catch (error) {
        debug('‚ö†Ô∏è Fetch my cards error', { error: error.message });
      }
    }
    
    // ============================================
    // STEP 8: PERFORM ACTION
    // ============================================
    async function performAction(action, amount) {
      debug(`üéÆ Performing action: ${action} $${amount}`);
      
      try {
        const response = await fetch('/api/engine/action', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            roomId: roomId,
            userId: userId,
            action: action,
            amount: amount
          })
        });
        
        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || 'Failed to perform action');
        }
        
        const data = await response.json();
        debug('‚úÖ Action performed', data);
        
        // UI will update via WebSocket broadcast automatically
        
      } catch (error) {
        debug('‚ùå Action error', { error: error.message });
        // Silently ignore "Hand is complete" errors - this is expected at showdown
        if (error.message.includes('Hand is complete')) {
          debug('‚ÑπÔ∏è Hand already complete - ignoring action');
          return;
        }
        // For other errors, just log them (no blocking alert)
        console.error('Action failed:', error.message);
      }
    }
    
    // ============================================
    // STEP 8A: UPDATE ACTION BUTTONS
    // ============================================
    function updateActionButtons(gameState) {
      // Find my player
      const myPlayer = gameState.players?.find(p => p.userId === userId);
      if (!myPlayer) return;
      
      const currentBet = gameState.currentBet || 0;
      const myBet = myPlayer.bet || 0;
      const callAmount = currentBet - myBet;
      
      debug('üîÑ Updating buttons', { currentBet, myBet, callAmount, isMyTurn: gameState.currentActorSeat === myPlayer.seatIndex });
      
      // Update call button text - CHECK or CALL
      const callBtn = document.getElementById('callBtn');
      const callBtnText = document.getElementById('callBtnText');
      const callAmountSpan = document.getElementById('callAmount');
      
      if (callAmount === 0) {
        // It's a check
        callBtnText.textContent = 'CHECK';
        callAmountSpan.style.display = 'none';
        callBtn.onclick = () => performAction('CHECK', 0);
      } else {
        // It's a call
        callBtnText.textContent = 'CALL';
        callAmountSpan.style.display = 'inline';
        callAmountSpan.textContent = callAmount;
        callBtn.onclick = () => performAction('CALL', callAmount);
      }
      
      // Update fold button
      document.getElementById('foldBtn').onclick = () => performAction('FOLD', 0);
      
      // Update raise button
      document.getElementById('raiseBtn').onclick = () => {
        const minRaise = currentBet * 2 || 20;
        const amount = prompt(`Raise to how much? (min: $${minRaise})`, minRaise.toString());
        if (amount) performAction('RAISE', parseInt(amount));
      };
    }
    
    // ============================================
    // STEP 8B: HANDLE HAND COMPLETE
    // ============================================
    function handleHandComplete(gameState) {
      debug('üèÜ Hand complete', gameState);
      
      // Hide action buttons
      document.getElementById('actionButtons').style.display = 'none';
      document.getElementById('handStrength').style.display = 'none';
      
      if (gameState.winners && gameState.winners.length > 0) {
        const winner = gameState.winners[0];
        const potAmount = winner.amount;
        
        debug(`üèÜ Winner: Seat ${winner.seatIndex} wins $${potAmount}`);
        
        // 1. KEEP POT VISIBLE (don't zero it yet)
        document.getElementById('potAmount').textContent = potAmount;
        
        // 2. HIGHLIGHT WINNER'S SEAT
        highlightWinnerSeat(winner.seatIndex);
        
        // 3. SHOW WINNER BANNER
        const banner = document.getElementById('winnerBanner');
        const winnerPlayer = gameState.players.find(p => p.seatIndex === winner.seatIndex);
        const winnerNickname = winnerPlayer ? `@${winnerPlayer.nickname || 'Player'}` : `Seat ${winner.seatIndex}`;
        
        banner.innerHTML = `üèÜ ${winnerNickname} WINS $${potAmount.toLocaleString()}<br><small style="font-size:1.2rem;">${winner.handDescription}</small>`;
        banner.classList.add('show');
        
        // 4. SHOW/MUCK CONTROLS FOR NON-WINNERS
        // Keep controls visible for ENTIRE 5-second countdown
        const myPlayer = gameState.players?.find(p => p.userId === userId);
        const didIWin = myPlayer && myPlayer.seatIndex === winner.seatIndex;
        const didIFold = myPlayer && myPlayer.folded;
        
        debug('üÉè Show/muck check:', {
          hasMyPlayer: !!myPlayer,
          myUserId: userId,
          mySeatIndex: myPlayer?.seatIndex,
          winnerSeatIndex: winner.seatIndex,
          didIWin,
          didIFold
        });
        
        // Only show controls if: I didn't win, I didn't fold, and I'm in the hand
        if (myPlayer && !didIWin && !didIFold) {
          debug('üÉè Showing show/muck controls (you didn\'t win)');
          document.getElementById('showdownControls').classList.add('show');
        } else {
          debug('üÉè NOT showing controls', { myPlayer: !!myPlayer, didIWin, didIFold });
        }
        
        // 5. AFTER 3 SECONDS: Hide banner, transfer chips, START COUNTDOWN
        setTimeout(() => {
          // Hide banner only (keep show/muck controls visible)
          banner.classList.remove('show');
          
          // Clear winner highlight
          clearWinnerHighlight();
          
          // Update all seat chips (show final amounts)
          updateSeatChips(gameState.players);
          
          // Zero the pot (chips now in winner's stack)
          document.getElementById('potAmount').textContent = '0';
          
          // START COUNTDOWN FOR NEXT HAND
          const startBtn = document.getElementById('startBtn');
          startBtn.style.display = 'inline-block';
          startBtn.disabled = true;
          
          let countdown = 5;
          startBtn.textContent = `‚è∞ NEXT HAND (${countdown}s)`;
          
          const countdownInterval = setInterval(() => {
            countdown--;
            if (countdown > 0) {
              startBtn.textContent = `‚è∞ NEXT HAND (${countdown}s)`;
            } else {
              clearInterval(countdownInterval);
              
              // Hide show/muck controls when countdown finishes
              document.getElementById('showdownControls').classList.remove('show');
              
              if (isHost) {
                startBtn.textContent = '‚ñ∂Ô∏è STARTING...';
                debug('üé¨ Auto-starting next hand (HOST)...');
                startHand();
              } else {
                startBtn.textContent = '‚è≥ STARTING...';
                debug('‚è≥ Waiting for host to start next hand (GUEST)');
              }
            }
          }, 1000);
          
        }, 3000); // 3 second delay to show winner
      }
    }
    
    // Helper: Highlight winner's seat
    function highlightWinnerSeat(seatIndex) {
      const seatsDiv = document.getElementById('seats');
      const seatDivs = seatsDiv.querySelectorAll('.seat');
      
      seatDivs.forEach(seatDiv => {
        const label = seatDiv.querySelector('.seat-label');
        if (label && label.textContent === `Seat ${seatIndex}`) {
          seatDiv.classList.add('winner');
        }
      });
    }
    
    // Helper: Clear winner highlight
    function clearWinnerHighlight() {
      const seatsDiv = document.getElementById('seats');
      const seatDivs = seatsDiv.querySelectorAll('.seat.winner');
      seatDivs.forEach(seatDiv => {
        seatDiv.classList.remove('winner');
      });
    }
    
    // ============================================
    // SHOW/MUCK FUNCTIONALITY
    // ============================================
    async function showCards() {
      debug('üÉè Player chose to SHOW cards');
      
      try {
        const response = await fetch('/api/engine/showdown-action', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            roomId: roomId,
            userId: userId,
            action: 'SHOW'
          })
        });
        
        if (!response.ok) {
          const error = await response.json();
          console.error('‚ùå Show cards error:', error);
          debug('‚ùå Show cards failed', error);
          return;
        }
        
        const result = await response.json();
        debug('‚úÖ Cards shown to table', result);
        
        // Hide controls
        document.getElementById('showdownControls').classList.remove('show');
        
        // NO NEED to manually display - WebSocket will handle it for all players
        
      } catch (error) {
        console.error('‚ùå Show cards network error:', error);
        debug('‚ùå Show cards network error', { error: error.message });
      }
    }
    
    async function muckCards() {
      debug('üóëÔ∏è Player chose to MUCK cards');
      
      try {
        const response = await fetch('/api/engine/showdown-action', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            roomId: roomId,
            userId: userId,
            action: 'MUCK'
          })
        });
        
        if (!response.ok) {
          const error = await response.json();
          console.error('‚ùå Muck cards error:', error);
          debug('‚ùå Muck cards failed', error);
          return;
        }
        
        const result = await response.json();
        debug('‚úÖ Cards mucked', result);
        
        // Hide controls
        document.getElementById('showdownControls').classList.remove('show');
        
      } catch (error) {
        console.error('‚ùå Muck cards network error:', error);
        debug('‚ùå Muck cards network error', { error: error.message });
      }
    }
    
    // ============================================
    // STEP 8C: RENDER COMMUNITY CARDS
    // ============================================
    function renderCommunityCards(cards) {
      debug('üÉè Rendering community cards', { cards });
      
      const communityDiv = document.getElementById('communityCards');
      communityDiv.innerHTML = '';
      
      cards.forEach(card => {
        const cardImg = document.createElement('img');
        cardImg.className = 'card-img';
        cardImg.src = getCardImagePath(card);
        cardImg.alt = card;
        cardImg.onerror = function() {
          // Fallback if image doesn't exist
          this.src = '/cards/back.png';
        };
        communityDiv.appendChild(cardImg);
      });
      
      document.getElementById('communitySection').style.display = 'block';
      
      // Re-evaluate hand strength when community cards change
      const myCardsDiv = document.getElementById('myCards');
      if (myCardsDiv && myCardsDiv.dataset.cards) {
        const myCards = JSON.parse(myCardsDiv.dataset.cards);
        evaluateHandStrength(myCards, cards);
      }
    }
    
    // ============================================
    // STEP 8D: EVALUATE AND DISPLAY HAND STRENGTH
    // ============================================
    function evaluateHandStrength(holeCards, communityCards) {
      // Store cards for re-evaluation
      const myCardsDiv = document.getElementById('myCards');
      myCardsDiv.dataset.cards = JSON.stringify(holeCards);
      
      if (!holeCards || holeCards.length !== 2) return;
      if (!communityCards) communityCards = [];
      
      const allCards = [...holeCards, ...communityCards];
      
      // Simple hand evaluation (client-side approximation)
      const handDescription = getSimpleHandDescription(allCards);
      
      // Display
      const strengthDiv = document.getElementById('handStrength');
      const textDiv = document.getElementById('handStrengthText');
      
      if (handDescription) {
        textDiv.textContent = handDescription;
        strengthDiv.style.display = 'block';
        debug('üé¥ Hand strength:', handDescription);
      }
    }
    
    /**
     * Simple client-side hand evaluation
     * Returns description like "Pair of AA", "Two Pair - QQ33"
     */
    function getSimpleHandDescription(cards) {
      if (cards.length < 2) return 'Incomplete Hand';
      
      // Parse ranks
      const rankMap = { '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, 'T': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14 };
      const rankCharMap = { 2: '2', 3: '3', 4: '4', 5: '5', 6: '6', 7: '7', 8: '8', 9: '9', 10: 'T', 11: 'J', 12: 'Q', 13: 'K', 14: 'A' };
      
      const ranks = cards.map(card => rankMap[card[0]]);
      const suits = cards.map(card => card[1]);
      
      // Count frequencies
      const rankCounts = {};
      ranks.forEach(r => rankCounts[r] = (rankCounts[r] || 0) + 1);
      
      const pairs = [];
      const trips = [];
      const quads = [];
      
      for (const [rank, count] of Object.entries(rankCounts)) {
        if (count === 4) quads.push(parseInt(rank));
        if (count === 3) trips.push(parseInt(rank));
        if (count === 2) pairs.push(parseInt(rank));
      }
      
      // Sort descending
      pairs.sort((a, b) => b - a);
      trips.sort((a, b) => b - a);
      quads.sort((a, b) => b - a);
      
      // Check flush
      const suitCounts = {};
      suits.forEach(s => suitCounts[s] = (suitCounts[s] || 0) + 1);
      const isFlush = Object.values(suitCounts).some(c => c >= 5);
      
      // Check straight (simplified)
      const uniqueRanks = [...new Set(ranks)].sort((a, b) => b - a);
      let isStraight = false;
      if (uniqueRanks.length >= 5) {
        for (let i = 0; i <= uniqueRanks.length - 5; i++) {
          if (uniqueRanks[i] - uniqueRanks[i + 4] === 4) {
            isStraight = true;
            break;
          }
        }
      }
      
      // Determine hand
      if (quads.length > 0) {
        return `Four of a Kind (${rankCharMap[quads[0]]}s)`;
      }
      if (trips.length > 0 && pairs.length > 0) {
        return `Full House (${rankCharMap[trips[0]]}${rankCharMap[trips[0]]}${rankCharMap[trips[0]]} over ${rankCharMap[pairs[0]]}${rankCharMap[pairs[0]]})`;
      }
      if (isFlush) {
        return 'Flush';
      }
      if (isStraight) {
        return 'Straight';
      }
      if (trips.length > 0) {
        return `Three of a Kind (${rankCharMap[trips[0]]}s)`;
      }
      if (pairs.length >= 2) {
        return `Two Pair (${rankCharMap[pairs[0]]}${rankCharMap[pairs[0]]} ${rankCharMap[pairs[1]]}${rankCharMap[pairs[1]]})`;
      }
      if (pairs.length === 1) {
        return `Pair (${rankCharMap[pairs[0]]}${rankCharMap[pairs[0]]})`;
      }
      
      // High card
      const highCard = Math.max(...ranks);
      return `High Card (${rankCharMap[highCard]})`;
    }
    
    // ============================================
    // STEP 9: RENDER COMMUNITY CARDS + POT
    // ============================================
    function renderCommunity(communityCards, pot, currentBet) {
      if (!communityCards || communityCards.length === 0) {
        document.getElementById('communitySection').style.display = 'none';
        return;
      }
      
      debug('üé¥ Rendering community cards', { communityCards, pot, currentBet });
      
      const section = document.getElementById('communitySection');
      const cardsDiv = document.getElementById('communityCards');
      
      section.style.display = 'block';
      cardsDiv.innerHTML = '';
      
      communityCards.forEach(card => {
        const cardDiv = document.createElement('div');
        cardDiv.className = 'card';
        cardDiv.style.backgroundImage = `url('/cards/${card}.png')`;
        cardsDiv.appendChild(cardDiv);
      });
      
      document.getElementById('potAmount').textContent = pot || 0;
      document.getElementById('currentBet').textContent = currentBet || 0;
      
      debug('‚úÖ Community cards rendered');
    }
    
    // ============================================
    // STEP 10: UPDATE TURN INDICATOR
    // ============================================
    function updateTurnIndicator(currentActorSeat) {
      const indicator = document.getElementById('turnIndicator');
      const actorText = document.getElementById('currentActor');
      
      if (currentActorSeat === null || currentActorSeat === undefined) {
        indicator.style.display = 'none';
        actorText.textContent = '';
        return;
      }
      
      // Check if it's our turn
      // (This is simplified - need to map userId to seat)
      actorText.textContent = `(Waiting for Seat ${currentActorSeat})`;
      
      // TODO: Properly detect if current actor is us
      // indicator.style.display = 'inline';
    }
    
    // ============================================
    // üéõÔ∏è HOST CONTROLS FUNCTIONS
    // ============================================
    function toggleHostControls() {
      const content = document.getElementById('hostControlsContent');
      const icon = document.getElementById('hostToggleIcon');
      content.classList.toggle('expanded');
      icon.classList.toggle('expanded');
    }
    
    async function loadHostControls() {
      if (!isHost) {
        document.getElementById('hostControlsPanel').style.display = 'none';
        return;
      }
      
      debug('üéõÔ∏è Loading host controls...');
      document.getElementById('hostControlsPanel').style.display = 'block';
      
      try {
        const response = await fetch(`/api/engine/host-controls/${roomId}/${userId}`);
        if (!response.ok) {
          console.error('Failed to load host controls');
          return;
        }
        
        const data = await response.json();
        debug('‚úÖ Host controls loaded', data);
        
        // Update blinds inputs
        document.getElementById('hostSmallBlindInput').value = data.room.smallBlind;
        document.getElementById('hostBigBlindInput').value = data.room.bigBlind;
        
        // Render players
        renderHostPlayerList(data.players);
        
      } catch (error) {
        console.error('Error loading host controls:', error);
      }
    }
    
    function renderHostPlayerList(players) {
      const container = document.getElementById('hostPlayerList');
      const countEl = document.getElementById('hostPlayerCount');
      
      countEl.textContent = players.length;
      
      if (players.length === 0) {
        container.innerHTML = '<div class="empty-state">No players seated</div>';
        return;
      }
      
      container.innerHTML = players.map(player => `
        <div class="player-item">
          <div class="player-item-info">
            <div class="player-item-name">
              @${player.nickname}
              ${player.userId === userId ? ' (YOU)' : ''}
            </div>
            <div class="player-item-details">
              <span>Seat ${player.seatIndex}</span>
              <span class="player-item-chips">$${player.chips}</span>
            </div>
          </div>
          ${player.userId !== userId ? `
            <button class="host-btn kick" onclick="kickPlayer('${player.userId}')">
              üö´ KICK
            </button>
          ` : ''}
        </div>
      `).join('');
    }
    
    async function kickPlayer(targetUserId) {
      if (!confirm('Are you sure you want to kick this player? They will be removed from their seat.')) {
        return;
      }
      
      debug('üö´ Kicking player:', targetUserId);
      
      try {
        const response = await fetch('/api/engine/host-controls/kick-player', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            roomId,
            hostId: userId,
            targetUserId
          })
        });
        
        if (!response.ok) {
          const error = await response.json();
          alert(`Failed to kick player: ${error.error}`);
          return;
        }
        
        debug('‚úÖ Player kicked');
        loadHostControls(); // Refresh panel
        loadRoom(); // Refresh seats
        
      } catch (error) {
        console.error('Error kicking player:', error);
        alert('Failed to kick player');
      }
    }
    
    async function updateBlinds() {
      const smallBlind = parseInt(document.getElementById('hostSmallBlindInput').value);
      const bigBlind = parseInt(document.getElementById('hostBigBlindInput').value);
      
      if (bigBlind <= smallBlind) {
        alert('Big blind must be greater than small blind!');
        return;
      }
      
      if (smallBlind < 1 || bigBlind < 2) {
        alert('Blinds must be positive integers!');
        return;
      }
      
      debug('üí∞ Updating blinds:', { smallBlind, bigBlind });
      
      try {
        const response = await fetch('/api/engine/host-controls/update-blinds', {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            roomId,
            hostId: userId,
            smallBlind,
            bigBlind
          })
        });
        
        if (!response.ok) {
          const error = await response.json();
          alert(`Failed to update blinds: ${error.error}`);
          return;
        }
        
        debug('‚úÖ Blinds updated');
        alert(`‚úÖ Blinds updated to $${smallBlind}/$${bigBlind}\n\nWill take effect on next hand.`);
        
      } catch (error) {
        console.error('Error updating blinds:', error);
        alert('Failed to update blinds');
      }
    }
    
    // ============================================
    // CIRCULAR SEAT POSITIONING (Proper Ellipse)
    // ============================================
    function calculateSeatPositions() {
      const centerX = 840;  // Center of 1680px canvas
      const centerY = 400;  // Center of 800px canvas
      const radiusX = 620;  // Horizontal radius
      const radiusY = 260;  // Vertical radius
      
      const positions = [];
      const totalSeats = 9;
      
      for (let i = 0; i < totalSeats; i++) {
        // Start from bottom (seat 0 = you) and go counter-clockwise
        const angle = (Math.PI / 2) - (2 * Math.PI * i / totalSeats);
        
        positions.push({
          index: i,
          x: Math.round(centerX + radiusX * Math.cos(angle)),
          y: Math.round(centerY - radiusY * Math.sin(angle))
        });
      }
      
      return positions;
    }
    
    const SEAT_POSITIONS = calculateSeatPositions();

    function applySeatPositions() {
      SEAT_POSITIONS.forEach(pos => {
        const seat = document.querySelector(`.seat[data-seat-index="${pos.index}"]`);
        if (seat) {
          seat.style.left = `${pos.x}px`;
          seat.style.top = `${pos.y}px`;
        }
      });
      debug('üìç Applied circular seat positions');
    }
    
    // ============================================
    // ZOOM LOCK SYSTEM
    // ============================================
    function setupZoomLock() {
      const wrapper = document.getElementById('tableWrapper');
      const table = document.getElementById('pokerTable');
      
      if (!wrapper || !table) {
        console.warn('‚ö†Ô∏è Zoom lock elements not found');
        return;
      }

      const updateScale = () => {
        const containerWidth = wrapper.clientWidth;
        const containerHeight = wrapper.clientHeight;
        const stageWidth = 1680;
        const stageHeight = 800;

        const scaleX = containerWidth / stageWidth;
        const scaleY = containerHeight / stageHeight;
        const scale = Math.min(scaleX, scaleY);

        const scaledWidth = stageWidth * scale;
        const scaledHeight = stageHeight * scale;
        const offsetX = (containerWidth - scaledWidth) / 2;
        const offsetY = (containerHeight - scaledHeight) / 2;

        table.style.left = `${offsetX}px`;
        table.style.top = `${offsetY}px`;
        table.style.transform = `scale(${scale})`;
        
        debug('üîç Zoom lock updated', { scale, offsetX, offsetY });
      };

      updateScale();
      window.addEventListener('resize', updateScale);
      new ResizeObserver(updateScale).observe(wrapper);
      
      debug('‚úÖ Zoom lock initialized');
    }
    
    // ============================================
    // INITIALIZE ON LOAD
    // ============================================
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        init();
        setupZoomLock();
      });
    } else {
      init();
      setupZoomLock();
    }
  </script>
</body>
</html>

