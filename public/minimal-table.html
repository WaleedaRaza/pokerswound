<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PokerGeek - Minimal Table</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
  <style>
    /* Design Tokens */
    :root {
      --bg: #0b0b12;
      --text: #e9eef7;
      --muted: #9aa3b2;
      --accent: #ff5100;
      --teal: #00d4aa;
      --error: #ff3b3b;
      --felt-current: #197a45;
      --font-main: "Inter", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      --font-mono: "JetBrains Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --shadow-md: 0 8px 18px rgba(0,0,0,.35);
      --shadow-lg: 0 12px 28px rgba(0,0,0,.45);
      --shadow-xl: 0 18px 44px rgba(0,0,0,.55);
      
      /* Liquid Glass Variables (from play page) */
      --glass-tint-opacity: 0.02;
      --glass-frost-blur: 20px;
      --glass-shadow-blur: 20px;
      --glass-shadow-spread: -5px;
      --glass-shadow-color: rgba(255, 255, 255, 0.1);
      --glass-outer-shadow: 12px;
    }

    /* Felt color presets */
    body[data-felt="green"] { --felt-current: #197a45; }
    body[data-felt="red"] { --felt-current: #6b1414; }
    body[data-felt="black"] { --felt-current: #1a1a1a; }
    body[data-felt="blue"] { --felt-current: #0f2942; }
    body[data-felt="grey"] { --felt-current: #2a2a2a; }
    body[data-felt="tan"] { --felt-current: #6b5642; }
    body[data-felt="purple"] { --felt-current: #3a1450; }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      background: #0b0b12;
      color: #e9eef7;
      font-family: 'Inter', system-ui, -apple-system, Arial, sans-serif;
      padding: 20px;
      position: relative;
      overflow-x: hidden;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      position: relative;
      z-index: 100; /* Above falling cards (z-index: 50) */
    }
    
    
    /* ============================================ */
    /* ZOOM LOCK TABLE WRAPPER */
    /* ============================================ */
    .table-wrapper {
      width: 100%;
      min-height: 1000px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--bg);
      position: relative;
      overflow: visible;
      margin-bottom: 30px;
      z-index: 100; /* Above falling cards (z-index: 50) */
    }

    .poker-table {
      position: absolute;
      width: 1600px;
      height: 1200px;
      transform-origin: top left;
      pointer-events: auto;
      z-index: 100; /* Above falling cards (z-index: 50) */
    }

    /* Oval Felt Background */
    .table-felt {
      position: absolute;
      inset: 24px;
      border-radius: 360px;
      border: 2px solid #0d1117;
      background: var(--felt-current);
      box-shadow: 
        inset 0 0 0 16px rgba(0,0,0,.35), 
        inset 0 0 80px rgba(0,0,0,.45);
      z-index: 0;
    }

    .table-felt::after {
      content: "";
      position: absolute;
      inset: -24px;
      border-radius: inherit;
      box-shadow: 0 16px 56px rgba(0,0,0,.55);
      pointer-events: none;
    }

    /* Board Center (Community Cards + Pot) */
    .board-center {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 16px;
      z-index: 5;
      pointer-events: none;
    }

    .community-cards-center {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      justify-content: center;
    }
    
    /* Community card styling */
    .community-cards-center .card-img {
      width: 110px;
      aspect-ratio: 5/7;
      border-radius: 10px;
      box-shadow: 
        0 0 30px rgba(255, 255, 255, 0.15),
        0 12px 40px rgba(0, 0, 0, 0.8);
      object-fit: cover;
      border: 2px solid rgba(255,255,255,0.3);
      transition: all 0.3s ease;
    }
    
    .community-cards-center .card-img:hover {
      transform: translateY(-4px);
      box-shadow: 
        0 0 40px rgba(255, 255, 255, 0.25),
        0 16px 50px rgba(0, 0, 0, 0.9);
    }
    
    /* Card entrance animation */
    @keyframes cardFlip {
      0% {
        transform: rotateY(90deg) scale(0.8);
        opacity: 0;
      }
      50% {
        transform: rotateY(45deg) scale(1.05);
      }
      100% {
        transform: rotateY(0deg) scale(1);
        opacity: 1;
      }
    }
    
    .community-cards-center .card-img.new-card {
      animation: cardFlip 0.5s ease-out forwards;
    }

    /* Pot Display - Default White, Fully Transparent */
    .pot-display-center {
      padding: 32px 48px 24px 48px; /* More top padding, less bottom */
      border-radius: 20px;
      background: transparent; /* Fully transparent */
      border: 2px solid rgba(255, 255, 255, 0.4); /* White border by default */
      text-align: center;
      box-shadow: 
        0 0 0 2px rgba(255, 255, 255, 0.2), /* White outer glow */
        0 0 20px rgba(255, 255, 255, 0.15); /* White ambient glow */
      pointer-events: auto;
      cursor: pointer;
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      overflow: visible; /* Allow chips to overflow */
      min-width: 200px;
    }
    
    /* Bet Pulse - Random Green or Gold Glow */
    .pot-display-center.bet-pulse-green {
      animation: betPulseGreen 0.8s ease-out;
    }
    
    .pot-display-center.bet-pulse-gold {
      animation: betPulseGold 0.8s ease-out;
    }
    
    @keyframes betPulseGreen {
      0% {
        border-color: rgba(255, 255, 255, 0.4);
        box-shadow: 
          0 0 0 2px rgba(255, 255, 255, 0.2),
          0 0 20px rgba(255, 255, 255, 0.15);
      }
      50% {
        border-color: rgba(100, 255, 150, 0.8);
        box-shadow: 
          0 0 0 3px rgba(100, 255, 150, 0.4),
          0 0 40px rgba(100, 255, 150, 0.3),
          0 0 60px rgba(100, 255, 150, 0.2);
      }
      100% {
        border-color: rgba(255, 255, 255, 0.4);
        box-shadow: 
          0 0 0 2px rgba(255, 255, 255, 0.2),
          0 0 20px rgba(255, 255, 255, 0.15);
      }
    }
    
    @keyframes betPulseGold {
      0% {
        border-color: rgba(255, 255, 255, 0.4);
        box-shadow: 
          0 0 0 2px rgba(255, 255, 255, 0.2),
          0 0 20px rgba(255, 255, 255, 0.15);
      }
      50% {
        border-color: rgba(255, 215, 0, 0.8);
        box-shadow: 
          0 0 0 3px rgba(255, 215, 0, 0.4),
          0 0 40px rgba(255, 215, 0, 0.3),
          0 0 60px rgba(255, 215, 0, 0.2);
      }
      100% {
        border-color: rgba(255, 255, 255, 0.4);
        box-shadow: 
          0 0 0 2px rgba(255, 255, 255, 0.2),
          0 0 20px rgba(255, 255, 255, 0.15);
      }
    }
    
    /* Turn Shake - Light Shake */
    .pot-display-center.shake-turn {
      animation: shakeTurn 0.5s ease-in-out;
    }
    
    @keyframes shakeTurn {
      0%, 100% { transform: translateX(0) translateY(0); }
      10% { transform: translateX(-2px) translateY(-1px) rotate(-0.5deg); }
      20% { transform: translateX(2px) translateY(1px) rotate(0.5deg); }
      30% { transform: translateX(-1px) translateY(-1px) rotate(-0.3deg); }
      40% { transform: translateX(1px) translateY(1px) rotate(0.3deg); }
      50% { transform: translateX(-1px) translateY(0) rotate(-0.2deg); }
      60% { transform: translateX(1px) translateY(0) rotate(0.2deg); }
      70% { transform: translateX(0) translateY(-1px) rotate(-0.1deg); }
      80% { transform: translateX(0) translateY(1px) rotate(0.1deg); }
      90% { transform: translateX(0) translateY(0) rotate(0deg); }
    }
    
    /* River Shake - Intense Shake */
    .pot-display-center.shake-river {
      animation: shakeRiver 0.8s ease-in-out;
    }
    
    @keyframes shakeRiver {
      0%, 100% { transform: translateX(0) translateY(0) rotate(0deg); }
      5% { transform: translateX(-4px) translateY(-2px) rotate(-1deg); }
      10% { transform: translateX(4px) translateY(2px) rotate(1deg); }
      15% { transform: translateX(-3px) translateY(-2px) rotate(-0.8deg); }
      20% { transform: translateX(3px) translateY(2px) rotate(0.8deg); }
      25% { transform: translateX(-2px) translateY(-1px) rotate(-0.5deg); }
      30% { transform: translateX(2px) translateY(1px) rotate(0.5deg); }
      35% { transform: translateX(-2px) translateY(-1px) rotate(-0.4deg); }
      40% { transform: translateX(2px) translateY(1px) rotate(0.4deg); }
      45% { transform: translateX(-1px) translateY(0) rotate(-0.3deg); }
      50% { transform: translateX(1px) translateY(0) rotate(0.3deg); }
      55% { transform: translateX(-1px) translateY(-1px) rotate(-0.2deg); }
      60% { transform: translateX(1px) translateY(1px) rotate(0.2deg); }
      65% { transform: translateX(0) translateY(-1px) rotate(-0.1deg); }
      70% { transform: translateX(0) translateY(1px) rotate(0.1deg); }
      75% { transform: translateX(-1px) translateY(0) rotate(-0.1deg); }
      80% { transform: translateX(1px) translateY(0) rotate(0.1deg); }
      85% { transform: translateX(0) translateY(-1px) rotate(0deg); }
      90% { transform: translateX(0) translateY(1px) rotate(0deg); }
      95% { transform: translateX(0) translateY(0) rotate(0deg); }
    }
    
    /* Turn Glow - Persistent Green Glow */
    .pot-display-center.glow-turn {
      border-color: rgba(100, 255, 150, 0.6);
      box-shadow: 
        0 0 0 2px rgba(100, 255, 150, 0.3),
        0 0 30px rgba(100, 255, 150, 0.25),
        0 0 50px rgba(100, 255, 150, 0.15);
    }
    
    /* River Glow - Persistent Gold Glow */
    .pot-display-center.glow-river {
      border-color: rgba(255, 215, 0, 0.7);
      box-shadow: 
        0 0 0 3px rgba(255, 215, 0, 0.4),
        0 0 40px rgba(255, 215, 0, 0.3),
        0 0 70px rgba(255, 215, 0, 0.2);
    }
    
    /* River Text Shake - Shaky animation on pot amount text */
    .pot-amount.shake-river-text {
      animation: shakeRiverText 0.8s ease-in-out;
    }
    
    @keyframes shakeRiverText {
      0%, 100% { transform: translateX(0) translateY(0); }
      5% { transform: translateX(-3px) translateY(-2px); }
      10% { transform: translateX(3px) translateY(2px); }
      15% { transform: translateX(-2px) translateY(-1px); }
      20% { transform: translateX(2px) translateY(1px); }
      25% { transform: translateX(-2px) translateY(-1px); }
      30% { transform: translateX(2px) translateY(1px); }
      35% { transform: translateX(-1px) translateY(0); }
      40% { transform: translateX(1px) translateY(0); }
      45% { transform: translateX(-1px) translateY(-1px); }
      50% { transform: translateX(1px) translateY(1px); }
      55% { transform: translateX(0) translateY(-1px); }
      60% { transform: translateX(0) translateY(1px); }
      65% { transform: translateX(-1px) translateY(0); }
      70% { transform: translateX(1px) translateY(0); }
      75% { transform: translateX(0) translateY(0); }
    }
    
    /* Pot Decrementing to Zero */
    .pot-display-center.pot-decrementing {
      animation: potDecrement 1.2s ease-out forwards;
    }
    
    @keyframes potDecrement {
      0% {
        transform: scale(1);
        opacity: 1;
      }
      50% {
        transform: scale(0.95);
        opacity: 0.8;
      }
      100% {
        transform: scale(0.9);
        opacity: 0.6;
      }
    }
    
    .pot-display-center:hover {
      border-color: rgba(255, 255, 255, 0.6);
      box-shadow: 
        0 0 0 2px rgba(255, 255, 255, 0.3),
        0 0 30px rgba(255, 255, 255, 0.25);
    }
    
    /* Side Pot Modal */
    .side-pot-modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(8px);
      z-index: 10000;
      display: none;
      align-items: center;
      justify-content: center;
      animation: fadeIn 0.2s ease-out;
    }
    
    .side-pot-modal-overlay.show {
      display: flex;
    }
    
    .side-pot-modal {
      background: linear-gradient(135deg, rgba(15,15,25,0.98), rgba(20,20,30,0.98));
      border: 3px solid rgba(255,215,0,.6);
      border-radius: 16px;
      padding: 32px;
      max-width: 600px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 16px 48px rgba(255, 215, 0, 0.4);
      animation: modalSlideIn 0.3s ease-out;
    }
    
    .side-pot-modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 24px;
      border-bottom: 2px solid rgba(255,215,0,.3);
      padding-bottom: 16px;
    }
    
    .side-pot-modal-header h2 {
      margin: 0;
      color: #ffd700;
      font-size: 1.75rem;
      font-family: 'JetBrains Mono', monospace;
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }
    
    .side-pot-modal-close {
      background: none;
      border: 2px solid rgba(255,215,0,.5);
      color: #ffd700;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }
    
    .side-pot-modal-close:hover {
      background: rgba(255,215,0,.1);
      border-color: #ffd700;
      transform: rotate(90deg);
    }
    
    .side-pot-list {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    
    .side-pot-item-detailed {
      background: rgba(255,215,0,.05);
      border: 2px solid rgba(255,215,0,.2);
      border-radius: 12px;
      padding: 20px;
      transition: all 0.2s ease;
    }
    
    .side-pot-item-detailed:hover {
      background: rgba(255,215,0,.1);
      border-color: rgba(255,215,0,.4);
      transform: translateX(4px);
    }
    
    .side-pot-item-detailed.main-pot {
      background: rgba(255,215,0,.1);
      border-color: rgba(255,215,0,.5);
      border-width: 3px;
    }
    
    .side-pot-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }
    
    .side-pot-label {
      font-size: 1.1rem;
      font-weight: 700;
      color: #ffd700;
      font-family: 'JetBrains Mono', monospace;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    
    .side-pot-amount {
      font-size: 1.5rem;
      font-weight: 700;
      color: #ffd700;
      font-family: 'Courier New', monospace;
    }
    
    .side-pot-eligible {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid rgba(255,215,0,.2);
    }
    
    .side-pot-eligible-label {
      font-size: 0.85rem;
      color: rgba(255,255,255,.6);
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    
    .side-pot-eligible-seats {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    
    .eligible-seat-badge {
      background: rgba(255,215,0,.15);
      border: 1px solid rgba(255,215,0,.3);
      border-radius: 6px;
      padding: 4px 12px;
      font-size: 0.85rem;
      color: #ffd700;
      font-family: 'Courier New', monospace;
      font-weight: 600;
    }
    
    .side-pot-total {
      margin-top: 24px;
      padding-top: 24px;
      border-top: 3px solid rgba(255,215,0,.4);
      text-align: center;
    }
    
    .side-pot-total-label {
      font-size: 0.9rem;
      color: rgba(255,255,255,.7);
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }
    
    .side-pot-total-amount {
      font-size: 2rem;
      font-weight: 700;
      color: #ffd700;
      font-family: 'Courier New', monospace;
    }
    
    /* Hand Rank Display - Simple Text Line Above Buttons */
    .hand-rank-display {
      text-align: center;
      margin: 20px auto 15px auto;
      pointer-events: none;
    }
    
    .hand-rank-text {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.95rem;
      font-weight: 600;
      color: rgba(0, 212, 170, 0.85);
      letter-spacing: 0.8px;
      text-transform: uppercase;
      text-shadow: 0 2px 8px rgba(0, 212, 170, 0.3);
    }
    
    /* Runout Message Display (During All-In Runout) */
    .runout-message {
      padding: 16px 32px;
      border-radius: 12px;
      background: linear-gradient(135deg, rgba(255, 215, 0, 0.2) 0%, rgba(255, 180, 100, 0.2) 100%);
      border: 2px solid rgba(255, 215, 0, 0.5);
      text-align: center;
      box-shadow: 
        0 0 30px rgba(255, 215, 0, 0.3),
        inset 0 0 20px rgba(255, 215, 0, 0.1);
      backdrop-filter: blur(10px);
      pointer-events: none;
      margin: 20px auto;
      max-width: 500px;
      display: none;
      animation: pulseGlow 2s ease-in-out infinite;
    }
    
    .runout-message.show {
      display: block;
    }
    
    @keyframes pulseGlow {
      0%, 100% { 
        box-shadow: 
          0 0 30px rgba(255, 215, 0, 0.3),
          inset 0 0 20px rgba(255, 215, 0, 0.1);
      }
      50% { 
        box-shadow: 
          0 0 40px rgba(255, 215, 0, 0.5),
          inset 0 0 25px rgba(255, 215, 0, 0.15);
      }
    }
    
    .runout-message-text {
      font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', sans-serif;
      font-size: 20px;
      font-weight: 600;
      color: #ffd700;
      text-shadow: 
        0 0 15px rgba(255, 215, 0, 0.6),
        0 2px 4px rgba(0, 0, 0, 0.8);
      letter-spacing: 0.05em;
    }

    .hand-transition-overlay {
      position: fixed;
      inset: 0;
      background: rgba(2, 6, 23, 0.88);
      backdrop-filter: blur(6px);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1300;
      opacity: 0;
      transition: opacity 200ms ease;
    }

    .hand-transition-card {
      background: rgba(15, 23, 42, 0.85);
      border: 1px solid rgba(148, 163, 184, 0.4);
      border-radius: 16px;
      padding: 32px 48px;
      text-align: center;
      box-shadow: 0 15px 45px rgba(0,0,0,0.35);
      min-width: 280px;
    }

    .hand-transition-title {
      font-size: 0.9rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: rgba(226, 232, 240, 0.7);
      margin-bottom: 8px;
    }

    .hand-transition-countdown {
      font-size: 4rem;
      font-weight: 600;
      color: #00d4aa;
      letter-spacing: 0.05em;
      line-height: 1;
    }

    .board-fade-target {
      transition: opacity 200ms ease;
    }

    .board-fade-out {
      opacity: 0;
    }

    /* Pot Label - Refined Typography */
    .pot-label {
      font-size: 11px;
      color: rgba(255, 255, 255, 0.4);
      letter-spacing: 0.15em;
      font-weight: 500;
      margin-bottom: 6px;
      text-transform: uppercase;
      font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', sans-serif;
    }

    /* Pot Amount Container - Flex layout for "mainPot total totalPot" */
    .pot-amount-container {
      display: flex;
      flex-direction: column; /* Stack vertically: main pot on top, total below */
      align-items: center;
      justify-content: center;
      gap: 8px;
      position: relative;
      z-index: 3; /* Above chips */
    }
    
    /* Total pot row (label + amount) - shown inline when side pots exist */
    .pot-total-row {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      margin-top: 4px;
    }
    
    /* Pot Amount - Base Styling (White by Default) */
    .pot-amount {
      font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', sans-serif;
      font-size: 48px;
      font-weight: 700;
      letter-spacing: -0.03em;
      line-height: 1;
      position: relative;
      z-index: 3; /* Above chips */
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
      color: rgba(255, 255, 255, 0.95);
      text-shadow: 
        0 0 15px rgba(255, 255, 255, 0.4),
        0 2px 8px rgba(0, 0, 0, 0.8),
        0 4px 12px rgba(255, 255, 255, 0.2);
    }
    
    /* Total Label - Smaller, muted (Poker Now style) */
    .pot-total-label {
      font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', sans-serif;
      font-size: 13px;
      font-weight: 500;
      color: rgba(255, 255, 255, 0.6);
      text-transform: lowercase;
      letter-spacing: 0.05em;
    }
    
    /* Total Pot Amount - Smaller than main pot (Poker Now style) */
    .pot-total-amount {
      font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', sans-serif;
      font-size: 16px;
      font-weight: 600;
      color: rgba(255, 255, 255, 0.85);
      letter-spacing: 0.02em;
    }
    
    /* Removed chip conservation indicator CSS - using Poker Now style "total" display instead */
    
    /* Dollar sign styling */
    .pot-amount::before {
      content: '$';
      font-size: 0.7em;
      opacity: 0.8;
      font-weight: 500;
      margin-right: -4px;
      transition: opacity 0.6s ease;
    }
    
    /* Removed tier-based styling - using event-driven animations instead */
    
    /* Increment animation when pot changes */
    .pot-amount.updating {
      animation: potUpdate 0.6s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    @keyframes potUpdate {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.08); }
    }
    
    /* Increment counter animation */
    .pot-amount.incrementing {
      animation: potIncrement 0.8s ease-out;
    }
    
    @keyframes potIncrement {
      0% { 
        transform: scale(1);
        color: rgba(150, 200, 255, 0.9);
      }
      50% { 
        transform: scale(1.15);
        color: rgba(255, 215, 0, 1);
      }
      100% { 
        transform: scale(1);
      }
    }
    
    .side-pots-container {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .side-pot-item {
      font-size: 0.65rem;
      color: var(--muted);
      font-family: var(--font-mono);
      padding: 2px 0;
    }
    
    .total-pot-label {
      font-size: 0.75rem;
      color: var(--muted);
      margin-top: 10px;
      border-top: 1px solid rgba(255,255,255,0.1);
      padding-top: 8px;
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }
    
    .total-pot-amount {
      font-family: var(--font-mono);
      font-size: 1rem;
      color: var(--teal);
      margin-top: 4px;
      font-weight: 900;
      text-shadow: 
        0 0 10px rgba(0, 212, 170, 0.5),
        0 2px 8px rgba(0, 0, 0, 0.6);
      letter-spacing: 0.05em;
    }

    /* Seats Layer */
    .seats-layer {
      position: absolute;
      inset: 0;
      z-index: 10;
    }
    
    h1 {
      color: #ff5100;
      margin-bottom: 10px;
    }
    
    /* Clean Table Header */
    /* ========================================
       POKER TABLE OS: ROOM NAME (PLAIN TEXT ABOVE)
       ======================================== */
    .room-name-display {
      text-align: center;
      margin-bottom: 16px;
    }
    
    .room-name-text {
      color: #ff5100;
      font-size: 2rem;
      font-weight: 700;
      letter-spacing: 1.5px;
      font-family: 'JetBrains Mono', monospace;
      text-transform: uppercase;
      text-shadow: 0 0 20px rgba(255, 81, 0, 0.4);
    }
    
    .typing-cursor {
      color: #ff5100;
      font-size: 2rem;
      font-weight: 400;
      animation: blink 1s step-end infinite;
    }
    
    @keyframes blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0; }
    }

    /* ========================================
       POKER TABLE OS: THE DOCK (ONLY LIQUID GLASS BOX)
       DESIGN SYSTEM: JetBrains Mono font, Orange primary, Teal accents
       ======================================== */
    .poker-dock {
      position: relative;
      z-index: 100;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 32px;
      max-width: 900px;
      margin: 0 auto 24px auto;
      padding: 24px 32px;
      /* Background, border, blur handled by .liquid-glass */
      font-family: 'JetBrains Mono', monospace;
    }
    
    /* Dock Left: Start Hand + Table Code + Connection */
    .dock-left {
      display: flex;
      align-items: center;
      gap: 16px;
      flex-shrink: 0;
    }
    
    .dock-action-btn {
      padding: 12px 20px;
      font-size: 0.9rem;
      font-weight: 700;
      font-family: 'JetBrains Mono', monospace;
      color: #ff5100;
      background: rgba(255, 81, 0, 0.1);
      border: 2px solid rgba(255, 81, 0, 0.4);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
      white-space: nowrap;
      text-shadow: 0 0 10px rgba(255, 81, 0, 0.3);
    }
    
    .dock-action-btn:hover {
      background: rgba(255, 81, 0, 0.2);
      border-color: rgba(255, 81, 0, 0.6);
      transform: translateY(-2px);
      box-shadow: 0 4px 16px rgba(255, 81, 0, 0.4);
    }
    
    .dock-label {
      color: #00d4aa;
      font-size: 0.85rem;
      font-family: 'JetBrains Mono', monospace;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      font-weight: 600;
      white-space: nowrap;
    }
    
    .dock-code {
      color: #00d4aa;
      font-size: 1.4rem;
      font-weight: 800;
      letter-spacing: 3px;
      font-family: 'JetBrains Mono', monospace;
      text-shadow: 0 0 15px rgba(0, 212, 170, 0.6);
      white-space: nowrap;
    }
    
    .dock-connection {
      display: flex;
      align-items: center;
      margin-left: 6px;
    }
    
    /* Dock Center: Game State */
    .dock-center {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      min-width: 220px;
    }
    
    .game-state-text {
      color: rgba(255, 255, 255, 0.85);
      font-size: 1rem;
      font-weight: 600;
      letter-spacing: 1px;
      font-family: 'JetBrains Mono', monospace;
      text-transform: uppercase;
      white-space: nowrap;
    }
    
    /* Dock Right: Control Apps (Vertical Icon + Label) */
    .dock-right {
      display: flex;
      align-items: center;
      gap: 24px;
      flex-shrink: 0;
    }
    
    .dock-app {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      padding: 14px 18px;
      background: transparent;
      border: none;
      cursor: pointer;
      transition: all 0.25s ease;
      min-width: 90px;
    }
    
    .dock-app-icon {
      font-size: 2rem;
      line-height: 1;
      color: #ff5100;
      filter: drop-shadow(0 0 8px rgba(255, 81, 0, 0.5));
      transition: all 0.25s ease;
    }
    
    .dock-app-label {
      font-size: 0.75rem;
      font-weight: 600;
      letter-spacing: 0.5px;
      font-family: 'JetBrains Mono', monospace;
      color: #00d4aa;
      text-align: center;
      line-height: 1.3;
      white-space: nowrap;
      transition: all 0.25s ease;
    }
    
    .dock-app:hover {
      transform: translateY(-4px);
    }
    
    .dock-app:hover .dock-app-icon {
      color: #ff6a2e;
      filter: drop-shadow(0 0 12px rgba(255, 81, 0, 0.8));
      transform: scale(1.1);
    }
    
    .dock-app:hover .dock-app-label {
      color: #00ffcc;
      text-shadow: 0 0 8px rgba(0, 212, 170, 0.6);
    }
    
    .dock-app:active {
      transform: translateY(-2px);
    }
    
    /* Modal Overlay */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(10px);
      z-index: 10000; /* Way above everything for modals */
      display: flex;
      align-items: center;
      justify-content: center;
      animation: fadeIn 0.3s ease;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    .modal-content {
      max-width: 900px;
      max-height: 90vh;
      overflow-y: auto;
      width: 90%;
      padding: 0;
      position: relative;
      animation: slideUp 0.3s ease;
      /* Liquid glass handles all styling - remove conflicts */
      background: none !important;
      border: 2px solid rgba(255, 255, 255, 0.1) !important;
      backdrop-filter: none !important;
      box-shadow: none !important;
      z-index: 10001; /* Above modal overlay */
    }
    
    @keyframes slideUp {
      from { transform: translateY(50px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }
    
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 24px 32px;
      border-bottom: 2px solid rgba(255, 255, 255, 0.1);
      background: rgba(255, 255, 255, 0.02);
    }
    
    .modal-header h2 {
      color: rgba(255, 255, 255, 0.95);
      font-size: 1.5rem;
      font-weight: 700;
      margin: 0;
    }
    
    .modal-close-btn {
      background: transparent;
      border: none;
      color: rgba(255, 255, 255, 0.7);
      font-size: 2rem;
      cursor: pointer;
      padding: 0;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      border-radius: 50%;
    }
    
    .modal-close-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      color: rgba(255, 255, 255, 1);
    }
    
    .modal-body {
      padding: 32px;
    }
    
    .connection-indicator {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .connection-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #ff3b3b;
      box-shadow: 0 0 12px rgba(255, 59, 59, 0.6);
      transition: all 0.3s ease;
    }
    
    .connection-indicator.connected .connection-dot {
      background: #00d4aa;
      box-shadow: 0 0 12px rgba(0, 212, 170, 0.6);
    }
    
    .seats-grid {
      position: relative;
      width: 100%;
      height: 100%;
    }
    
    .seat {
      position: absolute;
      transform: translate(-50%, -50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0; /* Remove gap, positioning handled by absolute positioning */
    }
    
    /* Seat tile - Minimalist Design with Avatar Space */
    .seat-tile {
      position: relative; /* Needed for absolute positioning of bet indicator */
      background: transparent;
      border: 3px solid rgba(255, 255, 255, 0.4);
      border-radius: 20px;
      padding: 16px;
      width: 210px;
      height: 210px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      align-items: center;
      position: relative;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    /* Avatar/Profile Picture Container - Scales proportionally with tile */
    .seat-tile {
      --tile-scale: 1; /* Default scale (for 210px tiles) */
      --tile-width: 210px; /* Default width */
    }
    
    /* Player info wrapper (avatar + username) - positioned above/below tile */
    .seat-player-info {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: calc(8px * var(--tile-scale, 1));
      width: 100%;
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      pointer-events: none;
      white-space: nowrap;
    }
    
    /* Top seats: player info below tile */
    .seat.seat-top .seat-player-info {
      top: calc(100% + 12px * var(--tile-scale, 1)); /* Below tile + larger gap */
    }
    
    /* Bottom seats: player info above tile */
    .seat.seat-bottom .seat-player-info {
      bottom: calc(100% + 12px * var(--tile-scale, 1)); /* Above tile + larger gap */
    }
    
    .seat-avatar {
      /* Base size: 60px (increased for better visibility), scales with tile */
      width: calc(60px * var(--tile-scale, 1));
      height: calc(60px * var(--tile-scale, 1));
      border-radius: 50%;
      background: linear-gradient(135deg, rgba(0, 212, 170, 0.2), rgba(0, 180, 140, 0.2));
      border: 2px solid rgba(0, 212, 170, 0.3);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: calc(24px * var(--tile-scale, 1));
      font-weight: 600;
      color: rgba(0, 212, 170, 0.8);
      text-transform: uppercase;
      flex-shrink: 0;
      overflow: hidden;
      transition: all 0.3s ease;
    }
    
    .seat-avatar img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 50%;
    }
    
    /* Kick button on seat (host only) */
    .kick-seat-btn {
      position: absolute;
      top: 8px;
      right: 8px;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: rgba(255, 59, 59, 0.2);
      border: 1px solid rgba(255, 59, 59, 0.4);
      color: #ff3b3b;
      font-size: 14px;
      font-weight: 700;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: all 0.2s ease;
      z-index: 10;
    }
    
    .seat-tile:hover .kick-seat-btn {
      opacity: 1;
    }
    
    .kick-seat-btn:hover {
      background: rgba(255, 59, 59, 0.4);
      border-color: rgba(255, 59, 59, 0.6);
      transform: scale(1.1);
    }
    
    .kick-seat-btn:active {
      transform: scale(0.95);
    }
    
    /* Seat requested state (pending request) */
    .seat.seat-requested {
      border: 2px dashed rgba(255, 149, 0, 0.5);
      opacity: 0.7;
    }
    
    .seat.seat-requested .seat-tile {
      background: rgba(255, 149, 0, 0.1);
    }
    
    .seat-avatar::after {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.2), transparent 70%);
      pointer-events: none;
    }
    
    /* YOUR seat tile - Refined Emphasis */
    .seat.me .seat-tile {
      width: 210px;
      height: 210px;
      border: 3px solid rgba(0, 212, 170, 0.7);
      background: transparent;
    }
    
    .seat.me .seat-avatar {
      border-color: rgba(0, 212, 170, 0.5);
      box-shadow: 0 0 12px rgba(0, 212, 170, 0.4);
    }
    
    .seat.empty .seat-tile {
      border: 3px dashed rgba(0, 212, 170, 0.7);
      background: transparent;
      cursor: pointer;
      transition: border 0.3s ease;
    }
    
    .seat.empty:hover .seat-tile {
      border: 3px solid rgba(0, 212, 170, 1);
      background: rgba(0, 212, 170, 0.1);
    }
    
    .seat.taken .seat-tile {
      border-color: rgba(255, 215, 0, 0.2);
      background: rgba(255, 215, 0, 0.04);
    }
    
    .seat.taken .seat-avatar {
      background: linear-gradient(135deg, rgba(255, 215, 0, 0.15), rgba(255, 195, 0, 0.15));
      border-color: rgba(255, 215, 0, 0.3);
      color: rgba(255, 215, 0, 0.8);
    }
    
    .seat.winner .seat-tile {
      border-color: gold;
      background: rgba(255,215,0,0.2);
      box-shadow: 0 0 20px rgba(255,215,0,0.5);
      animation: winnerPulse 1.5s ease-in-out infinite;
    }
    
    @keyframes winnerPulse {
      0%, 100% {
        box-shadow: 0 0 20px rgba(255,215,0,0.5);
      }
      50% {
        box-shadow: 0 0 30px rgba(255,215,0,0.8);
      }
    }
    
    /* Current turn indicator - glowing border */
    @keyframes seatTurnGlow {
      0%, 100% {
        box-shadow: 0 0 0 3px #ffd700, 0 0 30px rgba(255, 215, 0, 0.6);
      }
      50% {
        box-shadow: 0 0 0 5px #ffd700, 0 0 50px rgba(255, 215, 0, 1);
      }
    }
    
    .seat.current-turn .seat-tile {
      border: 3px solid #ffd700;
      animation: seatTurnGlow 1.5s ease-in-out infinite;
    }
    
    /* Position badges inside tile - Scales proportionally */
    .position-badges {
      position: absolute;
      top: calc(8px * var(--tile-scale, 1));
      left: calc(8px * var(--tile-scale, 1));
      display: flex;
      gap: calc(4px * var(--tile-scale, 1));
      flex-wrap: wrap;
      z-index: 10;
    }
    
    /* Player name - Scales proportionally, now inside player-info wrapper */
    .seat-player {
      font-family: 'Outfit', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      font-size: calc(18px * var(--tile-scale, 1));
      font-weight: 800;
      color: rgba(255, 255, 255, 0.95);
      letter-spacing: calc(0.5px * var(--tile-scale, 1));
      text-align: center;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: calc(200px * var(--tile-scale, 1));
      text-transform: uppercase;
      margin: 0; /* Remove margin, gap handled by wrapper */
    }
    
    /* Player name when not in wrapper (empty seats) */
    .seat.empty .seat-player {
      position: relative;
      margin-top: calc(8px * var(--tile-scale, 1));
    }
    
    /* Empty seat text styling - Scales proportionally */
    .seat.empty .seat-player {
      font-size: calc(14px * var(--tile-scale, 1));
      font-weight: 800;
      color: rgba(0, 212, 170, 0.9);
      letter-spacing: calc(1px * var(--tile-scale, 1));
      margin-top: calc(12px * var(--tile-scale, 1));
    }
    
    /* Chips inside tile - prominent at bottom */
    /* Chip Animation Classes */
    .seat-chips.chips-updating {
      transition: color 0.3s ease;
    }
    
    .seat-chips.chips-incrementing {
      color: rgba(100, 255, 150, 1);
      text-shadow: 0 0 10px rgba(100, 255, 150, 0.5);
    }
    
    .seat-chips.chips-decrementing {
      color: rgba(255, 150, 100, 1);
      text-shadow: 0 0 10px rgba(255, 150, 100, 0.5);
    }
    
    /* Bet Amount Indicator (Chip + Number style) */
    .seat-bet-indicator {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      gap: 8px;
      z-index: 10;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s ease-in, transform 0.3s ease-out;
    }
    
    .seat-bet-indicator .bet-chip {
      width: 64px;
      height: 64px;
      flex-shrink: 0;
      filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
    }
    
    .seat-bet-indicator .bet-amount {
      color: #ffd700;
      font-size: 1.2rem;
      font-weight: 700;
      text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
      white-space: nowrap;
    }
    
    /* Top seats: bet indicator below username (player-info is at top: calc(100% + 8px), so bet indicator goes further down) */
    .seat.seat-top .seat-bet-indicator {
      top: calc(100% + 70px); /* Below tile + player-info height + larger gap */
    }
    
    /* Bottom seats: bet indicator above username (player-info is at bottom: calc(100% + 8px), so bet indicator goes further up) */
    .seat.seat-bottom .seat-bet-indicator {
      bottom: calc(100% + 70px); /* Above tile + player-info height + larger gap */
    }
    
    .seat-bet-indicator.show {
      opacity: 1;
      animation: betIndicatorPulse 0.5s ease-out;
    }
    
    .seat.seat-top .seat-bet-indicator.show {
      transform: translateX(-50%) translateY(5px);
    }
    
    .seat.seat-bottom .seat-bet-indicator.show {
      transform: translateX(-50%) translateY(-5px);
    }
    
    .seat-bet-indicator.fade-out {
      opacity: 0;
    }
    
    .seat.seat-top .seat-bet-indicator.fade-out {
      transform: translateX(-50%) translateY(10px);
    }
    
    .seat.seat-bottom .seat-bet-indicator.fade-out {
      transform: translateX(-50%) translateY(-10px);
    }
    
    @keyframes betIndicatorPulse {
      0% {
        transform: translateX(-50%) scale(0.8);
        opacity: 0;
      }
      50% {
        transform: translateX(-50%) scale(1.1);
      }
      100% {
        transform: translateX(-50%) translateY(-5px) scale(1);
        opacity: 1;
      }
    }
    
    .seat-tile .seat-chips {
      font-family: 'Outfit', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      color: #00ff88; /* Green dollar sign color */
      font-weight: 700;
      font-size: calc(22px * var(--tile-scale, 1)); /* Increased from 18px for better visibility */
      letter-spacing: calc(0.5px * var(--tile-scale, 1));
      text-align: center;
      margin-top: auto;
      margin-bottom: calc(8px * var(--tile-scale, 1));
    }
    
    /* Empty seat "claim" text - large and centered, scales proportionally */
    .seat.empty .seat-chips {
      font-size: calc(32px * var(--tile-scale, 1));
      font-weight: 800;
      color: rgba(0, 212, 170, 1);
      letter-spacing: calc(2px * var(--tile-scale, 1));
      text-transform: uppercase;
      margin: auto;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
    }
    
    /* Cards inside tile - prominent at top */
    .seat-tile .seat-cards {
      display: flex;
      gap: calc(8px * var(--tile-scale, 1));
      justify-content: center;
      align-items: center;
      flex: 1;
      min-height: 0;
      padding-top: calc(8px * var(--tile-scale, 1));
    }
    
    /* Card sizing inside tile - larger base size for better visibility */
    .seat-tile .seat-card-back, 
    .seat-tile .seat-card-front {
      /* Base size: 85x119px (increased from 70x98px), scales proportionally with tile */
      width: calc(81px * var(--tile-scale, 1));
      height: calc(113px * var(--tile-scale, 1));
      border-radius: calc(8px * var(--tile-scale, 1));
      box-shadow: 0 calc(4px * var(--tile-scale, 1)) calc(12px * var(--tile-scale, 1)) rgba(0,0,0,0.6);
      transition: transform 0.3s ease, opacity 0.3s ease, filter 0.3s ease;
      object-fit: cover;
    }
    
    /* Your seat cards slightly larger */
    .seat.me .seat-tile .seat-card-back,
    .seat.me .seat-tile .seat-card-front {
      width: calc(90px * var(--tile-scale, 1));
      height: calc(126px * var(--tile-scale, 1));
    }
    
    .seat-tile .seat-card-back:hover, 
    .seat-tile .seat-card-front:hover {
      transform: translateY(-4px);
    }
    
    .seat-card-back, .seat-card-front {
      width: 70px;
      height: 98px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.6);
      transition: transform 0.3s ease, opacity 0.3s ease, filter 0.3s ease;
      object-fit: cover;
    }
    
    .seat-card-back:hover, .seat-card-front:hover {
      transform: translateY(-4px);
    }
    
    .seat-card-back.folded, .seat-card-front.folded {
      opacity: 0.3;
      filter: grayscale(100%);
    }
    
    .seat-card-back.hidden {
      display: none;
    }
    
    /* üé∞ DEALER & BLIND BADGES */
    .position-badges {
      display: flex;
      gap: 4px;
      margin-top: 4px;
      justify-content: center;
    }
    
    .position-badge {
      font-size: 0.7rem;
      padding: 2px 6px;
      border-radius: 4px;
      font-weight: 600;
      border: 1px solid;
    }
    
    .position-badge.dealer {
      background: linear-gradient(135deg, #ffaa00, #ff8800);
      color: #0b0b12;
      border-color: #ffcc44;
    }
    
    .position-badge.sb {
      background: linear-gradient(135deg, #00aaff, #0088ff);
      color: white;
      border-color: #44ccff;
    }
    
    .position-badge.bb {
      background: linear-gradient(135deg, #ff3b3b, #ff0000);
      color: white;
      border-color: #ff6666;
    }
    
    /* üÉè SHOW/MUCK CONTROLS */
    .showdown-controls {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, rgba(15,15,25,0.95), rgba(20,20,30,0.95));
      border: 2px solid #ff5100;
      border-radius: 12px;
      padding: 20px;
      display: none;
      z-index: 999;
      box-shadow: 0 8px 24px rgba(0,0,0,0.5);
    }
    
    .showdown-controls.show {
      display: block;
    }
    
    .showdown-controls h3 {
      margin: 0 0 12px 0;
      color: #ff5100;
      font-size: 1rem;
      text-align: center;
    }
    
    .showdown-controls .button-group {
      display: flex;
      gap: 12px;
    }
    
    .showdown-controls button {
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 0.9rem;
    }
    
    .showdown-controls button.show-btn {
      background: linear-gradient(135deg, #00dd88, #00aa66);
      color: white;
    }
    
    .showdown-controls button.show-btn:hover {
      background: linear-gradient(135deg, #00ff99, #00cc77);
      transform: scale(1.05);
    }
    
    .showdown-controls button.muck-btn {
      background: linear-gradient(135deg, #666, #444);
      color: white;
    }
    
    .showdown-controls button.muck-btn:hover {
      background: linear-gradient(135deg, #777, #555);
      transform: scale(1.05);
    }
    
    /* üö® CUSTOM ALL-IN CONFIRMATION MODAL */
    .allin-confirm-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(8px);
      z-index: 10000;
      display: none;
      align-items: center;
      justify-content: center;
      animation: fadeIn 0.2s ease-out;
    }
    
    .allin-confirm-overlay.show {
      display: flex;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    .allin-confirm-modal {
      background: linear-gradient(135deg, rgba(15,15,25,0.98), rgba(20,20,30,0.98));
      border: 3px solid #ff5100;
      border-radius: 16px;
      padding: 32px;
      max-width: 400px;
      width: 90%;
      box-shadow: 0 16px 48px rgba(255, 81, 0, 0.4);
      animation: modalSlideIn 0.3s ease-out;
    }
    
    @keyframes modalSlideIn {
      from {
        transform: translateY(-20px);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }
    
    .allin-confirm-header h2 {
      margin: 0 0 20px 0;
      color: #ff5100;
      font-size: 1.5rem;
      text-align: center;
      font-family: 'JetBrains Mono', monospace;
    }
    
    .allin-confirm-body {
      margin-bottom: 24px;
    }
    
    .allin-confirm-body p {
      color: #e9eef7;
      font-size: 1rem;
      margin: 12px 0;
      text-align: center;
    }
    
    .allin-confirm-body strong {
      color: #ff5100;
      font-size: 1.2em;
    }
    
    .allin-warning {
      color: #ff6b6b !important;
      font-weight: 600;
    }
    
    .allin-checkbox-label {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 16px;
      cursor: pointer;
      color: #9aa3b2;
      font-size: 0.9rem;
    }
    
    .allin-checkbox-label input[type="checkbox"] {
      width: 18px;
      height: 18px;
      cursor: pointer;
      accent-color: #ff5100;
    }
    
    .allin-confirm-actions {
      display: flex;
      gap: 12px;
      justify-content: center;
    }
    
    .allin-confirm-btn {
      padding: 12px 24px;
      border: none;
      border-radius: 8px;
      font-weight: 600;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.2s;
      font-family: 'JetBrains Mono', monospace;
    }
    
    .allin-confirm-btn.allin-cancel {
      background: rgba(255, 255, 255, 0.1);
      color: #e9eef7;
      border: 2px solid rgba(255, 255, 255, 0.2);
    }
    
    .allin-confirm-btn.allin-cancel:hover {
      background: rgba(255, 255, 255, 0.15);
      transform: translateY(-2px);
    }
    
    .allin-confirm-btn.allin-confirm {
      background: linear-gradient(135deg, #ff5100, #ff3300);
      color: white;
      border: 2px solid #ff5100;
    }
    
    .allin-confirm-btn.allin-confirm:hover {
      background: linear-gradient(135deg, #ff6600, #ff4400);
      transform: translateY(-2px);
      box-shadow: 0 8px 24px rgba(255, 81, 0, 0.4);
    }
    
    /* üéõÔ∏è HOST CONTROLS PANEL */
    .host-controls-panel {
      background: linear-gradient(135deg, rgba(255,81,0,0.1), rgba(255,81,0,0.05));
      border: 2px solid #ff5100;
      border-radius: 12px;
      padding: 0;
      margin-bottom: 20px;
      display: none; /* Hidden by default, shown for host only */
      overflow: hidden;
    }
    
    .host-controls-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px 20px;
      background: rgba(255,81,0,0.15);
      cursor: pointer;
      user-select: none;
      transition: background 0.2s;
    }
    
    .host-controls-header:hover {
      background: rgba(255,81,0,0.2);
    }
    
    .host-controls-header h3 {
      color: #ff5100;
      font-size: 1.1rem;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .host-badge {
      background: #ff5100;
      color: white;
      padding: 4px 10px;
      border-radius: 6px;
      font-size: 0.75rem;
      font-weight: 700;
    }
    
    .host-controls-content {
      max-height: 0;
      opacity: 0;
      transition: all 0.3s ease;
      pointer-events: none;
    }
    
    .host-controls-content.expanded {
      max-height: 600px;
      opacity: 1;
      pointer-events: auto;
      padding: 20px;
    }
    
    .host-section {
      background: rgba(255,255,255,0.05);
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 15px;
    }
    
    .host-section:last-child {
      margin-bottom: 0;
    }
    
    .host-section.priority-section {
      border: 2px solid #ff5100;
      background: rgba(255, 81, 0, 0.1);
    }
    
    .host-section h4 {
      color: #00d4aa;
      font-size: 0.95rem;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .player-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .player-item {
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      padding: 12px 15px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border: 1px solid rgba(255,255,255,0.1);
    }
    
    .player-item-info {
      flex: 1;
    }
    
    .player-item-name {
      color: #e9eef7;
      font-weight: 600;
      font-size: 1rem;
      margin-bottom: 4px;
    }
    
    .player-item-details {
      color: #999;
      font-size: 0.85rem;
      display: flex;
      gap: 15px;
    }
    
    .player-item-chips {
      color: gold;
    }
    
    .host-btn {
      padding: 8px 16px;
      border-radius: 6px;
      border: none;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      white-space: nowrap;
    }
    
    .host-btn.kick {
      background: #ff3b3b;
      color: white;
    }
    
    .host-btn.kick:hover {
      background: #ff5555;
      transform: scale(1.05);
    }
    
    /* ü™ë SEAT REQUEST NOTIFICATION POPUP */
    .host-notification-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(8px);
      z-index: 10000;
      display: flex;
      align-items: center;
      justify-content: center;
      animation: fadeIn 0.2s ease-out;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    .host-notification-modal {
      background: linear-gradient(135deg, rgba(15,15,25,0.98), rgba(20,20,30,0.98));
      border: 3px solid #ff5100;
      border-radius: 16px;
      padding: 0;
      max-width: 450px;
      width: 90%;
      box-shadow: 0 16px 48px rgba(255, 81, 0, 0.4);
      animation: modalSlideIn 0.3s ease-out;
    }
    
    @keyframes modalSlideIn {
      from {
        transform: translateY(-20px);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }
    
    .host-notification-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px 24px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .host-notification-header h3 {
      margin: 0;
      color: #ff5100;
      font-size: 1.3rem;
      font-family: 'JetBrains Mono', monospace;
    }
    
    .host-notification-header .close-btn {
      background: none;
      border: none;
      color: #9aa3b2;
      font-size: 1.5rem;
      cursor: pointer;
      padding: 0;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
      transition: all 0.2s;
    }
    
    .host-notification-header .close-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      color: #e9eef7;
    }
    
    .host-notification-body {
      padding: 24px;
    }
    
    .host-notification-body p {
      color: #e9eef7;
      font-size: 1rem;
      margin: 0 0 20px 0;
      line-height: 1.6;
    }
    
    .host-notification-body strong {
      color: #00d4aa;
    }
    
    .request-details {
      margin-top: 16px;
    }
    
    .request-chip-input {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    .request-chip-input label {
      color: #9aa3b2;
      font-size: 0.9rem;
      min-width: 100px;
    }
    
    .request-chip-input .form-input {
      flex: 1;
      padding: 10px 12px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 6px;
      color: #e9eef7;
      font-size: 1rem;
    }
    
    .host-notification-actions {
      display: flex;
      gap: 12px;
      padding: 20px 24px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .host-notification-btn {
      flex: 1;
      padding: 12px 24px;
      border: none;
      border-radius: 8px;
      font-weight: 600;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.2s;
      font-family: 'JetBrains Mono', monospace;
    }
    
    .host-notification-btn.reject {
      background: rgba(255, 59, 59, 0.2);
      color: #ff6b6b;
      border: 2px solid #ff3b3b;
    }
    
    .host-notification-btn.reject:hover {
      background: rgba(255, 59, 59, 0.3);
      transform: translateY(-2px);
    }
    
    .host-notification-btn.approve {
      background: linear-gradient(135deg, #00d4aa, #00b894);
      color: white;
      border: 2px solid #00d4aa;
    }
    
    .host-notification-btn.approve:hover {
      background: linear-gradient(135deg, #00ffcc, #00d4aa);
      transform: translateY(-2px);
      box-shadow: 0 8px 24px rgba(0, 212, 170, 0.4);
    }
    
    /* Pending requests list */
    .seat-request-item {
      background: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
      padding: 12px 15px;
      margin-bottom: 10px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .seat-request-info {
      flex: 1;
    }
    
    .seat-request-name {
      color: #e9eef7;
      font-weight: 600;
      margin-bottom: 4px;
    }
    
    .seat-request-details {
      color: #9aa3b2;
      font-size: 0.85rem;
    }
    
    .seat-request-actions {
      display: flex;
      gap: 8px;
    }
    
    .seat-request-btn {
      padding: 6px 12px;
      border-radius: 6px;
      border: none;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .seat-request-btn.approve {
      background: #00d4aa;
      color: #0b0b12;
    }
    
    .seat-request-btn.reject {
      background: #ff3b3b;
      color: white;
    }
    
    .seat-request-btn:hover {
      transform: scale(1.05);
    }
    
    .empty-state {
      color: #9aa3b2;
      font-size: 0.9rem;
      text-align: center;
      padding: 20px;
      font-style: italic;
    }
    
    .blinds-controls {
      display: flex;
      gap: 15px;
      align-items: center;
      flex-wrap: wrap;
    }
    
    .blind-input-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .blind-input-group label {
      color: #9aa3b2;
      font-weight: 600;
      font-size: 0.9rem;
    }
    
    .blind-input-group input {
      width: 90px;
      padding: 10px;
      border-radius: 6px;
      border: 2px solid #333;
      background: rgba(0,0,0,0.4);
      color: #e9eef7;
      font-size: 1rem;
      font-weight: 600;
    }
    
    .blind-input-group input:focus {
      outline: none;
      border-color: #00d4aa;
    }
    
    .host-btn.update {
      background: #00d4aa;
      color: #0b0b12;
      padding: 10px 20px;
      font-size: 0.95rem;
    }
    
    .host-btn.update:hover {
      background: #00ffcc;
      transform: translateY(-2px);
    }
    
    .empty-state {
      color: #666;
      font-style: italic;
      text-align: center;
      padding: 15px;
    }
    
    .toggle-icon {
      color: #ff5100;
      font-size: 1.2rem;
      transition: transform 0.3s;
    }
    
    .toggle-icon.expanded {
      transform: rotate(180deg);
    }
    
    /* Section hints */
    .section-hint {
      font-size: 0.85rem;
      color: rgba(255,255,255,0.6);
      margin: -8px 0 12px 0;
      font-style: italic;
    }
    
    /* Form elements */
    .form-select, .form-input {
      width: 100%;
      padding: 10px;
      border-radius: 8px;
      background: rgba(255,255,255,0.08);
      color: white;
      border: 1px solid rgba(255,255,255,0.2);
      font-family: "Courier New", monospace;
      font-size: 0.95rem;
      transition: all 0.3s ease;
    }
    
    .form-select:focus, .form-input:focus {
      outline: none;
      border-color: var(--teal);
      background: rgba(255,255,255,0.12);
      box-shadow: 0 0 0 2px rgba(0, 212, 170, 0.2);
    }
    
    .chip-adjustment-controls {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    
    /* Player Settings Panel (Non-Hosts) */
    #playerSettingsPanel {
      max-width: 1400px;
      margin: 20px auto;
      background: rgba(20, 20, 40, 0.8);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 16px;
      padding: 24px;
      backdrop-filter: blur(10px);
    }
    
    #playerSettingsPanel .panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: pointer;
      user-select: none;
      padding-bottom: 16px;
      border-bottom: 2px solid rgba(255,255,255,0.1);
      margin-bottom: 20px;
    }
    
    #playerSettingsPanel .panel-header h2 {
      color: var(--teal);
      font-size: 1.3rem;
      font-weight: 700;
      margin: 0;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    #playerSettingsPanel .collapse-btn {
      background: transparent;
      border: none;
      cursor: pointer;
      padding: 8px;
    }
    
    #playerSettingsPanel .panel-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease;
    }
    
    #playerSettingsPanel .panel-content.expanded {
      max-height: 1000px;
    }
    
    .color-picker-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
      gap: 12px;
      margin-top: 16px;
    }
    
    .color-btn {
      background: rgba(255,255,255,0.05);
      border: 2px solid rgba(255,255,255,0.2);
      border-radius: 12px;
      padding: 12px;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }
    
    .color-btn:hover {
      background: rgba(255,255,255,0.1);
      border-color: var(--teal);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 212, 170, 0.3);
    }
    
    .color-btn.active {
      border-color: var(--accent);
      background: rgba(255, 81, 0, 0.1);
      box-shadow: 0 0 20px rgba(255, 81, 0, 0.4);
    }
    
    /* Toggle Switch */
    .toggle-switch {
      display: flex;
      align-items: center;
      gap: 12px;
      cursor: pointer;
    }
    
    .toggle-switch input[type="checkbox"] {
      position: absolute;
      opacity: 0;
      width: 0;
      height: 0;
    }
    
    .toggle-slider {
      position: relative;
      display: inline-block;
      width: 50px;
      height: 26px;
      background: rgba(255,255,255,0.1);
      border-radius: 13px;
      transition: all 0.3s;
      border: 2px solid rgba(255,255,255,0.2);
    }
    
    .toggle-slider::after {
      content: '';
      position: absolute;
      width: 18px;
      height: 18px;
      left: 2px;
      top: 2px;
      background: #e9eef7;
      border-radius: 50%;
      transition: all 0.3s;
    }
    
    .toggle-switch input:checked + .toggle-slider {
      background: #00d4aa;
      border-color: #00d4aa;
    }
    
    .toggle-switch input:checked + .toggle-slider::after {
      transform: translateX(24px);
    }
    
    .toggle-label {
      color: #e9eef7;
      font-size: 0.9rem;
    }
    
    /* Settings Select */
    .settings-select {
      width: 100%;
      padding: 10px 14px;
      background: rgba(255,255,255,0.05);
      border: 2px solid rgba(255,255,255,0.2);
      border-radius: 8px;
      color: #e9eef7;
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.3s;
    }
    
    .settings-select:hover {
      border-color: #00d4aa;
      background: rgba(255,255,255,0.08);
    }
    
    .settings-select:focus {
      outline: none;
      border-color: #00d4aa;
      box-shadow: 0 0 0 3px rgba(0, 212, 170, 0.2);
    }
    
    /* Setting Note */
    .setting-note {
      margin-top: 8px;
      font-size: 0.8rem;
      color: #9aa3b2;
      font-style: italic;
    }
    
    /* ============================================ */
    /* HOST CONTROLS PANEL - MATCHES PLAYER SETTINGS */
    /* ============================================ */
    
    #hostControlsPanel {
      max-width: 1400px;
      margin: 20px auto;
      background: rgba(20, 20, 40, 0.8);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 16px;
      padding: 24px;
      backdrop-filter: blur(10px);
      display: none; /* Hidden by default, shown only for hosts */
    }
    
    #hostControlsPanel .panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: pointer;
      user-select: none;
      padding-bottom: 16px;
      border-bottom: 2px solid rgba(255,255,255,0.1);
      margin-bottom: 20px;
    }
    
    #hostControlsPanel .panel-header h2 {
      color: var(--accent);
      font-size: 1.3rem;
      font-weight: 700;
      margin: 0;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    .host-badge {
      font-size: 0.7rem;
      background: rgba(255, 81, 0, 0.2);
      color: var(--accent);
      padding: 4px 10px;
      border-radius: 20px;
      border: 1px solid var(--accent);
      font-weight: 600;
      letter-spacing: 0.5px;
    }
    
    #hostControlsPanel .collapse-btn {
      background: transparent;
      border: none;
      cursor: pointer;
      padding: 8px;
    }
    
    #hostControlsPanel .panel-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease;
    }
    
    #hostControlsPanel .panel-content.expanded {
      max-height: 2000px;
    }
    
    .host-actions-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 12px;
      margin-top: 16px;
    }
    
    .host-control-btn {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      padding: 16px 12px;
      border-radius: 10px;
      font-family: "Courier New", monospace;
      font-weight: 600;
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.3s ease;
      border: 2px solid;
      background: rgba(255,255,255,0.03);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .host-control-btn .btn-icon {
      font-size: 1.5rem;
    }
    
    .host-control-btn .btn-text {
      font-size: 0.8rem;
      line-height: 1.2;
      text-align: center;
    }
    
    .host-control-btn.action {
      color: #00d4aa;
      border-color: #00d4aa;
    }
    
    .host-control-btn.action:hover {
      background: rgba(0, 212, 170, 0.2);
      border-color: #00ffcc;
      transform: translateY(-3px);
      box-shadow: 0 6px 20px rgba(0, 212, 170, 0.4);
    }
    
    .host-control-btn.update {
      color: #00d4aa;
      border-color: #00d4aa;
      width: 100%;
      margin-top: 12px;
    }
    
    .host-control-btn.update:hover {
      background: rgba(0, 212, 170, 0.2);
      border-color: #00ffcc;
      transform: translateY(-2px);
    }
    
    .host-control-btn.danger {
      color: #ff5151;
      border-color: #ff5151;
    }
    
    .host-control-btn.danger:hover {
      background: rgba(255, 81, 81, 0.2);
      border-color: #ff6666;
      transform: translateY(-3px);
      box-shadow: 0 6px 20px rgba(255, 81, 81, 0.4);
    }
    
    .host-control-btn.paused {
      background: rgba(249, 115, 22, 0.2);
      color: #f97316;
      border-color: #f97316;
    }
    
    .setting-group {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-bottom: 20px;
    }
    
    .setting-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 14px 16px;
      background: rgba(255,255,255,0.03);
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.1);
      margin-bottom: 12px;
    }
    
    .setting-label {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    
    .setting-label span {
      color: #e9eef7;
      font-size: 0.95rem;
      font-weight: 500;
    }
    
    .setting-label small {
      color: #9aa3b2;
      font-size: 0.8rem;
    }
    
    .timer-buttons {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 8px;
    }
    
    .timer-btn {
      flex: 1;
      min-width: 60px;
      padding: 10px 15px;
      background: rgba(255,255,255,0.05);
      color: #e9eef7;
      border: 2px solid rgba(255,255,255,0.2);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-family: "Courier New", monospace;
      font-size: 0.9rem;
      font-weight: 600;
    }
    
    .timer-btn:hover {
      background: rgba(0, 212, 170, 0.15);
      border-color: #00d4aa;
      color: #00d4aa;
      transform: translateY(-2px);
    }
    
    .timer-btn.active {
      background: #00d4aa;
      color: #0b0b12;
      border-color: #00d4aa;
      font-weight: 700;
      box-shadow: 0 0 15px rgba(0, 212, 170, 0.5);
    }
    
    .timer-status {
      text-align: center;
      padding: 12px;
      background: rgba(255,255,255,0.03);
      border-radius: 8px;
      font-family: "Courier New", monospace;
      color: #9aa3b2;
      margin-top: 8px;
      font-size: 0.9rem;
    }
    
    .timer-status span {
      color: #00d4aa;
      font-weight: 700;
      font-size: 1rem;
    }
    
    .blinds-controls {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-top: 16px;
    }
    
    .blind-input-group {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    
    .blind-input-group label {
      color: #e9eef7;
      font-size: 0.9rem;
      font-weight: 500;
      min-width: 100px;
    }
    
    .blind-input-group input,
    .blind-input-group select {
      flex: 1;
      padding: 10px 14px;
      background: rgba(255,255,255,0.05);
      border: 2px solid rgba(255,255,255,0.2);
      border-radius: 8px;
      color: #e9eef7;
      font-size: 0.9rem;
      font-family: "Courier New", monospace;
      font-weight: 600;
      transition: all 0.3s;
    }
    
    .blind-input-group input:focus,
    .blind-input-group select:focus {
      outline: none;
      border-color: #00d4aa;
      box-shadow: 0 0 0 3px rgba(0, 212, 170, 0.2);
      background: rgba(255,255,255,0.08);
    }
    
    .form-input {
      padding: 10px 14px;
      background: rgba(255,255,255,0.05);
      border: 2px solid rgba(255,255,255,0.2);
      border-radius: 8px;
      color: #e9eef7;
      font-size: 0.9rem;
      font-family: "Courier New", monospace;
      font-weight: 600;
      transition: all 0.3s;
    }
    
    .form-input:focus {
      outline: none;
      border-color: #00d4aa;
      box-shadow: 0 0 0 3px rgba(0, 212, 170, 0.2);
      background: rgba(255,255,255,0.08);
    }
    
    .danger-zone {
      border: 2px solid rgba(255, 81, 81, 0.3);
      border-radius: 12px;
      padding: 20px;
      background: rgba(255, 81, 81, 0.05);
      margin-top: 24px;
    }
    
    .danger-zone h4 {
      color: #ff5151;
      margin-bottom: 8px;
    }
    
    .danger-zone .section-hint {
      color: #ff8888;
    }
    
    /* ============================================ */
    /* COMPACT HOST CONTROLS STYLES */
    /* ============================================ */
    
    /* Compact Players Section */
    .players-section {
      margin-bottom: 24px;
    }
    
    .blinds-controls-compact {
      margin-bottom: 20px;
      padding: 16px;
      background: rgba(255,255,255,0.03);
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.1);
    }
    
    .blind-input-row {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }
    
    .blind-input-group {
      flex: 1;
      min-width: 120px;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .blind-input-group label {
      font-size: 0.8rem;
      color: #9aa3b2;
      white-space: nowrap;
      flex-shrink: 0;
    }
    
    .form-input.compact {
      flex: 1;
      min-width: 60px;
      padding: 6px 10px;
      font-size: 0.85rem;
      max-width: 80px;
    }
    
    .host-control-btn.compact {
      padding: 8px 16px;
      font-size: 0.8rem;
      margin: 0;
      flex-shrink: 0;
      white-space: nowrap;
    }
    
    .section-subheader {
      display: flex;
      align-items: center;
      gap: 8px;
      margin: 16px 0 12px 0;
      font-size: 0.9rem;
      color: #9aa3b2;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    /* Compact Player Items */
    .player-item-compact {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 16px;
      background: rgba(255,255,255,0.03);
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.1);
      margin-bottom: 8px;
      transition: all 0.2s ease;
    }
    
    .player-item-compact:hover {
      background: rgba(255,255,255,0.05);
      border-color: rgba(0, 212, 170, 0.3);
    }
    
    .player-item-info-compact {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    
    .player-item-name-compact {
      color: #e9eef7;
      font-size: 0.95rem;
      font-weight: 500;
    }
    
    .you-badge {
      color: #00d4aa;
      font-size: 0.8rem;
    }
    
    .player-item-details-compact {
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: 0.85rem;
    }
    
    .seat-badge {
      color: #9aa3b2;
      font-family: "Courier New", monospace;
    }
    
    .chips-badge {
      color: #00d4aa;
      font-family: "Courier New", monospace;
      font-weight: 600;
    }
    
    .kick-btn-compact {
      background: transparent;
      border: 1px solid rgba(255, 81, 81, 0.3);
      color: #ff5151;
      padding: 8px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 1rem;
      transition: all 0.2s ease;
    }
    
    .kick-btn-compact:hover {
      background: rgba(255, 81, 81, 0.15);
      border-color: #ff5151;
      transform: scale(1.1);
    }
    
    /* Compact Seat Requests */
    .seat-request-item-compact {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 16px;
      background: rgba(255, 165, 0, 0.1);
      border-radius: 8px;
      border: 1px solid rgba(255, 165, 0, 0.3);
      margin-bottom: 8px;
    }
    
    .seat-request-info-compact {
      flex: 1;
    }
    
    .seat-request-name-compact {
      color: #e9eef7;
      font-weight: 600;
      font-size: 0.95rem;
    }
    
    .seat-request-details-compact {
      color: #9aa3b2;
      font-size: 0.85rem;
      margin-top: 4px;
    }
    
    .seat-request-actions-compact {
      display: flex;
      gap: 8px;
    }
    
    .approve-btn-compact, .reject-btn-compact {
      background: transparent;
      border: 1px solid;
      padding: 8px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 1rem;
      transition: all 0.2s ease;
    }
    
    .approve-btn-compact {
      border-color: rgba(0, 212, 170, 0.3);
      color: #00d4aa;
    }
    
    .approve-btn-compact:hover {
      background: rgba(0, 212, 170, 0.15);
      border-color: #00d4aa;
    }
    
    .reject-btn-compact {
      border-color: rgba(255, 81, 81, 0.3);
      color: #ff5151;
    }
    
    .reject-btn-compact:hover {
      background: rgba(255, 81, 81, 0.15);
      border-color: #ff5151;
    }
    
    /* Compact Controls Section */
    .controls-section {
      margin-bottom: 24px;
    }
    
    .controls-grid-compact {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
      gap: 8px;
    }
    
    .control-btn-small {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 4px;
      padding: 8px 10px;
      border-radius: 6px;
      font-family: "Courier New", monospace;
      font-weight: 600;
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.2s ease;
      border: 2px solid;
      background: rgba(255,255,255,0.03);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      min-height: 60px;
    }
    
    .control-btn-small.action {
      color: #00d4aa;
      border-color: #00d4aa;
    }
    
    .control-btn-small.action:hover {
      background: rgba(0, 212, 170, 0.2);
      border-color: #00ffcc;
      transform: translateY(-2px);
    }
    
    .control-btn-small.danger {
      color: #ff5151;
      border-color: #ff5151;
    }
    
    .control-btn-small.danger:hover {
      background: rgba(255, 81, 81, 0.2);
      border-color: #ff6666;
      transform: translateY(-2px);
    }
    
    .control-btn-small.timer-control,
    .control-btn-small.toggle-control {
      color: #e9eef7;
      border-color: rgba(255,255,255,0.2);
      flex-direction: column;
      justify-content: center;
      padding: 8px 6px;
      min-height: auto;
    }
    
    .control-btn-small.timer-control {
      grid-column: span 2;
    }
    
    .control-btn-small.timer-control:hover,
    .control-btn-small.toggle-control:hover {
      background: rgba(255,255,255,0.05);
      border-color: rgba(255,255,255,0.3);
    }
    
    .btn-icon-small {
      font-size: 1rem;
    }
    
    .btn-text-small {
      font-size: 0.65rem;
      line-height: 1;
    }
    
    .timer-buttons-inline {
      display: flex;
      gap: 3px;
      align-items: center;
      flex-wrap: wrap;
      justify-content: center;
      margin-top: 4px;
    }
    
    .timer-btn-tiny {
      padding: 3px 6px;
      background: rgba(255,255,255,0.05);
      color: #e9eef7;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.65rem;
      font-weight: 600;
      transition: all 0.2s ease;
      font-family: "Courier New", monospace;
      white-space: nowrap;
    }
    
    .timer-btn-tiny:hover {
      background: rgba(0, 212, 170, 0.15);
      border-color: #00d4aa;
      color: #00d4aa;
    }
    
    .timer-btn-tiny.active {
      background: #00d4aa;
      color: #0b0b12;
      border-color: #00d4aa;
    }
    
    .toggle-switch-tiny {
      position: relative;
      width: 36px;
      height: 20px;
      flex-shrink: 0;
    }
    
    .toggle-switch-tiny input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    
    .toggle-slider-tiny {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(255,255,255,0.2);
      transition: 0.3s;
      border-radius: 20px;
    }
    
    .toggle-slider-tiny:before {
      position: absolute;
      content: "";
      height: 14px;
      width: 14px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: 0.3s;
      border-radius: 50%;
    }
    
    .toggle-switch-tiny input:checked + .toggle-slider-tiny {
      background-color: #00d4aa;
    }
    
    .toggle-switch-tiny input:checked + .toggle-slider-tiny:before {
      transform: translateX(16px);
    }
    
    /* Compact Settings Grid */
    .settings-compact-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 8px;
    }
    
    .setting-item-compact {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
      padding: 10px 8px;
      background: rgba(255,255,255,0.03);
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.1);
    }
    
    .setting-label-compact {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2px;
      text-align: center;
    }
    
    .setting-label-compact span {
      color: #e9eef7;
      font-size: 0.8rem;
      font-weight: 500;
      white-space: nowrap;
    }
    
    .setting-label-compact small {
      color: #9aa3b2;
      font-size: 0.7rem;
    }
    
    /* Compact Settings Select */
    .settings-select-compact {
      width: 100%;
      padding: 6px 8px;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 6px;
      color: #e9eef7;
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .settings-select-compact:hover {
      border-color: #00d4aa;
      background: rgba(255,255,255,0.08);
    }
    
    .settings-select-compact:focus {
      outline: none;
      border-color: #00d4aa;
      box-shadow: 0 0 0 2px rgba(0, 212, 170, 0.2);
    }
    
    /* Hotkey List */
    .hotkey-list div {
      padding: 6px 0;
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }
    
    .hotkey-list div:last-child {
      border-bottom: none;
    }
    
    kbd {
      display: inline-block;
      padding: 3px 8px;
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 4px;
      font-family: "Courier New", monospace;
      font-size: 0.85rem;
      color: #00d4aa;
      margin-right: 8px;
    }
    
    .color-preview {
      width: 60px;
      height: 60px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.4), inset 0 2px 8px rgba(255,255,255,0.1);
      transition: all 0.3s ease;
    }
    
    .color-btn:hover .color-preview {
      transform: scale(1.1);
    }
    
    .color-btn span {
      color: white;
      font-size: 0.85rem;
      font-weight: 600;
      font-family: "Courier New", monospace;
    }
    
    .controls {
      background: rgba(255,255,255,0.05);
      padding: 20px;
      border-radius: 12px;
      margin-bottom: 30px;
    }
    
    /* Subtle blink animation for active buttons */
    @keyframes subtlePulse {
      0%, 100% {
        opacity: 1;
        box-shadow: 0 0 0 rgba(255, 255, 255, 0);
      }
      50% {
        opacity: 0.85;
        box-shadow: 0 0 20px rgba(255, 255, 255, 0.15);
      }
    }
    
    /* BASE BUTTON STYLES - No liquid glass by default */
    .btn {
      padding: 18px 40px;
      background: #0b0b12;
      color: #e9eef7;
      border: 3px solid;
      border-radius: 8px;
      font-family: "Courier New", monospace;
      font-weight: 600;
      font-size: 20px;
      cursor: pointer;
      transition: all 0.2s ease;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    /* Action Buttons - Clean, Clear Design with Colored Borders */
    /* ========================================
       ACTION BUTTONS - LIQUID GLASS TILES (SAME AS DOCK)
       ======================================== */
    .action-btn {
      position: relative;
      z-index: 100;
      min-width: 280px;
      min-height: 80px;
      padding: 24px 60px;
      cursor: pointer;
      transition: all 0.25s ease;
      border-radius: 16px;
      /* Override browser button default background */
      background: transparent;
      /* Let liquid glass pseudo-elements handle the background/blur/distortion */
    }
    
    /* Text layer - positioned ABOVE liquid glass effects */
    .action-btn-text {
      position: relative;
      z-index: 1001; /* Above liquid glass ::before (z-index: 1000) */
      display: block;
      font-family: 'JetBrains Mono', monospace;
      font-size: 1.5rem;
      font-weight: 700;
      letter-spacing: 3px;
      text-transform: uppercase;
      /* Text is completely separate from distortion layer */
      filter: none;
    }
    
    .action-btn:hover:not(:disabled):not(.not-your-turn) {
      transform: translateY(-3px);
    }
    
    .action-btn:active:not(:disabled):not(.not-your-turn) {
      transform: translateY(-1px);
    }
    
    /* FOLD Button - Red text with glow */
    #foldBtn {
      border: 2px solid rgba(239, 68, 68, 0.3);
    }
    
    #foldBtn .action-btn-text {
      color: #ef4444;
    }
    
    #foldBtn:hover:not(:disabled):not(.not-your-turn) {
      border-color: rgba(248, 113, 113, 0.5);
    }
    
    #foldBtn:hover:not(:disabled):not(.not-your-turn) .action-btn-text {
      color: #f87171;
      text-shadow: 0 0 12px rgba(239, 68, 68, 0.6);
    }
    
    /* CALL/CHECK Button - Teal (matches dock accent) */
    #callBtn {
      border: 2px solid rgba(0, 212, 170, 0.3);
    }
    
    #callBtn .action-btn-text {
      color: #00d4aa;
    }
    
    #callBtn:hover:not(:disabled):not(.not-your-turn) {
      border-color: rgba(0, 255, 204, 0.5);
    }
    
    #callBtn:hover:not(:disabled):not(.not-your-turn) .action-btn-text {
      color: #00ffcc;
      text-shadow: 0 0 12px rgba(0, 212, 170, 0.6);
    }
    
    /* RAISE/BET Button - Orange (matches dock primary) */
    #raiseBtn {
      border: 2px solid rgba(255, 81, 0, 0.3);
    }
    
    #raiseBtn .action-btn-text {
      color: #ff5100;
    }
    
    #raiseBtn:hover:not(:disabled):not(.not-your-turn) {
      border-color: rgba(255, 106, 46, 0.5);
    }
    
    #raiseBtn:hover:not(:disabled):not(.not-your-turn) .action-btn-text {
      color: #ff6a2e;
      text-shadow: 0 0 12px rgba(255, 81, 0, 0.6);
    }
    
    /* Disabled/Not Your Turn State */
    .action-btn:disabled,
    .action-btn.not-your-turn {
      opacity: 0.25;
      cursor: not-allowed;
      transform: none !important;
    }
    
    .action-btn:disabled:hover,
    .action-btn.not-your-turn:hover {
      transform: none !important;
    }
    
    
    /* Force white text on start button */
    #startBtn, #refreshBtn {
      color: #ffffff !important;
    }
    
    /* ============================================ */
    /* RAISE PANEL (Below Buttons - No Box) */
    /* ============================================ */
    .raise-panel {
      margin: 30px auto 0;
      max-width: 800px;
      padding: 20px 0;
      animation: panelSlideDown 0.3s ease-out;
    }
    
    @keyframes panelSlideDown {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    .raise-slider-section {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-bottom: 24px;
    }
    
    .raise-info {
      display: flex;
      justify-content: center;
      gap: 40px;
      margin-bottom: 20px;
      margin-top: 20px;
    }
    
    .raise-info-item {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    
    .raise-info-label {
      font-size: 13px;
      color: #9aa3b2;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .raise-info-value {
      font-size: 20px;
      font-weight: 700;
      color: #00d4aa;
      font-family: "Courier New", monospace;
    }
    
    .raise-presets {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 12px;
      margin-bottom: 20px;
    }
    
    .raise-preset-btn {
      padding: 12px;
      background: #0b0b12;
      color: #e9eef7;
      border: 2px solid #00d4aa;
      border-radius: 6px;
      font-family: "Courier New", monospace;
      font-weight: 600;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s ease;
      text-transform: uppercase;
    }
    
    .raise-preset-btn:hover {
      background: #00d4aa;
      color: #0b0b12;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 212, 170, 0.4);
    }
    
    
    .raise-input {
      padding: 12px 16px;
      background: #0b0b12;
      border: 2px solid rgba(0, 212, 170, 0.5);
      border-radius: 8px;
      color: #e9eef7;
      font-size: 18px;
      font-family: "Courier New", monospace;
      font-weight: 600;
      text-align: center;
      width: 200px;
      margin: 0 auto;
    }
    
    .raise-input:focus {
      outline: none;
      border-color: #00d4aa;
      box-shadow: 0 0 0 3px rgba(0, 212, 170, 0.2);
    }
    
    .raise-slider {
      width: 100%;
      height: 8px;
      background: rgba(0, 212, 170, 0.2);
      border-radius: 4px;
      outline: none;
      -webkit-appearance: none;
      appearance: none;
    }
    
    .raise-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      background: #00d4aa;
      cursor: pointer;
      border-radius: 50%;
      box-shadow: 0 2px 8px rgba(0, 212, 170, 0.5);
    }
    
    .raise-slider::-moz-range-thumb {
      width: 20px;
      height: 20px;
      background: #00d4aa;
      cursor: pointer;
      border-radius: 50%;
      border: none;
      box-shadow: 0 2px 8px rgba(0, 212, 170, 0.5);
    }
    
    .raise-slider-value {
      text-align: center;
      font-size: 32px;
      font-weight: 700;
      color: #00d4aa;
      font-family: "Courier New", monospace;
      margin-bottom: 8px;
    }
    
    .raise-actions {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-top: 20px;
    }
    
    .raise-actions .btn {
      min-width: 140px;
    }
    
    #raiseSubmitBtn {
      color: #00d4aa;
      border-color: #00d4aa;
    }
    
    #raiseSubmitBtn:hover {
      background: #00d4aa;
      color: #0b0b12;
    }
    
    
    
    .my-cards {
      background: rgba(0,212,170,0.1);
      border: 2px solid #00d4aa;
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 30px;
    }
    
    .my-cards h3 {
      color: #00d4aa;
      margin-bottom: 15px;
    }
    
    .cards-display {
      display: flex;
      gap: 10px;
    }
    
    .card {
      width: 80px;
      height: 112px;
      background-size: cover;
      background-position: center;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }
    
    
    /* Calming UI Adjustments */
    .container {
      max-width: 1400px;
      margin: 0 auto;
    }
    
    h2 {
      color: rgba(255,255,255,0.9);
      font-weight: 600;
      font-size: 1.1rem;
      margin-bottom: 16px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    #currentActor {
      color: var(--accent);
      font-weight: 700;
    }
    
    /* Add padding for fixed navbar */
    body {
      padding-top: 100px;
    }
  </style>
  
  <!-- Global CSS for navbar -->
  <link rel="stylesheet" href="/css/pokergeek.css">
  
  <!-- Liquid Glass Controller -->
  <script src="/js/liquid-glass-controller.js"></script>
  <!-- Global Animations (EXACT same as play page) -->
  <script src="/js/global-animations.js"></script>
  
  <!-- Supabase SDK -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <!-- Unified Auth System -->
  <script src="/js/auth-manager.js"></script>
  <script src="/js/nav-shared.js"></script>
  <script src="/js/navbar-template.js"></script>
  
  <!-- Social Features -->
  <link rel="stylesheet" href="/css/social-modals.css">
  <script src="/js/social-modals.js"></script>
  
  <!-- Rank Styling -->
  <link rel="stylesheet" href="/css/rank-styling.css">
  <script src="/js/username-styling.js"></script>
  
  <!-- Hand Evaluator (inline for browser compatibility) -->
  <script>
    // Hand Evaluator - Browser-compatible version
    window.handEvaluator = (function() {
      function evaluatePokerHand(holeCards, communityCards) {
        // Combine all cards (use available community cards)
        const allCards = [...holeCards, ...communityCards];
        
        // Parse cards: "Ah" -> { rank: 14, suit: 'h' }
        const cards = allCards.map(cardStr => {
          const rank = cardStr.charAt(0);
          const suit = cardStr.charAt(1);
          const rankValue = {
            '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9,
            'T': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14
          }[rank];
          return { rank: rankValue, suit, original: cardStr };
        });
        
        // Count ranks and suits
        const rankCounts = {};
        const suitCounts = {};
        
        cards.forEach(card => {
          rankCounts[card.rank] = (rankCounts[card.rank] || 0) + 1;
          suitCounts[card.suit] = (suitCounts[card.suit] || 0) + 1;
        });
        
        // Get rank groups
        const quads = [];
        const trips = [];
        const pairs = [];
        
        Object.entries(rankCounts).forEach(([rank, count]) => {
          if (count === 4) quads.push(parseInt(rank));
          if (count === 3) trips.push(parseInt(rank));
          if (count === 2) pairs.push(parseInt(rank));
        });
        
        quads.sort((a, b) => b - a);
        trips.sort((a, b) => b - a);
        pairs.sort((a, b) => b - a);
        
        // Check for flush
        const flushSuit = Object.entries(suitCounts).find(([suit, count]) => count >= 5)?.[0];
        
        // Check for straight
        const uniqueRanks = [...new Set(cards.map(c => c.rank))].sort((a, b) => b - a);
        let straightHigh = 0;
        
        for (let i = 0; i <= uniqueRanks.length - 5; i++) {
          if (uniqueRanks[i] - uniqueRanks[i + 4] === 4) {
            straightHigh = uniqueRanks[i];
            break;
          }
        }
        
        // Check for A-2-3-4-5 straight (wheel)
        if (uniqueRanks.includes(14) && uniqueRanks.includes(2) && uniqueRanks.includes(3) && 
            uniqueRanks.includes(4) && uniqueRanks.includes(5)) {
          straightHigh = 5;
        }
        
        // Determine hand ranking
        let handRank = 0;
        let handName = '';
        const rankNames = {
          2: '2', 3: '3', 4: '4', 5: '5', 6: '6', 7: '7', 8: '8', 9: '9',
          10: 'T', 11: 'J', 12: 'Q', 13: 'K', 14: 'A'
        };
        
        // Royal Flush
        if (flushSuit && straightHigh === 14) {
          const flushCards = cards.filter(c => c.suit === flushSuit);
          const flushRanks = flushCards.map(c => c.rank);
          if ([10, 11, 12, 13, 14].every(r => flushRanks.includes(r))) {
            handRank = 9;
            handName = 'Royal Flush';
          }
        }
        
        // Straight Flush
        if (handRank === 0 && flushSuit && straightHigh > 0) {
          const flushCards = cards.filter(c => c.suit === flushSuit);
          const flushRanks = flushCards.map(c => c.rank).sort((a, b) => b - a);
          let sfHigh = 0;
          for (let i = 0; i <= flushRanks.length - 5; i++) {
            if (flushRanks[i] - flushRanks[i + 4] === 4) {
              sfHigh = flushRanks[i];
              break;
            }
          }
          if (sfHigh > 0) {
            handRank = 8;
            handName = `Straight Flush (${rankNames[sfHigh]}-high)`;
          }
        }
        
        // Four of a Kind
        if (handRank === 0 && quads.length > 0) {
          handRank = 7;
          handName = `Four of a Kind (${rankNames[quads[0]]}s)`;
        }
        
        // Full House
        if (handRank === 0 && trips.length > 0 && (pairs.length > 0 || trips.length > 1)) {
          const bestTrips = trips[0];
          const bestPair = trips.length > 1 ? trips[1] : pairs[0];
          handRank = 6;
          handName = `Full House (${rankNames[bestTrips]}s over ${rankNames[bestPair]}s)`;
        }
        
        // Flush
        let flushCards = [];
        if (handRank === 0 && flushSuit) {
          handRank = 5;
          flushCards = cards.filter(c => c.suit === flushSuit)
            .sort((a, b) => b.rank - a.rank).slice(0, 5);
          handName = `Flush (${rankNames[flushCards[0].rank]}-high)`;
        }
        
        // Straight
        if (handRank === 0 && straightHigh > 0) {
          handRank = 4;
          handName = `Straight (${rankNames[straightHigh]}-high)`;
        }
        
        // Three of a Kind
        if (handRank === 0 && trips.length > 0) {
          handRank = 3;
          handName = `Three of a Kind (${rankNames[trips[0]]}s)`;
        }
        
        // Two Pair
        if (handRank === 0 && pairs.length >= 2) {
          handRank = 2;
          handName = `Two Pair (${rankNames[pairs[0]]}s and ${rankNames[pairs[1]]}s)`;
        }
        
        // One Pair
        if (handRank === 0 && pairs.length === 1) {
          handRank = 1;
          handName = `Pair (${rankNames[pairs[0]]}s)`;
        }
        
        // High Card
        if (handRank === 0) {
          const highCards = cards.sort((a, b) => b.rank - a.rank).slice(0, 5);
          const highCard = highCards[0].rank;
          handRank = 0;
          handName = `High Card (${rankNames[highCard]})`;
        }
        
        return {
          rank: handRank,
          name: handName,
          quads,
          trips,
          pairs,
          straightHigh,
          flushSuit,
          flushCards: flushCards.map(c => c.rank),
          kickers: []
        };
      }
      
      return { evaluatePokerHand };
    })();
  </script>
</head>
<body>
  <!-- EXACT Falling Cards from Play Page -->
  <div id="floating-cards" class="floating-cards"></div>
  
  <!-- UNIFIED NAVBAR (Injected by navbar-template.js) -->
  <div id="navbar-container"></div>
  
  <!-- üÉè SHOW/MUCK CONTROLS (showdown only) -->
  <div class="showdown-controls" id="showdownControls">
    <h3>üÉè Show your cards or muck?</h3>
    <div class="button-group">
      <button class="show-btn" onclick="showCards()">SHOW CARDS</button>
      <button class="muck-btn" onclick="muckCards()">MUCK</button>
    </div>
  </div>
  
  <!-- üö® CUSTOM ALL-IN CONFIRMATION MODAL -->
  <div class="allin-confirm-overlay" id="allinConfirmOverlay">
    <div class="allin-confirm-modal">
      <div class="allin-confirm-header">
        <h2>üö® Go All-In?</h2>
      </div>
      <div class="allin-confirm-body">
        <p>You are about to bet your entire stack of <strong id="allinConfirmAmount">$0</strong>.</p>
        <p class="allin-warning">This action cannot be undone.</p>
        <label class="allin-checkbox-label">
          <input type="checkbox" id="allinDontAskAgain">
          <span>Don't ask again this game</span>
        </label>
      </div>
      <div class="allin-confirm-actions">
        <button class="allin-confirm-btn allin-cancel" onclick="cancelAllIn()">Cancel</button>
        <button class="allin-confirm-btn allin-confirm" onclick="confirmAllIn()">Go All-In</button>
      </div>
    </div>
  </div>
  
  <div class="container">
    <!-- ROOM NAME: Plain text above dock, no box -->
    <div class="room-name-display">
      <span class="room-name-text" id="roomNameDisplay">Loading...</span><span class="typing-cursor">|</span>
      </div>

    <!-- POKER TABLE OS: THE DOCK (ONLY LIQUID GLASS BOX) -->
    <div class="poker-dock liquid-glass liquid-glass--md liquid-glass--no-hover">
      <!-- Left: Start Hand + Table Code + Connection -->
      <div class="dock-left">
        <button class="dock-action-btn" id="startBtn" onclick="startHand()" style="display: none;">Start Hand</button>
        <span class="dock-label">Table Code:</span>
        <span class="dock-code" id="roomCode">---</span>
        <div class="dock-connection" id="socketStatus">
        <span class="connection-dot"></span>
      </div>
    </div>
    
      <!-- Center: Game State -->
      <div class="dock-center">
        <span class="game-state-text" id="gameStateText">Waiting to start</span>
        <div class="hand-timer-bar" id="handTimerBar">
          <div class="hand-timer-fill" id="handTimerFill"></div>
        </div>
      </div>

      <!-- Right: Control Buttons (Dock Apps) -->
      <div class="dock-right">
        <button class="dock-app" id="hostControlsBtn" onclick="openHostControlsModal()" style="display: none;" title="Host Controls">
          <span class="dock-app-icon">‚öí</span>
          <span class="dock-app-label">Host Settings</span>
        </button>
        <button class="dock-app" id="playerSettingsBtn" onclick="openPlayerSettingsModal()" title="Settings">
          <span class="dock-app-icon">‚òª</span>
          <span class="dock-app-label">Settings</span>
        </button>
      </div>
      </div>
      
    <!-- üéõÔ∏è HOST CONTROLS MODAL - LIQUID GLASS STYLED -->
    <div id="hostControlsModal" class="modal-overlay" style="display: none;" onclick="closeModalOnOverlay(event, 'hostControlsModal')">
      <div class="modal-content liquid-glass liquid-glass--xl" onclick="event.stopPropagation()">
        <div class="modal-header">
        <h2>üéõÔ∏è HOST CONTROLS <span class="host-badge">ONLY YOU</span></h2>
          <button class="modal-close-btn" onclick="closeHostControlsModal()">√ó</button>
      </div>
      
        <div class="modal-body" id="hostControlsContent">
        
        <!-- ============================================ -->
        <!-- SECTION 1: PLAYERS & BLINDS (Unified) -->
        <!-- ============================================ -->
        <div class="host-section players-section">
          <h4>üë• Players & Blinds</h4>
          
          <!-- Blind Controls (Top of Players Section) -->
          <div class="blinds-controls-compact">
            <div class="blind-input-row">
              <div class="blind-input-group">
                <label>Small Blind:</label>
                <input type="number" id="hostSmallBlindInput" value="10" min="1" class="form-input compact">
              </div>
              <div class="blind-input-group">
                <label>Big Blind:</label>
                <input type="number" id="hostBigBlindInput" value="20" min="2" class="form-input compact">
              </div>
              <button class="host-control-btn update compact" onclick="updateBlinds()">UPDATE</button>
          </div>
        </div>
        
          <!-- Pending Seat Requests (Shown First if Any) -->
          <div id="pendingSeatRequestsSection" style="display: none;">
            <div class="section-subheader">
              <span>ü™ë Pending Requests <span id="pendingRequestsBadge" class="badge-count" style="display: none;">0</span></span>
            </div>
            <div id="pendingSeatRequests">
              <div class="empty-state">No pending requests</div>
            </div>
          </div>
          
          <!-- Current Players List -->
          <div class="section-subheader">
            <span>Seated Players <span id="hostPlayerCount">0</span></span>
            </div>
          <div id="hostPlayerList">
            <div class="empty-state">No players seated</div>
            </div>
        </div>
        
        <!-- ============================================ -->
        <!-- SECTION 2: GAME CONTROLS (Consolidated) -->
        <!-- ============================================ -->
        <div class="host-section controls-section">
          <h4>‚öôÔ∏è Game Controls</h4>
          
          <!-- All Controls in Compact Grid -->
          <div class="controls-grid-compact">
            <!-- Game Actions -->
            <button class="control-btn-small action" onclick="togglePauseGame()" id="pauseGameBtn" title="Pause Game">
              <span class="btn-icon-small">‚è∏Ô∏è</span>
              <span class="btn-text-small">PAUSE</span>
            </button>
            <button class="control-btn-small action" onclick="forceNextHand()" title="Next Hand">
              <span class="btn-icon-small">‚è≠Ô∏è</span>
              <span class="btn-text-small">NEXT</span>
            </button>
            <button class="control-btn-small action" onclick="toggleRoomLock()" id="lockBtn" title="Lock Room">
              <span class="btn-icon-small">üîí</span>
              <span class="btn-text-small" id="lockBtnText">LOCK</span>
            </button>
            
            <!-- Action Timer -->
            <div class="control-btn-small timer-control">
              <span class="btn-icon-small">‚è±Ô∏è</span>
              <div class="timer-buttons-inline">
                <button class="timer-btn-tiny" onclick="setActionTimer(0)">OFF</button>
                <button class="timer-btn-tiny" onclick="setActionTimer(15)">15s</button>
                <button class="timer-btn-tiny" onclick="setActionTimer(30)">30s</button>
                <button class="timer-btn-tiny" onclick="setActionTimer(60)">60s</button>
            </div>
          </div>
          
          <!-- Auto-Start Toggle -->
            <div class="control-btn-small toggle-control">
              <span class="btn-icon-small">üîÑ</span>
              <span class="btn-text-small">AUTO</span>
              <label class="toggle-switch-tiny">
              <input type="checkbox" id="autoStartToggle" onchange="toggleAutoStart()" checked>
                <span class="toggle-slider-tiny"></span>
            </label>
          </div>
          
          <!-- Spectator Mode Toggle -->
            <div class="control-btn-small toggle-control">
              <span class="btn-icon-small">üëÅÔ∏è</span>
              <span class="btn-text-small">SPECTATE</span>
              <label class="toggle-switch-tiny">
              <input type="checkbox" id="spectatorToggle" onchange="toggleSpectatorMode()" checked>
                <span class="toggle-slider-tiny"></span>
            </label>
        </div>
        
            <!-- Danger Actions (Red) -->
            <button class="control-btn-small danger" onclick="resetAllStacks()" title="Reset All Stacks">
              <span class="btn-icon-small">üîÑ</span>
              <span class="btn-text-small">RESET</span>
            </button>
            <button class="control-btn-small danger" onclick="endGame()" title="End Game">
              <span class="btn-icon-small">üõë</span>
              <span class="btn-text-small">END</span>
            </button>
            </div>
        </div>
        
        </div>
      </div>
    </div>
    
    <!-- ‚öôÔ∏è PLAYER SETTINGS MODAL - LIQUID GLASS STYLED -->
    <div id="playerSettingsModal" class="modal-overlay" style="display: none;" onclick="closeModalOnOverlay(event, 'playerSettingsModal')">
      <div class="modal-content liquid-glass liquid-glass--xl" onclick="event.stopPropagation()">
        <div class="modal-header">
        <h2>‚öôÔ∏è Player Settings</h2>
          <button class="modal-close-btn" onclick="closePlayerSettingsModal()">√ó</button>
      </div>
      
        <div class="modal-body" id="playerSettingsContent">
        <!-- TABLE COLOR -->
        <div class="host-section">
          <h4>üé® Table Color</h4>
          <p class="section-hint">Choose your preferred felt color (saved locally)</p>
          <div class="color-picker-grid">
            <button class="color-btn" data-color="green" onclick="changeFeltColor('green')" title="Classic Green">
              <div class="color-preview" style="background: #197a45;"></div>
              <span>Green</span>
            </button>
            <button class="color-btn" data-color="red" onclick="changeFeltColor('red')" title="Ruby Red">
              <div class="color-preview" style="background: #6b1414;"></div>
              <span>Red</span>
            </button>
            <button class="color-btn" data-color="blue" onclick="changeFeltColor('blue')" title="Ocean Blue">
              <div class="color-preview" style="background: #0f2942;"></div>
              <span>Blue</span>
            </button>
            <button class="color-btn" data-color="black" onclick="changeFeltColor('black')" title="Midnight Black">
              <div class="color-preview" style="background: #1a1a1a;"></div>
              <span>Black</span>
            </button>
            <button class="color-btn" data-color="grey" onclick="changeFeltColor('grey')" title="Steel Grey">
              <div class="color-preview" style="background: #2a2a2a;"></div>
              <span>Grey</span>
            </button>
            <button class="color-btn" data-color="tan" onclick="changeFeltColor('tan')" title="Desert Tan">
              <div class="color-preview" style="background: #6b5642;"></div>
              <span>Tan</span>
            </button>
            <button class="color-btn" data-color="purple" onclick="changeFeltColor('purple')" title="Royal Purple">
              <div class="color-preview" style="background: #3a1450;"></div>
              <span>Purple</span>
            </button>
          </div>
        </div>
        
        <!-- STYLING SETTINGS (Consolidated) -->
        <div class="host-section">
          <h4>üé® Styling Settings</h4>
          
          <div class="settings-compact-grid">
            <!-- 4-Color Deck -->
            <div class="setting-item-compact">
              <div class="setting-label-compact">
                <span>üÉè 4-Color</span>
              </div>
              <label class="toggle-switch-compact">
            <input type="checkbox" id="fourColorDeck" onchange="toggleFourColorDeck(this.checked)">
                <span class="toggle-slider-compact"></span>
          </label>
        </div>
        
            <!-- Card Back Design -->
            <div class="setting-item-compact">
              <div class="setting-label-compact">
                <span>üé¥ Card Back</span>
              </div>
              <select id="cardBackSelect" onchange="changeCardBack(this.value)" class="settings-select-compact">
            <option value="default">Classic</option>
                <option value="modern">Modern</option>
                <option value="minimal">Minimal</option>
                <option value="geometric">Geometric</option>
          </select>
        </div>
        
            <!-- Animation Speed -->
            <div class="setting-item-compact">
              <div class="setting-label-compact">
                <span>‚ö° Speed</span>
              </div>
              <select id="animSpeedSelect" onchange="changeAnimSpeed(this.value)" class="settings-select-compact">
                <option value="fast">Fast</option>
                <option value="normal" selected>Normal</option>
                <option value="slow">Slow</option>
          </select>
        </div>
        
            <!-- Auto-Muck -->
            <div class="setting-item-compact">
              <div class="setting-label-compact">
                <span>üôà Auto-Muck</span>
              </div>
              <label class="toggle-switch-compact">
            <input type="checkbox" id="autoMuck" onchange="toggleAutoMuck(this.checked)">
                <span class="toggle-slider-compact"></span>
          </label>
        </div>
        
            <!-- Chip Display Format -->
            <div class="setting-item-compact">
              <div class="setting-label-compact">
                <span>üí∞ Chips</span>
              </div>
              <select id="chipFormatSelect" onchange="changeChipFormat(this.value)" class="settings-select-compact">
                <option value="full" selected>Full</option>
                <option value="compact">Compact</option>
                <option value="bigblinds">BB</option>
          </select>
        </div>
        
            <!-- Action Confirmation -->
            <div class="setting-item-compact">
              <div class="setting-label-compact">
                <span>‚ö†Ô∏è Confirm</span>
              </div>
              <label class="toggle-switch-compact">
            <input type="checkbox" id="actionConfirm" onchange="toggleActionConfirm(this.checked)">
                <span class="toggle-slider-compact"></span>
          </label>
            </div>
          </div>
        </div>
        
        <!-- ============================================ -->
        <!-- SANDBOX MODE (Testing Only) -->
        <!-- ============================================ -->
        <div class="host-section sandbox-section" id="sandboxSection" style="display: none; border: 2px solid #ff9500; background: rgba(255, 149, 0, 0.05);">
          <h4>üß™ SANDBOX MODE <span style="color: #ff9500; font-size: 0.8rem;">(Testing Only)</span></h4>
          <p class="section-hint" style="color: #ff9500;">Set cards & board before starting hand to test corner cases</p>
          
          <label class="toggle-switch">
            <input type="checkbox" id="sandboxModeToggle" onchange="toggleSandboxMode(this.checked)">
            <span class="toggle-slider"></span>
            <span class="toggle-label">Enable Sandbox Mode</span>
          </label>
          
          <div id="sandboxControls" style="display: none; margin-top: 16px;">
            <!-- Player Cards & Stacks -->
            <div id="sandboxPlayerList">
              <p style="color: #9aa3b2; font-size: 0.85rem;">No players seated. Seat players first.</p>
            </div>
            
            <!-- Board Cards -->
            <div style="margin-top: 16px;">
              <h5 style="font-size: 0.9rem; color: #e9eef7; margin-bottom: 8px;">üÉè Board Cards (Optional)</h5>
              <div style="display: flex; gap: 8px; margin-top: 8px;">
                <input type="text" id="sandboxFlop1" placeholder="Ah" maxlength="2" class="sandbox-card-input" style="width: 50px; padding: 6px; text-align: center; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.2); border-radius: 4px; color: #e9eef7; font-family: 'Courier New', monospace; font-size: 0.9rem;">
                <input type="text" id="sandboxFlop2" placeholder="Kd" maxlength="2" class="sandbox-card-input" style="width: 50px; padding: 6px; text-align: center; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.2); border-radius: 4px; color: #e9eef7; font-family: 'Courier New', monospace; font-size: 0.9rem;">
                <input type="text" id="sandboxFlop3" placeholder="Qs" maxlength="2" class="sandbox-card-input" style="width: 50px; padding: 6px; text-align: center; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.2); border-radius: 4px; color: #e9eef7; font-family: 'Courier New', monospace; font-size: 0.9rem;">
                <input type="text" id="sandboxTurn" placeholder="7c" maxlength="2" class="sandbox-card-input" style="width: 50px; padding: 6px; text-align: center; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.2); border-radius: 4px; color: #e9eef7; font-family: 'Courier New', monospace; font-size: 0.9rem;">
                <input type="text" id="sandboxRiver" placeholder="3s" maxlength="2" class="sandbox-card-input" style="width: 50px; padding: 6px; text-align: center; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.2); border-radius: 4px; color: #e9eef7; font-family: 'Courier New', monospace; font-size: 0.9rem;">
              </div>
              <small style="color: #9aa3b2; display: block; margin-top: 8px; font-size: 0.75rem;">
                Format: Ah, Kd, Qs (rank + suit). Leave blank for random dealing.
              </small>
            </div>
          </div>
        </div>
        
        <!-- HOTKEYS -->
        <div class="host-section">
          <h4>‚å®Ô∏è Keyboard Shortcuts</h4>
          <p class="section-hint">Quick actions with keyboard</p>
          <label class="toggle-switch">
            <input type="checkbox" id="hotkeysEnabled" onchange="toggleHotkeys(this.checked)">
            <span class="toggle-slider"></span>
            <span class="toggle-label">Enable Hotkeys</span>
          </label>
          <div class="hotkey-list" style="margin-top: 12px; font-size: 0.85rem; color: #9aa3b2;">
            <div><kbd>F</kbd> = Fold</div>
            <div><kbd>C</kbd> = Check/Call</div>
            <div><kbd>R</kbd> = Raise</div>
            <div><kbd>Space</kbd> = Confirm Action</div>
          </div>
        </div>
        
      </div>
    </div>
    </div>
    
    <!-- HIDDEN: Old top sections (deprecated - info now on table) -->
    <div style="display: none !important;">
      <div class="my-cards board-fade-target" id="communitySection">
        <div class="cards-display"></div>
        <span id="currentBet">0</span>
        <span id="currentBetDisplay">0</span>
      </div>
      
      <div class="my-cards" id="myCardsSection">
        <span id="turnIndicator"></span>
        <div class="cards-display" id="myCards"></div>
        <div id="handStrength">
          <div id="handStrengthText"></div>
        </div>
      </div>
    </div>
    
    <h2 style="margin-bottom: 15px;">Seats <span id="currentActor" style="font-size: 0.9rem; color: #ff5100; font-weight: normal;"></span></h2>
    
    <!-- üé∞ POKER TABLE (Zoom-Locked) -->
    <div class="table-wrapper" id="tableWrapper">
      <div class="poker-table" id="pokerTable">
        <!-- Oval Felt Background -->
        <div class="table-felt"></div>
        
        <!-- Board Center (Community Cards + Pot + Hand Rank) -->
        <div class="board-center">
          <div class="community-cards-center" id="communityCards"></div>
          
          <div class="pot-display-center">
            <!-- Main Pot Display (Poker Now format: "mainPot total totalPot") -->
            <div class="pot-amount-container">
              <div class="pot-amount" id="mainPotAmount">0</div>
              <!-- Total pot display (only shown when side pots exist) -->
              <div class="pot-total-row" id="potTotalRow" style="display: none;">
                <span class="pot-total-label" id="potTotalLabel">total</span>
                <span class="pot-total-amount" id="totalPotAmount">0</span>
            </div>
            </div>
            
            <!-- Side Pots Container (hidden for now - users find multiple amounts confusing) -->
            <div id="sidePotsContainer" class="side-pots-container" style="display: none; margin-top: 10px;">
              <div class="side-pot-label" style="font-size: 0.7rem; color: var(--muted); margin-bottom: 5px;">SIDE POTS</div>
              <div id="sidePotsList" style="display: flex; flex-direction: column; gap: 5px;"></div>
            </div>
          </div>
        </div>
        
        <!-- Seats Layer -->
        <div class="seats-layer">
          <div class="seats-grid" id="seats"></div>
        </div>
      </div>
    </div>
    
    <!-- HAND RANK DISPLAY (Simple Text Above Action Buttons) -->
    <div id="handRankDisplay" class="hand-rank-display" style="display: none;">
      <div class="hand-rank-text" id="handRankText">Evaluating...</div>
    </div>
    
    <!-- RUNOUT MESSAGE (During All-In Runout) -->
    <div id="runoutMessage" class="runout-message">
      <div class="runout-message-text">Dealing cards...</div>
    </div>
    
    <!-- ACTION BUTTONS - Liquid Glass Tiles (same as dock) -->
    <div id="actionButtons" style="display:none; margin-top: 40px; margin-bottom: 50px; display: flex; justify-content: center; align-items: center; gap: 30px; max-width: 1200px; margin-left: auto; margin-right: auto; padding: 0 40px;">
      <button class="action-btn liquid-glass liquid-glass--md" id="foldBtn">
        <span class="action-btn-text">FOLD</span>
      </button>
      <button class="action-btn liquid-glass liquid-glass--md" id="callBtn">
        <span class="action-btn-text"><span id="callBtnText">CALL</span> $<span id="callAmount">0</span></span>
      </button>
      <button class="action-btn liquid-glass liquid-glass--md" id="raiseBtn">
        <span class="action-btn-text">RAISE</span>
      </button>
    </div>
    
    <!-- RAISE PANEL (Below Buttons) -->
    <div id="raisePanel" class="raise-panel" style="display: none;">
      <!-- Slider + Display Value (Top) -->
      <div class="raise-slider-section">
        <input type="range" id="raiseSlider" class="raise-slider" min="0" max="1000" step="1" />
        <div class="raise-slider-value" id="raiseSliderValue">$0</div>
        <input type="number" id="raiseAmount" class="raise-input" placeholder="Enter amount" />
      </div>
      
      <!-- Preset Buttons (Middle) -->
      <div class="raise-presets">
        <button class="raise-preset-btn" onclick="setRaisePreset('quarter')">1/4 Pot</button>
        <button class="raise-preset-btn" onclick="setRaisePreset('half')">1/2 Pot</button>
        <button class="raise-preset-btn" onclick="setRaisePreset('threequarter')">3/4 Pot</button>
        <button class="raise-preset-btn" onclick="setRaisePreset('pot')">Pot</button>
        <button class="raise-preset-btn" onclick="setRaisePreset('double')">2x Pot</button>
        <button class="raise-preset-btn" onclick="setRaisePreset('allin')">All-In</button>
      </div>
      
      <!-- Pot Info (Bottom) -->
      <div class="raise-info">
        <div class="raise-info-item">
          <span class="raise-info-label">Pot:</span>
          <span class="raise-info-value" id="raiseModalPot">$0</span>
        </div>
        <div class="raise-info-item">
          <span class="raise-info-label">Your Stack:</span>
          <span class="raise-info-value" id="raiseModalStack">$0</span>
        </div>
        <div class="raise-info-item">
          <span class="raise-info-label">Min Raise:</span>
          <span class="raise-info-value" id="raiseModalMin">$0</span>
        </div>
      </div>
      
      <!-- Submit Actions -->
      <div class="raise-actions">
        <button class="btn" style="background: #666; color: #fff; border-color: #666;" onclick="closeRaisePanel()">Cancel</button>
        <button class="btn" id="raiseSubmitBtn" onclick="submitRaise()">Raise</button>
      </div>
    </div>
    
  </div>
  
  <div id="handTransitionOverlay" class="hand-transition-overlay">
    <div class="hand-transition-card">
      <div class="hand-transition-title" id="handTransitionTitle">Next hand starting</div>
      <div class="hand-transition-countdown" id="handTransitionCountdown">3</div>
    </div>
  </div>
  
  <script src="/socket.io/socket.io.js"></script>
  <script>
    // ============================================
    // GLOBAL STATE
    // ============================================
    let roomId = null;
    let userId = null;
    let gameId = null;
    let socket = null;
    let allInDontAskAgain = false; // Track "don't ask again" preference for current game session
    let pendingAllInAction = null; // Store pending ALL_IN action callback
    let showdownActions = {}; // Track who showed vs mucked: { userId: 'SHOW' | 'MUCK' }
    let isHost = false; // Track if current user is host
    let isClaimingSeat = false; // Prevent duplicate seat claims
    let currentGameState = null; // Track current game state for UI logic
    let myHoleCards = null; // Track user's hole cards to show on their seat tile
    let isSpectator = false; // Track if user is a spectator (not seated, game active)
    let mySeatIndex = null; // Track which seat the user is in (null if spectator)
    let autoStartTimer = null;
    let autoStartCountdownInterval = null;
    
    function showOverlayCountdown(seconds, title = 'Next hand starting') {
    const overlay = document.getElementById('handTransitionOverlay');
    if (overlay) {
      overlay.style.display = 'none';
      overlay.style.opacity = '0';
    }
    const bar = document.getElementById('handTimerBar');
    const fill = document.getElementById('handTimerFill');
    const titleEl = document.getElementById('gameStateText');
    if (!bar || !fill || !titleEl) return;
    titleEl.textContent = title;
    bar.style.display = 'block';
    fill.style.transition = 'none';
    fill.style.transform = 'scaleX(1)';
    requestAnimationFrame(() => {
      fill.style.transition = 'transform ' + seconds + 's linear';
      fill.style.transform = 'scaleX(0)';
    });
    }
    
    function updateOverlayCountdown(seconds) {
    // No-op since we transitioned to bar
    }
    
    function hideOverlayCountdown() {
      const overlay = document.getElementById('handTransitionOverlay');
    if (overlay) {
      overlay.style.opacity = '0';
      overlay.style.display = 'none';
    }
    const bar = document.getElementById('handTimerBar');
    const fill = document.getElementById('handTimerFill');
    if (bar && fill) {
      bar.style.display = 'none';
      fill.style.transition = 'none';
      fill.style.transform = 'scaleX(1)';
    }
    }
    
    function fadeBoardToNewState(callback) {
      const section = document.getElementById('communitySection');
      if (!section) {
        callback();
        return;
      }
      section.classList.add('board-fade-out');
      setTimeout(() => {
        callback();
        section.classList.remove('board-fade-out');
        section.classList.add('board-fade-in');
        setTimeout(() => {
          section.classList.remove('board-fade-in');
        }, 220);
      }, 200);
    }
    
    // ============================================
    // NAVIGATION PROTECTION
    // ============================================
    // Warn user before leaving active game
    window.addEventListener('beforeunload', (e) => {
      if (gameId && currentGameState && currentGameState.status !== 'waiting') {
        e.preventDefault();
        e.returnValue = 'You are in an active game. Are you sure you want to leave?';
        return e.returnValue;
      }
    });
    
    // Intercept navbar link clicks to confirm navigation
    document.addEventListener('DOMContentLoaded', () => {
      setTimeout(() => {
        const navLinks = document.querySelectorAll('.navbar-links a, .navbar-brand');
        navLinks.forEach(link => {
          link.addEventListener('click', (e) => {
            if (gameId && currentGameState && currentGameState.status !== 'waiting') {
              const confirmed = confirm('You are in an active game. Are you sure you want to leave?');
              if (!confirmed) {
                e.preventDefault();
              }
            }
          });
        });
      }, 100); // Small delay to ensure navbar is rendered
    });
    
    // ============================================
    // UTILITY: DEBUG LOGGING
    // ============================================
    function debug(message, data = null) {
      // Debug disabled for clean production UI
      // console.log(message, data);
    }
    
    // ============================================
    // UTILITY: UPDATE DOCK GAME STATE
    // ============================================
    function updateDockGameState(text) {
      const gameStateEl = document.getElementById('gameStateText');
      if (gameStateEl) {
        gameStateEl.textContent = text;
        debug('üéØ Dock state updated:', text);
      }
    }
    
    // ============================================
    // UTILITY: CARD IMAGE PATH CONVERTER
    // ============================================
    function getCardImagePath(card) {
      // Convert "Ah" ‚Üí "hearts_A.png", "Ks" ‚Üí "spades_K.png", "Td" ‚Üí "diamonds_10.png"
      if (!card || card.length < 2) return '/cards/back.png';
      
      const rank = card.slice(0, -1); // "A", "K", "T", "2", etc.
      const suitChar = card.slice(-1); // "h", "s", "d", "c"
      
      const suitMap = {
        'h': 'hearts',
        's': 'spades',
        'd': 'diamonds',
        'c': 'clubs'
      };
      
      const rankMap = {
        'T': '10'
      };
      
      const suit = suitMap[suitChar] || 'hearts';
      const finalRank = rankMap[rank] || rank;
      
      return `/cards/${suit}_${finalRank}.png`;
    }
    
    // ============================================
    // STEP 1: INITIALIZE
    // ============================================
    function init() {
      debug('üé¨ Initializing minimal table...');
      
      // Initialize dock state
      updateDockGameState('Waiting to start');
      
      // Initialize falling cards animation (EXACT same as play page)
      if (typeof initOngoingOnly === 'function') {
        initOngoingOnly();
      }
      
      // Get room ID from URL
      const urlParams = new URLSearchParams(window.location.search);
      roomId = urlParams.get('room');
      
      // PRIORITY 1: Check if user is authenticated via Supabase
      let isAuthenticated = false;
      
      try {
        // Check localStorage for Supabase session (standard location)
        const supabaseAuth = localStorage.getItem('sb-ztqcpuktihltfepnexcx-auth-token');
        if (supabaseAuth) {
          const authData = JSON.parse(supabaseAuth);
          if (authData && authData.user && authData.user.id) {
            userId = authData.user.id;
            isAuthenticated = true;
            sessionStorage.setItem('userId', userId);
            sessionStorage.setItem('userEmail', authData.user.email || 'Unknown');
            debug('‚úÖ Authenticated user detected:', { userId, email: authData.user.email });
          }
        }
      } catch (e) {
        debug('‚ö†Ô∏è Could not read Supabase auth:', e.message);
      }
      
      // PRIORITY 2: Try window.currentUser (if available)
      if (!userId && window.currentUser && window.currentUser.id) {
        userId = window.currentUser.id;
        isAuthenticated = true;
        sessionStorage.setItem('userId', userId);
        debug('‚úÖ Found window.currentUser:', userId);
      }
      
      // PRIORITY 3: Check sessionStorage
      if (!userId) {
        userId = sessionStorage.getItem('userId');
        
        // Validate UUID format (check if it's actually a UUID)
        const isValidUUID = userId && /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(userId);
        
        if (!isValidUUID) {
          // Clear invalid ID
          if (userId) {
            debug('‚ö†Ô∏è Invalid UUID detected, clearing:', userId);
            sessionStorage.removeItem('userId');
            userId = null;
          }
        }
      }
      
      // LAST RESORT: Generate guest UUID
      if (!userId) {
        userId = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
          const r = Math.random() * 16 | 0;
          const v = c === 'x' ? r : (r & 0x3 | 0x8);
          return v.toString(16);
        });
        sessionStorage.setItem('userId', userId);
        sessionStorage.setItem('isGuest', 'true');
        debug('‚ö†Ô∏è No auth found, generated guest UUID:', userId);
      }
      
      // Validate
      if (!roomId) {
        alert('‚ùå No room ID in URL. Redirecting to lobby...');
        window.location.href = '/play';
        return;
      }
      
      debug('‚úÖ Initialized', { roomId, userId, isAuthenticated });
      
      // Initialize host controls settings from localStorage
      initializeHostSettings();
      
      // Connect WebSocket
      connectWebSocket();
      
      // CRITICAL: Hydrate game state before loading room
      hydrateGameState();
    }
    
    // Initialize host settings from localStorage
    function initializeHostSettings() {
      // Restore action timer
      const savedTimer = localStorage.getItem('pokergeek_action_timer');
      if (savedTimer) {
        actionTimerSeconds = parseInt(savedTimer);
        const display = document.getElementById('actionTimerDisplay');
        if (display) {
          display.textContent = actionTimerSeconds === 0 ? 'OFF' : `${actionTimerSeconds}s`;
          // Mark active button (old, compact, and tiny buttons)
          document.querySelectorAll('.timer-btn, .timer-btn-compact, .timer-btn-tiny').forEach(btn => {
            const btnValue = btn.textContent.trim();
            if ((actionTimerSeconds === 0 && btnValue === 'OFF') ||
                (btnValue === `${actionTimerSeconds}s`)) {
              btn.classList.add('active');
            }
          });
        }
      }
      
      // Restore auto-start setting
      const autoStart = localStorage.getItem('pokergeek_auto_start');
      if (autoStart === 'false') {
        const checkbox = document.getElementById('autoStartToggle');
        if (checkbox) checkbox.checked = false;
      }
      
      // Restore spectator mode setting
      const spectatorMode = localStorage.getItem('pokergeek_spectator_mode');
      if (spectatorMode === 'false') {
        const checkbox = document.getElementById('spectatorToggle');
        if (checkbox) checkbox.checked = false;
      }
      
      // Expand both panels by default
      setTimeout(() => {
        const hostContent = document.getElementById('hostControlsContent');
        const playerContent = document.getElementById('playerSettingsContent');
        if (hostContent) hostContent.classList.add('expanded');
        if (playerContent) playerContent.classList.add('expanded');
      }, 100);
      
      debug('‚öôÔ∏è Host settings initialized from localStorage');
    }
    
    // ============================================
    // CRITICAL: HYDRATE GAME STATE ON REFRESH
    // ============================================
    async function hydrateGameState() {
      debug('üíß Hydrating game state...');
      
      try {
        const response = await fetch(`/api/engine/hydrate/${roomId}/${userId}`);
        
        if (!response.ok) {
          debug('‚ö†Ô∏è Hydration failed, loading lobby state');
          await loadRoom(); // Ensure room code loads even if hydration fails
          return;
        }
        
        const data = await response.json();
        
        if (!data.hasActiveGame) {
          debug('‚è∏Ô∏è  No active game - loading lobby');
          await loadRoom(); // Ensure room code loads
          return;
        }
        
        // ACTIVE GAME FOUND - RESTORE STATE
        debug('üéÆ ACTIVE GAME FOUND - RESTORING STATE', {
          handNumber: data.gameState.handNumber,
          street: data.gameState.street,
          pot: data.gameState.pot,
          isSpectator: data.isSpectator,
          inCurrentHand: data.inCurrentHand
        });
        
        // ARCHITECTURAL FIX: Use backend spectator detection
        // Backend knows if user is in gameState.players[] (inCurrentHand)
        // If not in current hand during active game = spectator
        isSpectator = data.isSpectator || false;
        
        gameId = data.gameId;
        currentGameState = data.gameState; // Store for UI logic
        
        // Recalculate seat positions (dynamic positioning based on player count)
        setTimeout(() => applySeatPositions(), 100);
        
        // Show community section
        document.getElementById('communitySection').style.display = 'block';
        
        // Render community cards
        if (data.gameState.communityCards && data.gameState.communityCards.length > 0) {
          renderCommunityCards(data.gameState.communityCards);
        }
        
        // Update pot and bet (with side pots support)
        updatePotDisplay(data.gameState);
        document.getElementById('currentBet').textContent = data.gameState.currentBet || 0;
        
        // Update bet indicators from hydrated state
        updateBetIndicators(data.gameState);
        
        // Show current actor
        const actorText = document.getElementById('currentActor');
        if (data.gameState.currentActorSeat !== undefined) {
          actorText.textContent = `(Seat ${data.gameState.currentActorSeat + 1}'s turn)`;
          actorText.style.display = 'inline';
          // Update dock center with current turn
          updateDockGameState(`Seat ${data.gameState.currentActorSeat + 1}'s turn`);
        }
        
        // Render my hole cards
        if (data.myHoleCards && data.myHoleCards.length === 2) {
          myHoleCards = data.myHoleCards; // Store globally
          renderMyCards(data.myHoleCards);
        }
        
        // ARCHITECTURAL FIX: Update hand rank display after hydration
        updateHandRankDisplay(data.gameState, myHoleCards);
        
        // Show/hide action buttons based on turn
        const actionButtons = document.getElementById('actionButtons');
        // Only show action buttons if game is active AND user is not a spectator
        if (data.isMyTurn && data.gameState.status === 'IN_PROGRESS' && !isSpectator) {
          actionButtons.style.display = 'flex';
          updateActionButtons(data.gameState);
        } else {
          actionButtons.style.display = 'none';
        }
        
        // Hide START button (game is active)
        document.getElementById('startBtn').style.display = 'none';
        
        // Update seat card backings (pass myHoleCards to show on my seat)
        updateSeatCardBackings(data.gameState, myHoleCards);
        
        // Update position badges (dealer, SB, BB)
        updatePositionBadges(data.gameState);
        
        debug('‚úÖ Game state restored successfully');
        
        // Still load room to get seat info
        loadRoom();
        
      } catch (error) {
        debug('‚ùå Hydration error', { error: error.message });
        console.error('Hydration error:', error);
        await loadRoom(); // Fallback to normal flow - ensure room code loads
      }
    }
    
    // ============================================
    // STEP 2: WEBSOCKET CONNECTION
    // ============================================
    function connectWebSocket() {
      debug('üîå Connecting WebSocket...');
      
      socket = io();
      
      socket.on('connect', () => {
        debug('‚úÖ Socket connected', { socketId: socket.id });
        document.getElementById('socketStatus').classList.add('connected');
        
        // Join room
        socket.emit('join_room', { roomId, userId });
        debug('üì° Sent join_room event', { roomId, userId });
      });
      
      socket.on('disconnect', (reason) => {
        debug('üî¥ Socket disconnected', { reason });
        document.getElementById('socketStatus').classList.remove('connected');
      });
      
      socket.on('seat_update', (data) => {
        debug('ü™ë Seat update received', data);
        loadRoom();
        if (isHost) {
          refreshHostControls(); // Refresh player list when seats change
        }
      });
      
      socket.on('hand_complete', (data) => {
        debug('üèÜ Hand complete event received', data);
        
        if (data.gameState) {
          handleHandComplete(data.gameState);
        }
      });
      
      // Listen for seat request resolved (player approved)
      socket.on('seat_request_resolved', (data) => {
        if (data.status === 'APPROVED' && data.userId !== userId) {
          // Someone else got approved - show elegant corner notification
          const username = data.username || 'Player';
          showCornerNotification(`${username} joining next hand`, 'info');
        }
      });
      
      socket.on('hand_started', (data) => {
        debug('üÉè Hand started event', data);
        hideOverlayCountdown();
        
        fadeBoardToNewState(() => {
          const communityCardsEl = document.getElementById('communityCards');
          const myCardsEl = document.getElementById('myCards');
          if (communityCardsEl) communityCardsEl.innerHTML = '';
          if (myCardsEl) myCardsEl.innerHTML = '';
        document.getElementById('actionButtons').style.display = 'none';
        document.getElementById('myCardsSection').style.display = 'none';
        document.getElementById('startBtn').style.display = 'none';
        
        isAllInRunout = false;
        previousCommunityCards = [];
        showdownActions = {};
        previousStreet = null;
        previousPlayerChips.clear();
        previousPlayerBets.clear();
        currentPotValue = 0;
        clearBetIndicators();
        
        if (data.gameStateId) {
          gameId = data.gameStateId;
        }
        
        if (data.gameState) {
          const gs = data.gameState;
            currentGameState = gs;
          setTimeout(() => applySeatPositions(), 100);
            const communitySection = document.getElementById('communitySection');
            if (communitySection) communitySection.style.display = 'block';
          
          // CRITICAL FIX: Ensure pot display structure is intact before updating
          const potDisplayEl = document.querySelector('.pot-display-center');
          const mainPotEl = document.getElementById('mainPotAmount');
          if (potDisplayEl && !mainPotEl) {
            // Structure was destroyed - restore it
            potDisplayEl.innerHTML = `
              <div class="pot-amount-container">
                <div class="pot-amount" id="mainPotAmount">0</div>
                <div class="pot-total-row" id="potTotalRow" style="display: none;">
                  <span class="pot-total-label" id="potTotalLabel">total</span>
                  <span class="pot-total-amount" id="totalPotAmount">0</span>
                </div>
              </div>
              <div id="sidePotsContainer" class="side-pots-container" style="display: none; margin-top: 10px;">
                <div class="side-pot-label" style="font-size: 0.7rem; color: var(--muted); margin-bottom: 5px;">SIDE POTS</div>
                <div id="sidePotsList" style="display: flex; flex-direction: column; gap: 5px;"></div>
              </div>
            `;
          }
          
          updatePotDisplay(gs);
          document.getElementById('currentBet').textContent = gs.currentBet || 0;
          
          const actorText = document.getElementById('currentActor');
          if (gs.currentActorSeat !== undefined) {
            actorText.textContent = `(Seat ${gs.currentActorSeat + 1}'s turn)`;
            actorText.style.display = 'inline';
            updateDockGameState(`Seat ${gs.currentActorSeat + 1}'s turn`);
          }
          
          debug('‚úÖ Game state updated', { pot: gs.pot, currentBet: gs.currentBet, street: gs.street });
          updateSeatCardBackings(gs, myHoleCards);
          updatePositionBadges(gs);
        }
        
        fetchMyCards();
        setTimeout(loadRoom, 500);
        });
      });
      
      // Listen for progressive street reveals (all-in runout)
      socket.on('street_reveal', (data) => {
        debug('üÉè Street reveal event', data);
        
        // ARCHITECTURAL FIX: Hide action buttons during runout (players can't act)
        const actionButtons = document.getElementById('actionButtons');
        if (actionButtons) {
          actionButtons.style.display = 'none';
        }
        
        // Hide hand rank display during runout
        const handRankDisplay = document.getElementById('handRankDisplay');
        if (handRankDisplay) {
          handRankDisplay.style.display = 'none';
        }
        
        // Show runout message
        const runoutMessage = document.getElementById('runoutMessage');
        if (runoutMessage) {
          const runoutText = runoutMessage.querySelector('.runout-message-text');
          if (runoutText) {
            runoutText.textContent = `Dealing ${data.street}...`;
          }
          runoutMessage.classList.add('show');
        }
        
        if (data.communityCards && data.communityCards.length > 0) {
          // Render cards with animation (all-in runout)
          renderCommunityCards(data.communityCards);
        }
      });
      
      // Listen for action processed events
      socket.on('action_processed', (data) => {
        debug('üéÆ Action processed', data);
        
        // Update game state display
        if (data.gameState) {
          const gs = data.gameState;
          
          // GOLDEN PATH: Skip all updates if hand is complete
          // hand_complete event will handle everything
          if (gs.status === 'COMPLETED') {
            debug('‚è∏Ô∏è Hand complete - skipping action_processed, waiting for hand_complete event');
            return; // Don't process - wait for hand_complete event
          }
          
          currentGameState = gs; // Store for UI logic
          
          // Recalculate seat positions (dynamic positioning based on player count)
          setTimeout(() => applySeatPositions(), 100);
          
          // ARCHITECTURAL FIX: Update pot display FIRST (shows money movement)
          // Check if pot increased (betting action occurred)
          const oldPot = currentPotValue;
          const newPot = gs.mainPot !== undefined ? gs.mainPot : (gs.pot || 0);
          if (newPot > oldPot) {
            // Trigger bet pulse animation (ALWAYS GREEN on increment)
            triggerBetPulse();
          }
          
          updatePotDisplay(gs);
          document.getElementById('currentBet').textContent = gs.currentBet || 0;
          
          // ARCHITECTURAL FIX: Update chips SECOND (shows money leaving stacks)
          // This creates the visual effect of money moving from stack to pot
          updateSeatChips(gs.players);
          
          // Update bet indicators from game state (shows betThisStreet for all players)
          // This ensures indicators persist and update throughout the betting round
          updateBetIndicators(gs);
          
          // Show bet amount indicator when action occurs (with pulse animation)
          if (data.action && data.amount !== undefined && data.amount > 0) {
            // Find which player made this action
            const actionPlayer = gs.players?.find(p => p.userId === data.userId);
            if (actionPlayer && (data.action === 'BET' || data.action === 'RAISE' || data.action === 'CALL' || data.action === 'ALL_IN')) {
              // Use betThisStreet as the display amount (what they've bet this street)
              const betAmount = actionPlayer.betThisStreet || 0;
              
              if (betAmount > 0) {
                // Pulse animation for new/updated bet
                showBetAmount(actionPlayer.seatIndex, data.action, betAmount);
              }
            } else if (actionPlayer && data.action === 'FOLD') {
              // Hide indicator when player folds
              const seat = document.querySelector(`.seat[data-seat-index="${actionPlayer.seatIndex}"]`);
              if (seat) {
                const betIndicator = seat.querySelector('.seat-bet-indicator');
                if (betIndicator) {
                  betIndicator.style.display = 'none';
                  betIndicator.classList.remove('show');
                }
              }
            }
          }
          
          // Update previous bet tracking for all players (for next action)
          if (gs.players) {
            gs.players.forEach(p => {
              previousPlayerBets.set(p.seatIndex, p.betThisStreet || 0);
            });
          }
          
          // Update current actor
          const actorText = document.getElementById('currentActor');
          if (gs.currentActorSeat !== undefined) {
            actorText.textContent = `(Seat ${gs.currentActorSeat + 1}'s turn)`;
            // Update dock center with current turn
            updateDockGameState(`Seat ${gs.currentActorSeat + 1}'s turn`);
          }
          
          // Show community cards if any (but skip if this is an all-in runout - handled by street_reveal)
          if (gs.communityCards && gs.communityCards.length > 0 && !gs.needsProgressiveReveal) {
            renderCommunityCards(gs.communityCards);
          }
          
          // ARCHITECTURAL FIX: Update hand rank display whenever game state changes
          updateHandRankDisplay(gs, myHoleCards);
          
          // ARCHITECTURAL FIX: Hide buttons during all-in runout (needsProgressiveReveal)
          const actionButtons = document.getElementById('actionButtons');
          const runoutMessage = document.getElementById('runoutMessage');
          
          if (gs.needsProgressiveReveal) {
            // All-in runout in progress - hide buttons, show message
            if (actionButtons) actionButtons.style.display = 'none';
            if (runoutMessage) runoutMessage.classList.add('show');
          } else {
            // Normal play - hide runout message, show buttons if needed
            if (runoutMessage) runoutMessage.classList.remove('show');
          
          if (gs.status === 'IN_PROGRESS') {
            updateActionButtons(gs); // This will show/hide buttons based on canAct
          } else {
            if (actionButtons) actionButtons.style.display = 'none';
            }
          }
          
          // Update seat card backings (show folds, etc) (pass myHoleCards to show on my seat)
          updateSeatCardBackings(gs, myHoleCards);
          
          // Update position badges (dealer, SB, BB)
          updatePositionBadges(gs);
          
          // Store updated gameState for renderSeats to use
          currentGameState = gs;
          
          // Recalculate seat positions (dynamic positioning based on player count)
          setTimeout(() => applySeatPositions(), 100);
        }
      });
      
      // Listen for showdown actions (show/muck)
      socket.on('showdown_action', (data) => {
        debug('üÉè Showdown action received:', data);
        
        const { action, userId: actionUserId, seatIndex, nickname, holeCards } = data;
        
        // Track showdown action
        if (actionUserId) {
          showdownActions[actionUserId] = action;
        }
        
        if (action === 'SHOW' && holeCards) {
          // REPLACE card backs with actual card images
          const cardBacksContainer = document.querySelector(`.seat-cards[data-seat-index="${seatIndex}"]`);
          if (cardBacksContainer) {
            cardBacksContainer.innerHTML = ''; // Clear card backs
            
            // Display actual cards using images
            holeCards.forEach(card => {
              const cardImg = document.createElement('img');
              cardImg.className = 'seat-card-front';
              cardImg.src = getCardImagePath(card);
              cardImg.alt = card;
              cardImg.onerror = function() {
                // Fallback if image doesn't exist
                this.src = '/cards/back.png';
              };
              cardBacksContainer.appendChild(cardImg);
            });
            
            debug(`‚úÖ @${nickname} showed cards: ${holeCards.join(' ')}`);
          }
          
        } else if (action === 'MUCK') {
          // Grey out card backs (already folded styling)
          const cardBacksContainer = document.querySelector(`.seat-cards[data-seat-index="${seatIndex}"]`);
          if (cardBacksContainer) {
            const cardBacks = cardBacksContainer.querySelectorAll('.seat-card-back');
            cardBacks.forEach(back => {
              back.classList.add('folded'); // Grey them out
            });
            
            debug(`‚úÖ @${nickname} mucked cards`);
          }
          
        }
      });
      
      // NOTE: Private hole cards are sent via HTTP response in startHand()
      // We'll add WebSocket private emit in Phase 2b
      
      socket.on('game_started', (data) => {
        debug('üéÆ Game started event', data);
        if (data.gameId) {
          gameId = data.gameId;
        }
        setTimeout(loadRoom, 1000);
      });
      
      // Host control events
      socket.on('blinds_updated', (data) => {
        debug('üí∞ Blinds updated immediately', data);
      });
      
      socket.on('blinds_queued', (data) => {
        debug('‚è≥ Blinds queued for next hand', data);
        // Show non-blocking notification to all players
      });
      
      socket.on('chips_adjusted', (data) => {
        debug('üíµ Chips adjusted by host', data);
        loadRoom(); // Refresh to show new chip amounts
        if (isHost) loadHostControls(); // Update host dropdown
      });
      
      socket.on('chips_queued', (data) => {
        debug('‚è≥ Chips queued for next hand', data);
        if (isHost) {
          showToast('‚è≥ Chips will update at end of hand', 'info');
        }
        if (isHost) loadHostControls(); // Update host dropdown to show new values
      });
      
      socket.on('player_kicked', (data) => {
        if (data.userId === userId) {
          alert('‚ùå You have been removed from the game by the host.');
          window.location.href = '/';
        }
      });
      
      // Seat request events
      socket.on('seat_request_pending', (data) => {
        debug('ü™ë Seat request pending (broadcast):', data);
        
        // ARCHITECTURAL FIX: Track ALL pending requests (not just mine)
        // This prevents duplicate requests - players see when a seat is requested
        allPendingRequests.set(data.seatIndex, {
          requestId: data.requestId,
          userId: data.userId,
          username: data.username || data.nickname,
          requestedChips: data.requestedChips
        });
        
        // If this is MY request, also track it in myPendingRequests
        if (data.userId === userId) {
          myPendingRequests.set(data.seatIndex, data.requestId);
          showNotification(`Seat request sent for seat ${data.seatIndex + 1}. Waiting for host approval...`, 'info');
        } else {
          // Someone else requested this seat - show visual feedback
          debug(`‚ö†Ô∏è Seat ${data.seatIndex + 1} requested by ${data.username || data.userId?.substr(0, 8)}`);
          // Update seat display to show it's requested
          updateSeatRequestStatus(data.seatIndex, true, data.username || data.userId?.substr(0, 8));
        }
        
        if (isHost) {
          // Show notification instead of popup
          showNotification(`ü™ë @${data.username} requested Seat ${data.seatIndex + 1} ($${data.requestedChips.toLocaleString()})`, 'info');
          loadPendingSeatRequests(); // Refresh list in host controls
        }
        
        // Refresh seats to show updated state
        loadRoom();
      });
      
      socket.on('seat_request_resolved', (data) => {
        debug('‚úÖ Seat request resolved:', data);
        // ARCHITECTURAL FIX: Clear from both maps
        if (data.seatIndex !== undefined) {
          myPendingRequests.delete(data.seatIndex);
          allPendingRequests.delete(data.seatIndex);
          // Update seat display to remove requested status
          updateSeatRequestStatus(data.seatIndex, false);
        }
        if (isHost) {
          loadPendingSeatRequests(); // Refresh list
          refreshHostControls(); // Refresh player list
        }
        loadRoom(); // Refresh seats to update pending status
      });
      
      socket.on('seat_request_approved', (data) => {
        debug('‚úÖ Seat request approved:', data);
        // ARCHITECTURAL FIX: Clear from both maps
        if (data.seatIndex !== undefined) {
          myPendingRequests.delete(data.seatIndex);
          allPendingRequests.delete(data.seatIndex);
          updateSeatRequestStatus(data.seatIndex, false);
        }
        showNotification('Your seat request was approved!', 'success');
        setTimeout(() => loadRoom(), 1000); // Reload to show seat
      });
      
      socket.on('seat_request_rejected', (data) => {
        debug('‚ùå Seat request rejected:', data);
        // ARCHITECTURAL FIX: Clear from both maps
        if (data.seatIndex !== undefined) {
          myPendingRequests.delete(data.seatIndex);
          allPendingRequests.delete(data.seatIndex);
          updateSeatRequestStatus(data.seatIndex, false);
        }
        showNotification('Your seat request was rejected by the host', 'error');
        loadRoom(); // Refresh to remove pending status
      });
      
      socket.on('seat_request_sent', (data) => {
        debug('üì§ Seat request sent:', data);
        // ARCHITECTURAL FIX: Track my pending request (already tracked in seat_request_pending, but keep for backwards compatibility)
        if (data.seatIndex !== undefined && data.requestId) {
          myPendingRequests.set(data.seatIndex, data.requestId);
          allPendingRequests.set(data.seatIndex, {
            requestId: data.requestId,
            userId: userId,
            username: 'You',
            requestedChips: data.requestedChips || 1000
          });
        }
      });
      
      socket.on('you_busted', (data) => {
        debug('üíÄ You busted:', data);
        isSpectator = true; // Mark as spectator
        mySeatIndex = null; // Clear seat index
        
        // Show appropriate message based on host status
        const message = data.message || (data.isHost 
          ? 'You busted! Click any empty seat to rejoin automatically (host privilege).'
          : 'You busted! Click any empty seat to request rejoining the game.');
        
        showNotification(message, data.isHost ? 'warning' : 'info');
        loadRoom(); // Refresh seats to show spectator status and enable seat claiming
        // Hide action buttons for spectators
        const actionButtons = document.getElementById('actionButtons');
        if (actionButtons) {
          actionButtons.style.display = 'none';
        }
      });
      
      socket.on('player_busted', (data) => {
        debug('üíÄ Player busted:', data);
        if (isHost) {
          showNotification(`Player busted and is now a spectator (seat ${data.seatIndex + 1})`, 'info');
        }
        loadRoom(); // Refresh seats
      });
      
      socket.on('game_ended', (data) => {
        debug('üèÜ Game ended:', data);
        showNotification(data.message || 'Game ended', 'info');
        
        // Clear any active game state
        currentGameState = null;
        myHoleCards = null;
        gameId = null; // CRITICAL: Clear gameId so START button shows
        
        // Clear action buttons
        document.getElementById('actionButtons').style.display = 'none';
        
        // Hide runout message
        const runoutMessage = document.getElementById('runoutMessage');
        if (runoutMessage) {
          runoutMessage.classList.remove('show');
        }
        
        // Clear community cards display
        const communityCardsDiv = document.getElementById('communityCards');
        if (communityCardsDiv) {
          communityCardsDiv.innerHTML = '';
        }
        
        // Clear pot display
        const potDiv = document.getElementById('pot');
        if (potDiv) {
          potDiv.textContent = '0';
        }
        
        // ARCHITECTURAL FIX: Don't auto-start a new hand after game ends
        // Just reload room to show lobby state - let host manually start next game
        setTimeout(() => {
          loadRoom();
        }, 1500);
      });
      
      // ARCHITECTURAL FIX: Handle hand complete lobby event (hand complete, room back in lobby)
      socket.on('hand_complete_lobby', (data) => {
        debug('üèÅ Hand complete - back in lobby:', data);
        
        // Clear any pending countdowns
        if (autoStartCountdownInterval) {
          clearInterval(autoStartCountdownInterval);
          autoStartCountdownInterval = null;
        }
        if (autoStartTimer) {
          clearTimeout(autoStartTimer);
          autoStartTimer = null;
        }
        
        const autoStartIn = data.autoStartIn || 0;
        const requiresManualStart = data.requiresManualStart || false;
        const allowShowdownWindow = data.showdownWindow || 2000;
        
        setTimeout(() => {
        currentGameState = null;
          gameId = null;
        document.getElementById('actionButtons').style.display = 'none';
        const runoutMessage = document.getElementById('runoutMessage');
        if (runoutMessage) {
          runoutMessage.classList.remove('show');
        }
        }, allowShowdownWindow);
        
        const startBtn = document.getElementById('startBtn');
        if (startBtn) {
          if (autoStartIn > 0) {
            startBtn.style.display = 'none';
          } else if (requiresManualStart && isHost) {
          startBtn.style.display = 'inline-block';
          } else {
            startBtn.style.display = 'none';
          }
        }
        
        if (autoStartIn > 0) {
          let secondsRemaining = Math.ceil(autoStartIn / 1000);
          showNotification(data.message || `Hand complete. Next hand starting in ${secondsRemaining}s...`, 'info');
          
          showOverlayCountdown(secondsRemaining);
          
          updateDockGameState(`Next hand in ${secondsRemaining}s`);
          autoStartCountdownInterval = setInterval(() => {
            secondsRemaining -= 1;
            if (secondsRemaining > 0) {
              updateDockGameState(`Next hand in ${secondsRemaining}s`);
              updateOverlayCountdown(secondsRemaining);
            } else {
              clearInterval(autoStartCountdownInterval);
              autoStartCountdownInterval = null;
              hideOverlayCountdown();
            }
          }, 1000);
          
        autoStartTimer = setTimeout(() => {
          updateDockGameState('Starting next hand...');
          hydrateGameState();
        }, autoStartIn + allowShowdownWindow + 750);
          
        } else {
          showNotification(data.message || 'Hand complete. Host can start the next hand.', 'info');
          hideOverlayCountdown();
        }
        
        // Refresh seats/host controls after short delay
        setTimeout(() => {
          loadRoom();
          if (isHost) {
            refreshHostControls();
          }
        }, autoStartIn > 0 ? 500 : 1000);
      });
    }
    
    // ============================================
    // STEP 3: LOAD ROOM STATE
    // ============================================
    async function loadRoom() {
      debug('üåä Fetching room state...');
      
      try {
        // Get room info
        const roomResponse = await fetch(`/api/engine/room/${roomId}`);
        if (!roomResponse.ok) {
          throw new Error(`Failed to get room: ${roomResponse.status}`);
        }
        const roomData = await roomResponse.json();
        // Store room data globally for chip formatting (big blinds conversion)
        window.currentRoomData = roomData;
        debug('‚úÖ Room data received', roomData);
        
        // Get seats
        const seatsResponse = await fetch(`/api/engine/seats/${roomId}`);
        if (!seatsResponse.ok) {
          throw new Error(`Failed to get seats: ${seatsResponse.status}`);
        }
        const seatsData = await seatsResponse.json();
        debug('‚úÖ Seats data received', seatsData);
        
        // Update room name (top tile)
        const roomNameEl = document.getElementById('roomNameDisplay');
        if (roomNameEl) {
          const roomName = roomData.room?.name || 'Poker Room';
          roomNameEl.textContent = roomName;
          debug('‚úÖ Room name updated:', roomName);
        }
        
        // Update room code (dock)
        const roomCodeEl = document.getElementById('roomCode');
        if (roomCodeEl) {
          roomCodeEl.textContent = roomData.room?.code || roomData.room?.invite_code || '---';
          debug('‚úÖ Room code updated:', roomData.room?.code || roomData.room?.invite_code);
        } else {
          debug('‚ö†Ô∏è Room code element not found');
        }
        
        // Store game ID if exists (clear if null)
        if (roomData.room?.gameId) {
          gameId = roomData.room.gameId;
        } else {
          gameId = null; // CRITICAL: Clear gameId when no active game
        }
        
        // CRITICAL: During active game, renderSeats will use currentGameState chips (real-time)
        // Only render seats (chips will be updated from gameState if active)
        renderSeats(seatsData.seats, roomData.room);
        
        // If game is active, immediately update chips from currentGameState (if available)
        // This ensures chips are correct even if loadRoom() was called
        if (currentGameState && currentGameState.status === 'IN_PROGRESS' && currentGameState.players) {
          updateSeatChips(currentGameState.players);
        }
        
        // ARCHITECTURAL FIX: Determine player state
        // THREE STATES:
        // 1. LOBBY: Pre-game, everyone sees all 10 seats (hardcoded positions)
        // 2. ACTIVE PLAYER: In gameState.players[], sees only occupied seats (dynamic positions)
        // 3. SPECTATOR: Game active but not in gameState.players[] (sees all 10 seats, hardcoded positions)
        
        const mySeat = seatsData.seats?.find(s => s && s.userId === userId);
        isHost = roomData.room?.hostId === userId; // Update global isHost
        const roomIsActive = !!(roomData.room?.gameId || roomData.room?.game_id); // Game active if gameId exists
        mySeatIndex = mySeat ? mySeat.seatIndex : null;
        
        // CRITICAL: Only calculate isSpectator if NOT already set by hydration
        // Hydration is source of truth (backend checks if user is in gameState.players[])
        // This local calculation is ONLY for pre-game (when hydration returns no active game)
        if (typeof isSpectator !== 'boolean') {
          // Pre-game state: no one is spectating (all can claim seats directly)
          // OR game active but hydration hasn't run yet (shouldn't happen, but fallback)
          if (roomIsActive) {
            // Game active but no hydration data - mark as spectator (safe default)
            isSpectator = true;
            debug('‚ö†Ô∏è Game active but isSpectator not set by hydration - defaulting to spectator');
          } else {
            // Pre-game: no one is a spectator
            isSpectator = false;
          }
        } else {
          // Hydration already set isSpectator - trust it (backend is source of truth)
          debug('‚úÖ Using isSpectator from hydration:', isSpectator);
        }
        
        debug('üëÅÔ∏è Player state:', { 
          isSpectator, 
          isHost,
          roomIsActive,
          mySeat: !!mySeat, 
          mySeatIndex,
          state: !roomIsActive ? 'LOBBY' : (isSpectator ? 'SPECTATOR' : 'ACTIVE_PLAYER')
        });
        
        // Show START button ONLY if:
        // 1. Room status is NOT ACTIVE (no game in progress)
        // 2. 2+ players seated
        // 3. User is host (or show "waiting" if not host)
        const seatedCount = seatsData.occupiedCount || 0;
        
        // Update sandbox section visibility (only show when no active game)
        // Store seats data globally for sandbox mode
        window.currentSeatsData = seatsData;
        updateSandboxVisibility(roomIsActive, seatsData.seats || seatsData);
        
        // CRITICAL: If room is ACTIVE, NEVER show START button (game is in progress)
        if (roomIsActive) {
          document.getElementById('startBtn').style.display = 'none';
          debug('üéÆ Game active - START button hidden');
        } else if (isHost && seatedCount >= 2) {
          document.getElementById('startBtn').style.display = 'inline-block';
          document.getElementById('startBtn').disabled = false;
          document.getElementById('startBtn').textContent = 'Start Hand';
          debug('üéÆ START HAND button enabled (HOST)', { seatedCount });
        } else if (!isHost && seatedCount >= 2) {
          document.getElementById('startBtn').style.display = 'inline-block';
          document.getElementById('startBtn').disabled = true;
          document.getElementById('startBtn').textContent = 'Waiting for Host';
          debug('‚è≥ Waiting for host to start', { hostId: roomData.room?.hostId });
        } else {
          document.getElementById('startBtn').style.display = 'none';
        }
        
        // Load host controls if user is host
        if (isHost) {
          loadHostControls();
        }
        
      } catch (error) {
        debug('‚ùå Load room error', { error: error.message });
        console.error('Load room error:', error);
      }
    }
    
    // ============================================
    // STEP 4: RENDER SEATS
    // ============================================
    function renderSeats(seats, room) {
      debug('üé® Rendering seats...', { seatCount: seats ? seats.length : 0 });
      
      const seatsDiv = document.getElementById('seats');
      seatsDiv.innerHTML = '';
      
      // Check if game is active
      const isGameActive = currentGameState && (currentGameState.status === 'IN_PROGRESS' || currentGameState.status === 'COMPLETED');
      
      // Create 10 seats (displayed as 1-10, internally 0-9)
      // CRITICAL: 
      // - Host/Players: Only show OCCUPIED seats during active game (hide empty seats)
      // - Spectators: Show ALL seats (occupied + empty) so they can see and claim empty ones
      for (let i = 0; i < 10; i++) {
        const seat = seats ? seats[i] : null;
        const isEmpty = !seat || !seat.userId;
        
        // Skip empty seats if game is active AND user is NOT a spectator
        if (isEmpty && isGameActive && !isSpectator) {
          debug(`‚è© Skipping empty seat ${i} (game active, not spectator)`);
          continue;
        }
        
        const div = document.createElement('div');
        const isMe = seat && seat.userId === userId;
        
        div.className = 'seat';
        div.dataset.seatIndex = i; // Add data attribute for positioning
        if (!isEmpty && seat.userId) {
          div.dataset.userId = seat.userId; // Add userId for heads-up positioning
        }
        if (isEmpty) {
          div.className += ' empty';
        } else if (isMe) {
          div.className += ' taken me';
        } else {
          div.className += ' taken';
        }
        
        // Create seat tile wrapper (contains cards and chips)
        const seatTile = document.createElement('div');
        seatTile.className = 'seat-tile';
        
        // Position badges container (dealer, SB, BB) - inside tile
        const positionBadges = document.createElement('div');
        positionBadges.className = 'position-badges';
        positionBadges.dataset.seatIndex = i;
        seatTile.appendChild(positionBadges);
        
        // Avatar/Profile Picture - will be positioned with username outside tile
        let avatar = null;
        if (!isEmpty) {
          avatar = document.createElement('div');
          avatar.className = 'seat-avatar';
          const displayName = seat.nickname || `Guest_${seat.userId.substring(0, 6)}`;
          
          // Try to get profile picture from user data
          const avatarUrl = seat.avatar_url || seat.profilePicture;
          
          if (avatarUrl) {
            const img = document.createElement('img');
            img.src = avatarUrl;
            img.alt = displayName;
            img.onerror = () => {
              // Fallback to initial if image fails to load
              avatar.textContent = displayName.charAt(0).toUpperCase();
            };
            avatar.appendChild(img);
          } else {
          // Use first letter of nickname as fallback
          avatar.textContent = displayName.charAt(0).toUpperCase();
          }
        }
        
        // Card backings container - inside tile
        const cardBacksContainer = document.createElement('div');
        cardBacksContainer.className = 'seat-cards';
        cardBacksContainer.dataset.seatIndex = i;
        seatTile.appendChild(cardBacksContainer);
        
        // Bet amount indicator (Chip + Number style) - will be positioned relative to player-info
        const betIndicator = document.createElement('div');
        betIndicator.className = 'seat-bet-indicator';
        betIndicator.dataset.seatIndex = i;
        betIndicator.style.display = 'none';
        
        // Create chip image element with random chip SVG
        const chipImg = document.createElement('img');
        chipImg.className = 'bet-chip';
        
        // Array of all available chip SVGs (12 total)
        const chipSvgs = [
          'blue_chip_orange_accents.svg',
          'blue_chip_teal_accents.svg',
          'blue_chip_white_accents.svg',
          'orange_chip_blue_accents.svg',
          'orange_chip_teal_accents.svg',
          'orange_chip_white_accents.svg',
          'teal_chip_blue_accents.svg',
          'teal_chip_orange_accents.svg',
          'teal_chip_white_accents.svg',
          'white_chip_blue_accents.svg',
          'white_chip_orange_accents.svg',
          'white_chip_teal_accents.svg'
        ];
        
        // Randomly select a chip SVG
        const randomChip = chipSvgs[Math.floor(Math.random() * chipSvgs.length)];
        chipImg.src = `/public/${randomChip}`; // Server serves from /public/ path
        chipImg.alt = 'Chip';
        
        // Create amount text element
        const amountText = document.createElement('span');
        amountText.className = 'bet-amount';
        
        betIndicator.appendChild(chipImg);
        betIndicator.appendChild(amountText);
        // Don't append to tile yet - will append to seat container after positioning
        
        // Chips display - inside tile at bottom (or outside for heads-up)
        const chips = document.createElement('div');
        chips.className = 'seat-chips';
        
        // Player name - below tile
        const player = document.createElement('div');
        player.className = 'seat-player';
        
        // Check if heads-up (2 players) for special chip positioning
        // We'll check this after all seats are rendered, so for now just mark it
        if (isEmpty) {
          // ARCHITECTURAL FIX: Check if ANYONE has a pending request for this seat
          const hasPendingRequest = myPendingRequests.has(i) || allPendingRequests.has(i);
          const pendingRequest = allPendingRequests.get(i);
          const isMyRequest = myPendingRequests.has(i);
          
          if (hasPendingRequest) {
            // ARCHITECTURAL FIX: Elegant seat request styling
            if (isMyRequest) {
              // Your request - elegant waiting state
              player.textContent = 'Pending Approval';
              player.style.color = 'rgba(255, 255, 255, 0.9)';
              player.style.fontSize = '0.9rem';
              player.style.fontWeight = '500';
              chips.textContent = 'Awaiting host...';
              chips.style.color = 'rgba(255, 255, 255, 0.6)';
              chips.style.fontSize = '0.75rem';
            } else {
              // Someone else's request - show initiator elegantly
              const requesterName = pendingRequest?.username || 'Player';
              player.textContent = requesterName;
              player.style.color = 'rgba(255, 255, 255, 0.7)';
              player.style.fontSize = '0.9rem';
              chips.textContent = 'Requested';
              chips.style.color = 'rgba(255, 149, 0, 0.8)';
              chips.style.fontSize = '0.75rem';
            chips.style.fontStyle = 'italic';
            }
            div.onclick = null; // Disable clicking while pending
            div.style.opacity = '0.85';
            div.style.border = '2px dashed rgba(255, 255, 255, 0.3)';
            div.classList.add('seat-requested');
          } else {
            // Empty seat - allow requesting
          player.textContent = 'EMPTY';
            chips.textContent = 'CLAIM';
          div.onclick = () => claimSeat(i);
            div.classList.remove('seat-requested'); // Remove requested class
          }
          
          // ARCHITECTURAL FIX: Add kick button for host on occupied seats (not empty, not self)
          if (!isEmpty && isHost && seat.userId !== userId) {
            // Add kick button (host can kick other players)
            const kickBtn = document.createElement('button');
            kickBtn.className = 'kick-seat-btn';
            kickBtn.innerHTML = '‚úï';
            kickBtn.title = 'Kick player from seat';
            kickBtn.onclick = (e) => {
              e.stopPropagation();
              if (confirm(`Kick ${seat.nickname || 'player'} from seat ${i}?`)) {
                kickPlayerFromSeat(seat.userId, i);
              }
            };
            seatTile.appendChild(kickBtn);
          }
        } else {
          // Display nickname with rank color and badge (async)
          // NOTE: If seat exists here, player is actually seated (not a spectator)
          const displayName = seat.nickname || `Guest_${seat.userId.substring(0, 6)}`;
          const usernameText = displayName + (isMe ? ' (YOU)' : '');
          player.textContent = `@${displayName}`;
          if (isMe) player.textContent += ' (YOU)';
          
          // CRITICAL: During active game, use chips from gameState (real-time), otherwise use DB chips
          let chipAmount = seat.chips || 1000;
          if (isGameActive && currentGameState && currentGameState.players) {
            const gameStatePlayer = currentGameState.players.find(p => p.seatIndex === i);
            if (gameStatePlayer && gameStatePlayer.chips !== undefined) {
              chipAmount = gameStatePlayer.chips;
            }
          }
          // Format with green dollar sign
          const formatted = formatChipAmount(chipAmount);
          chips.innerHTML = `<span style="color: #00ff88;">$</span>${formatted.replace('$', '').trim()}`;
          chips.style.color = '';
          chips.style.fontStyle = '';
          
          // Apply rank styling and badge (async, non-blocking)
          if (window.UsernameStyling && seat.userId) {
            (async () => {
              try {
                const rankColor = await window.UsernameStyling.getRankColor(seat.userId);
                const badge = await window.UsernameStyling.getTopBadge(seat.userId);
                player.innerHTML = window.UsernameStyling.formatUsernameWithRankAndBadge(
                  usernameText, 
                  rankColor, 
                  badge
                );
              } catch (error) {
                console.error('Error applying rank styling:', error);
                // Fallback to default display
                player.textContent = `@${displayName}` + (isMe ? ' (YOU)' : '');
              }
            })();
          }
        }
        
        // For heads-up: chips go outside tile (adjacent), otherwise inside
        // We'll check after positioning, so add to tile for now
        seatTile.appendChild(chips);
        
        // Create wrapper for avatar + username (positioned above/below tile)
        let playerInfoWrapper = null;
        if (!isEmpty && avatar) {
          playerInfoWrapper = document.createElement('div');
          playerInfoWrapper.className = 'seat-player-info';
          // Avatar and username side by side
          playerInfoWrapper.appendChild(avatar);
          playerInfoWrapper.appendChild(player);
        }
        
        // Assemble based on seat position (will be determined after positioning)
        div.appendChild(seatTile);
        if (playerInfoWrapper) {
          div.appendChild(playerInfoWrapper);
          // Append bet indicator to seat container (will be positioned relative to player-info)
          if (!isEmpty) {
            div.appendChild(betIndicator);
          }
        } else {
          // Empty seat - just show player name below
        div.appendChild(player);
        }
        
        // Mark seat for heads-up chip repositioning (will be done after positioning)
        if (!isEmpty) {
          div.dataset.hasChips = 'true';
        }
        
        seatsDiv.appendChild(div);
      }
      
      // Apply circular positions
      applySeatPositions();
      
      // Update seat position classes (top/bottom) for avatar/username positioning
      updateSeatPositionClasses();
      
      // Update card backings if game is active (pass myHoleCards to show on my seat)
      if (currentGameState) {
        updateSeatCardBackings(currentGameState, myHoleCards);
      }
      
      debug('‚úÖ Seats rendered');
    }
    
    // ============================================
    // STEP 4B: UPDATE SEAT CHIPS IN REAL-TIME
    // ============================================
    /**
     * UPDATE POT DISPLAY
     * CRITICAL: Shows main pot + side pots + total for chip conservation validation
     */
    // Track current pot for increment animation
    let currentPotValue = 0;
    
    // Track previous street for shake animations
    let previousStreet = null;
    
    // Trigger bet pulse animation (ALWAYS GREEN on increment)
    function triggerBetPulse() {
      const potDisplayEl = document.querySelector('.pot-display-center');
      if (!potDisplayEl) return;
      
      // Remove any existing pulse classes
      potDisplayEl.classList.remove('bet-pulse-green', 'bet-pulse-gold');
      
      // ARCHITECTURAL FIX: Always green pulse on increment (user requested)
      potDisplayEl.classList.add('bet-pulse-green');
      
      // Remove class after animation completes
      setTimeout(() => {
        potDisplayEl.classList.remove('bet-pulse-green');
      }, 800);
    }
    
    // Trigger street-based styling (green glow at turn, gold glow + shake at river)
    function triggerStreetShake(street) {
      const potDisplayEl = document.querySelector('.pot-display-center');
      const mainPotEl = document.getElementById('mainPotAmount');
      if (!potDisplayEl) return;
      
      // Remove shake animations (they're temporary)
      potDisplayEl.classList.remove('shake-turn', 'shake-river');
      if (mainPotEl) {
        mainPotEl.classList.remove('shake-river-text');
      }
      
      // Remove glows from previous streets
      potDisplayEl.classList.remove('glow-turn', 'glow-river');
      
      if (street === 'TURN') {
        // TURN: Green glow (persistent) + light shake animation
        potDisplayEl.classList.add('glow-turn', 'shake-turn');
        setTimeout(() => {
          potDisplayEl.classList.remove('shake-turn'); // Remove shake, keep glow
        }, 500);
      } else if (street === 'RIVER') {
        // RIVER: Gold glow (persistent) + intense shake on container + shake on text
        potDisplayEl.classList.add('glow-river', 'shake-river');
        if (mainPotEl) {
          mainPotEl.classList.add('shake-river-text');
        }
        setTimeout(() => {
          potDisplayEl.classList.remove('shake-river'); // Remove shake, keep glow
          if (mainPotEl) {
            mainPotEl.classList.remove('shake-river-text');
          }
        }, 800);
      }
    }
    
    // Track previous chip values for animations
    let previousPlayerChips = new Map(); // seatIndex -> chips
    let previousPlayerBets = new Map(); // seatIndex -> betThisStreet (for calculating bet delta)
    
    function updatePotDisplay(gameState) {
      const mainPot = gameState.mainPot !== undefined ? gameState.mainPot : (gameState.pot || 0);
      const sidePots = gameState.sidePots || [];
      const totalPot = gameState.totalPot !== undefined ? gameState.totalPot : mainPot;
      
      // ARCHITECTURAL FIX: Show "mainPot total totalPot" format when side pots exist (like Poker Now)
      const mainPotEl = document.getElementById('mainPotAmount');
      const totalPotEl = document.getElementById('totalPotAmount');
      const totalLabelEl = document.getElementById('potTotalLabel');
      const totalPotRow = document.getElementById('potTotalRow');
      const potDisplayEl = document.querySelector('.pot-display-center');
      
      // Show/hide total pot display based on side pots (Poker Now style)
      if (sidePots.length > 0 && totalPot > mainPot) {
        // Show "total $X" format (Poker Now style: lowercase "total" + amount)
        if (totalPotRow) totalPotRow.style.display = 'flex';
        if (totalLabelEl) {
          totalLabelEl.textContent = 'total'; // Lowercase, matches Poker Now
        }
        if (totalPotEl) {
          const formattedTotal = formatChipAmount(totalPot).replace('$', '').trim();
          totalPotEl.textContent = formattedTotal;
        }
      } else {
        // Hide total (no side pots, just show main pot)
        if (totalPotRow) totalPotRow.style.display = 'none';
      }
      
      if (mainPotEl) {
        const oldPot = currentPotValue;
        const newPot = mainPot;
        
        // INCREMENT ANIMATION: Count up from old to new value
        if (newPot !== oldPot && oldPot > 0) {
          mainPotEl.classList.add('incrementing');
          
          // Animate the number incrementing
          const incrementDuration = 800; // ms
          const startTime = Date.now();
          const difference = newPot - oldPot;
          
          const animateIncrement = () => {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / incrementDuration, 1);
            
            // Easing function for smooth animation
            const eased = 1 - Math.pow(1 - progress, 3); // Ease out cubic
            
            const currentValue = Math.round(oldPot + (difference * eased));
            const formattedAmount = formatChipAmount(currentValue).replace('$', '').trim();
            mainPotEl.textContent = formattedAmount;
            
            if (progress < 1) {
              requestAnimationFrame(animateIncrement);
            } else {
              // Final value
              const finalFormatted = formatChipAmount(newPot).replace('$', '').trim();
              mainPotEl.textContent = finalFormatted;
              mainPotEl.classList.remove('incrementing');
              currentPotValue = newPot;
            }
          };
          
          requestAnimationFrame(animateIncrement);
        } else {
          // No animation needed (first load or no change)
          const formattedAmount = formatChipAmount(mainPot).replace('$', '').trim();
          mainPotEl.textContent = formattedAmount;
          currentPotValue = newPot;
        }
      }
      
      // Removed chip conservation indicator - using Poker Now style "total" display instead
      
      // Trigger shake animations and persistent glows on street changes
      if (gameState.street && gameState.street !== previousStreet) {
        triggerStreetShake(gameState.street);
        previousStreet = gameState.street;
        
        // ARCHITECTURAL FIX: Clear bet indicators when street advances (betting round ends)
        // betThisStreet resets to 0 on new street, so indicators should disappear
        clearBetIndicators();
      }
      
      // ARCHITECTURAL FIX: Ensure persistent glows remain during street
      // (glow-turn and glow-river persist until street changes - triggerStreetShake handles this)
      
      // ARCHITECTURAL FIX: Remove chip SVGs (user requested removal - they look gross)
      // Chip stack container is hidden/removed
      const chipStackContainer = document.getElementById('chipStackContainer');
      if (chipStackContainer) {
        chipStackContainer.innerHTML = ''; // Clear any existing chips
        chipStackContainer.style.display = 'none'; // Hide container
      }
      
      // Update side pots container
      const sidePotsContainer = document.getElementById('sidePotsContainer');
      const sidePotsList = document.getElementById('sidePotsList');
      
      if (sidePotsContainer && sidePotsList) {
      if (sidePots.length > 0) {
        const sidePotsToShow = sidePots;
        sidePotsList.innerHTML = sidePotsToShow.map((pot, index) => {
          return `<div class="side-pot-item" style="font-size: 0.65rem; color: var(--muted);">
            Side Pot ${index + 1}: ${formatChipAmount(pot.amount)}
          </div>`;
        }).join('');
        sidePotsContainer.style.display = 'block';
      } else {
        sidePotsContainer.style.display = 'none';
          sidePotsList.innerHTML = '';
        }
      } else {
        debug('‚ö†Ô∏è Side pot container not found in DOM');
      }
      
      // Note: totalPotEl already declared above, no need to redeclare
      
      // Backwards compatibility: Update old potAmount element if it exists
      const oldPotEl = document.getElementById('potAmount');
      if (oldPotEl) {
        oldPotEl.textContent = formatChipAmount(mainPot);
      }
      
      // Make pot display clickable to show side pot modal
      const potDisplayCenter = document.querySelector('.pot-display-center');
      if (potDisplayCenter) {
        potDisplayCenter.onclick = () => openSidePotModal(gameState);
        potDisplayCenter.style.cursor = 'pointer';
      }
    }
    
    /**
     * OPEN SIDE POT MODAL
     * Shows detailed breakdown of main pot and all side pots
     */
    function openSidePotModal(gameState) {
      const mainPot = gameState.mainPot !== undefined ? gameState.mainPot : (gameState.pot || 0);
      const sidePots = gameState.sidePots || [];
      const totalPot = gameState.totalPot !== undefined ? gameState.totalPot : mainPot;
      
      // Get or create modal
      let modalOverlay = document.getElementById('sidePotModalOverlay');
      if (!modalOverlay) {
        modalOverlay = document.createElement('div');
        modalOverlay.id = 'sidePotModalOverlay';
        modalOverlay.className = 'side-pot-modal-overlay';
        modalOverlay.innerHTML = `
          <div class="side-pot-modal">
            <div class="side-pot-modal-header">
              <h2>üí∞ Pot Breakdown</h2>
              <button class="side-pot-modal-close" onclick="closeSidePotModal()">√ó</button>
            </div>
            <div id="sidePotModalContent"></div>
          </div>
        `;
        document.body.appendChild(modalOverlay);
        
        // Close on overlay click
        modalOverlay.addEventListener('click', (e) => {
          if (e.target === modalOverlay) {
            closeSidePotModal();
          }
        });
      }
      
      const content = document.getElementById('sidePotModalContent');
      const pots = [];
      
      // Add main pot
      if (mainPot > 0) {
        pots.push({
          label: 'MAIN POT',
          amount: mainPot,
          isMainPot: true,
          eligibleSeats: gameState.players?.filter(p => !p.folded).map(p => p.seatIndex) || []
        });
      }
      
      // Add side pots
      sidePots.forEach((pot, index) => {
        pots.push({
          label: `SIDE POT ${index + 1}`,
          amount: pot.amount || 0,
          isMainPot: false,
          eligibleSeats: pot.eligibleSeats || pot.eligiblePlayerIds?.map(id => {
            const player = gameState.players?.find(p => p.userId === id);
            return player?.seatIndex;
          }).filter(s => s !== undefined) || []
        });
      });
      
      // Render pots
      content.innerHTML = `
        <div class="side-pot-list">
          ${pots.map(pot => `
            <div class="side-pot-item-detailed ${pot.isMainPot ? 'main-pot' : ''}">
              <div class="side-pot-header">
                <div class="side-pot-label">${pot.label}</div>
                <div class="side-pot-amount">${formatChipAmount(pot.amount)}</div>
              </div>
              ${pot.eligibleSeats.length > 0 ? `
                <div class="side-pot-eligible">
                  <div class="side-pot-eligible-label">Eligible Players</div>
                  <div class="side-pot-eligible-seats">
                    ${pot.eligibleSeats.map(seat => `
                      <span class="eligible-seat-badge">Seat ${seat + 1}</span>
                    `).join('')}
                  </div>
                </div>
              ` : ''}
            </div>
          `).join('')}
        </div>
        <div class="side-pot-total">
          <div class="side-pot-total-label">Total Pot</div>
          <div class="side-pot-total-amount">${formatChipAmount(totalPot)}</div>
        </div>
      `;
      
      modalOverlay.classList.add('show');
    }
    
    /**
     * CLOSE SIDE POT MODAL
     */
    function closeSidePotModal() {
      const modalOverlay = document.getElementById('sidePotModalOverlay');
      if (modalOverlay) {
        modalOverlay.classList.remove('show');
      }
    }
    
    // Make closeSidePotModal globally accessible
    window.closeSidePotModal = closeSidePotModal;
    
    /**
     * UPDATE HAND RANK DISPLAY
     * Shows current best hand rank (e.g., "Pair of Tens", "Two Pair 10s and 8s", "Straight")
     * Updates dynamically as community cards are revealed
     */
    function updateHandRankDisplay(gameState, holeCards) {
      const handRankDisplay = document.getElementById('handRankDisplay');
      
      // ARCHITECTURAL PRINCIPLE: Hide hand rank display when:
      // 1. No hole cards
      // 2. Player is a spectator
      // 3. Hand is completed (status === 'COMPLETED')
      // 4. Preflop (no community cards yet)
      
      if (!handRankDisplay) return;
      
      // Hide if no hole cards or spectator
      if (!holeCards || holeCards.length !== 2 || isSpectator) {
        handRankDisplay.style.display = 'none';
        return;
      }
      
      // Hide if hand is completed
      if (gameState && gameState.status === 'COMPLETED') {
        handRankDisplay.style.display = 'none';
        return;
      }
      
      const communityCards = gameState?.communityCards || [];
      
      // Hide if preflop (no community cards yet)
      if (communityCards.length === 0) {
        handRankDisplay.style.display = 'none';
        return;
      }
      
      // Evaluate hand using the same evaluator as backend
      try {
        // Import hand evaluator (it's available in the page)
        const { evaluatePokerHand } = window.handEvaluator || {};
        
        if (!evaluatePokerHand) {
          // Load evaluator dynamically if not available
          console.warn('Hand evaluator not available, loading...');
          handRankDisplay.style.display = 'none';
          return;
        }
        
        const handResult = evaluatePokerHand(holeCards, communityCards);
        const formattedDescription = formatHandDescription(handResult);
        
        // Update display
        const handRankText = document.getElementById('handRankText');
        
        if (handRankText) {
          handRankText.textContent = formattedDescription;
          handRankDisplay.style.display = 'block';
        }
      } catch (error) {
        console.error('Error evaluating hand:', error);
        handRankDisplay.style.display = 'none';
      }
    }
    
    /**
     * FORMAT HAND DESCRIPTION
     * Converts evaluator output to formal poker terminology
     * Examples:
     * - "Pair (Ts)" -> "One Pair (10)"
     * - "Two Pair (10s and 8s)" -> "Two Pair (10, 8)"
     * - "Three of a Kind (7s)" -> "Three of a Kind (7)"
     * - "Straight (J-high)" -> "Straight"
     */
    function formatHandDescription(handResult) {
      if (!handResult || !handResult.name) {
        return 'Evaluating...';
      }
      
      const name = handResult.name;
      
      // Format based on hand type
      if (name.includes('Pair (')) {
        // "Pair (Ts)" -> "One Pair (10)"
        const rankMatch = name.match(/Pair \(([^)]+)\)/);
        if (rankMatch) {
          const rank = rankMatch[1].replace('s', '');
          // Convert T -> 10, keep others as-is
          const rankDisplay = rank === 'T' ? '10' : rank;
          return `One Pair (${rankDisplay})`;
        }
      } else if (name.includes('Two Pair (')) {
        // "Two Pair (10s and 8s)" -> "Two Pair (10, 8)"
        const match = name.match(/Two Pair \(([^)]+)\)/);
        if (match) {
          // Extract ranks: "10s and 8s" -> "10, 8"
          const pairsText = match[1];
          const ranks = pairsText.split(' and ').map(r => {
            const rank = r.replace('s', '');
            return rank === 'T' ? '10' : rank;
          });
          return `Two Pair (${ranks.join(', ')})`;
        }
      } else if (name.includes('Three of a Kind (')) {
        // "Three of a Kind (7s)" -> "Three of a Kind (7)"
        const match = name.match(/Three of a Kind \(([^)]+)\)/);
        if (match) {
          const rank = match[1].replace('s', '');
          const rankDisplay = rank === 'T' ? '10' : rank;
          return `Three of a Kind (${rankDisplay})`;
        }
      } else if (name.includes('Straight (')) {
        // "Straight (J-high)" -> "Straight"
        return 'Straight';
      } else if (name.includes('Flush (')) {
        // "Flush (K-high)" -> "Flush"
        return 'Flush';
      } else if (name.includes('Full House (')) {
        // "Full House (8s over 7s)" -> "Full House (8, 7)"
        const match = name.match(/Full House \(([^)]+)\)/);
        if (match) {
          // Extract ranks: "8s over 7s" -> "8, 7"
          const fullHouseText = match[1];
          const ranks = fullHouseText.split(' over ').map(r => {
            const rank = r.replace('s', '');
            return rank === 'T' ? '10' : rank;
          });
          return `Full House (${ranks.join(', ')})`;
        }
      } else if (name.includes('Four of a Kind (')) {
        // "Four of a Kind (8s)" -> "Four of a Kind (8)"
        const match = name.match(/Four of a Kind \(([^)]+)\)/);
        if (match) {
          const rank = match[1].replace('s', '');
          const rankDisplay = rank === 'T' ? '10' : rank;
          return `Four of a Kind (${rankDisplay})`;
        }
      } else if (name.includes('Straight Flush (')) {
        // "Straight Flush (J-high)" -> "Straight Flush"
        return 'Straight Flush';
      } else if (name.includes('Royal Flush')) {
        return 'Royal Flush';
      } else if (name.includes('High Card (')) {
        // "High Card (K)" -> "High Card (K)"
        const match = name.match(/High Card \(([^)]+)\)/);
        if (match) {
          const rank = match[1];
          const rankDisplay = rank === 'T' ? '10' : rank;
          return `High Card (${rankDisplay})`;
        }
      }
      
      // Fallback: return as-is
      return name;
    }
    
    function updateSeatChips(players) {
      if (!players) return;
      
      debug('üí∞ Updating seat chips', { playerCount: players.length });
      
      players.forEach(player => {
        // Find the seat element by seatIndex (CRITICAL: match by seatIndex, not iterate all)
        const seatsDiv = document.getElementById('seats');
        const seatDiv = seatsDiv.querySelector(`.seat[data-seat-index="${player.seatIndex}"]`);
        
        if (seatDiv) {
          const chipEl = seatDiv.querySelector('.seat-chips');
          if (chipEl && player.chips !== undefined) {
            const oldChips = previousPlayerChips.get(player.seatIndex) || player.chips;
            const newChips = player.chips;
            
            // ARCHITECTURAL FIX: Animate chip changes smoothly
            if (oldChips !== newChips && oldChips !== undefined) {
              // Add animation class
              chipEl.classList.add('chips-updating');
              
              // Animate increment/decrement
              const incrementDuration = 800; // ms
              const startTime = Date.now();
              const difference = newChips - oldChips;
              
              const animateChips = () => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / incrementDuration, 1);
                
                // Easing function for smooth animation
                const eased = 1 - Math.pow(1 - progress, 3); // Ease out cubic
                
                const currentValue = Math.round(oldChips + (difference * eased));
                // Format with green dollar sign
                const formatted = formatChipAmount(currentValue);
                chipEl.innerHTML = `<span style="color: #00ff88;">$</span>${formatted.replace('$', '').trim()}`;
                
                // Add visual feedback based on direction
                if (difference > 0) {
                  chipEl.classList.add('chips-incrementing');
                  chipEl.classList.remove('chips-decrementing');
                } else {
                  chipEl.classList.add('chips-decrementing');
                  chipEl.classList.remove('chips-incrementing');
                }
                
                if (progress < 1) {
                  requestAnimationFrame(animateChips);
                } else {
                  // Final value
                  // Format with green dollar sign
                  const formatted = formatChipAmount(newChips);
                  chipEl.innerHTML = `<span style="color: #00ff88;">$</span>${formatted.replace('$', '').trim()}`;
                  chipEl.classList.remove('chips-updating', 'chips-incrementing', 'chips-decrementing');
                  previousPlayerChips.set(player.seatIndex, newChips);
                }
              };
              
              requestAnimationFrame(animateChips);
            } else {
              // No animation needed (first load or no change)
              // Format with green dollar sign
              const formatted = formatChipAmount(newChips);
              chipEl.innerHTML = `<span style="color: #00ff88;">$</span>${formatted.replace('$', '').trim()}`;
              previousPlayerChips.set(player.seatIndex, newChips);
            }
            
            debug(`üí∞ Updated seat ${player.seatIndex} chips to ${player.chips}`);
          }
        } else {
          debug(`‚ö†Ô∏è Could not find seat element for seatIndex ${player.seatIndex}`);
        }
      });
    }
    
    /**
     * SHOW BET AMOUNT INDICATOR (Poker Now style)
     * Displays the amount a player bet this street - persists until round ends
     * Updates when player acts again (raises/calls)
     */
    function showBetAmount(seatIndex, action, amount) {
      const seat = document.querySelector(`.seat[data-seat-index="${seatIndex}"]`);
      if (!seat) {
        debug(`‚ö†Ô∏è Could not find seat ${seatIndex} for bet indicator`);
        return;
      }
      
      const betIndicator = seat.querySelector('.seat-bet-indicator');
      if (!betIndicator) {
        debug(`‚ö†Ô∏è Bet indicator not found for seat ${seatIndex}`);
        return;
      }
      
      // Format amount based on action type
      let displayText = '';
      if (action === 'BET' || action === 'RAISE') {
        displayText = `${formatChipAmount(amount).replace('$', '').trim()}`;
      } else if (action === 'CALL') {
        displayText = `${formatChipAmount(amount).replace('$', '').trim()}`;
      } else if (action === 'ALL_IN') {
        displayText = `ALL IN ${formatChipAmount(amount).replace('$', '').trim()}`;
      } else {
        return; // Don't show for CHECK/FOLD
      }
      
      // Update bet amount text (chip image already in DOM)
      const amountText = betIndicator.querySelector('.bet-amount');
      if (amountText) {
        amountText.textContent = displayText;
      }
      betIndicator.style.display = 'flex'; // Use flex for chip + amount layout
      
      // Show with animation (pulse in)
      setTimeout(() => {
        betIndicator.classList.add('show');
      }, 10);
      
      // NOTE: Indicator stays visible until betting round ends (cleared in clearBetIndicators)
    }
    
    /**
     * CLEAR BET INDICATORS
     * Removes all bet indicators (called when betting round ends)
     */
    function clearBetIndicators() {
      document.querySelectorAll('.seat-bet-indicator').forEach(indicator => {
        indicator.classList.remove('show');
        indicator.classList.add('fade-out');
        
        setTimeout(() => {
          indicator.style.display = 'none';
          indicator.classList.remove('fade-out');
        }, 300);
      });
    }
    
    /**
     * UPDATE BET INDICATORS FROM GAME STATE
     * Shows current betThisStreet for each player (persists during betting round)
     * Clears indicators when betThisStreet is 0 (new street or no bet)
     */
    function updateBetIndicators(gameState) {
      if (!gameState || !gameState.players) return;
      
      gameState.players.forEach(player => {
        const seat = document.querySelector(`.seat[data-seat-index="${player.seatIndex}"]`);
        if (!seat) return;
        
        const betIndicator = seat.querySelector('.seat-bet-indicator');
        if (!betIndicator) return;
        
        if (player.folded) {
          // Hide indicator if player folded
          betIndicator.style.display = 'none';
          betIndicator.classList.remove('show');
          return;
        }
        
        // Show betThisStreet if player has bet this street
        const betThisStreet = player.betThisStreet || 0;
        if (betThisStreet > 0) {
          let displayText = '';
          if (player.status === 'ALL_IN') {
            displayText = `ALL IN ${formatChipAmount(betThisStreet).replace('$', '').trim()}`;
          } else {
            displayText = `${formatChipAmount(betThisStreet).replace('$', '').trim()}`;
          }
          
          // Update bet amount text (chip image already in DOM)
          const amountText = betIndicator.querySelector('.bet-amount');
          if (amountText) {
            amountText.textContent = displayText;
          }
          betIndicator.style.display = 'flex'; // Use flex for chip + amount layout
          betIndicator.classList.add('show');
        } else {
          // Hide indicator if betThisStreet is 0 (no bet this street)
          betIndicator.style.display = 'none';
          betIndicator.classList.remove('show');
        }
      });
    }
    
    // Legacy function - kept for compatibility
    function updateSeatChipsOld(players) {
      if (!players) return;
      
      debug('üí∞ Updating seat chips', { playerCount: players.length });
      
      players.forEach(player => {
        // Find the seat element
        const seatsDiv = document.getElementById('seats');
        const seatDivs = seatsDiv.querySelectorAll('.seat');
        
        seatDivs.forEach(seatDiv => {
          const label = seatDiv.querySelector('.seat-label');
          if (label && label.textContent === `Seat ${player.seatIndex + 1}`) {
            // Update chips display
            const chipsDiv = seatDiv.querySelector('.seat-chips');
            if (chipsDiv && !chipsDiv.textContent.includes('Click to claim')) {
              chipsDiv.textContent = `$${(player.chips || 0).toLocaleString()}`;
            }
          }
        });
      });
    }
    
    // ============================================
    // STEP 4B2: UPDATE POSITION BADGES (DEALER, SB, BB)
    // ============================================
    function updatePositionBadges(gameState) {
      if (!gameState) return;
      
      debug('üé∞ Updating position badges', { 
        dealer: gameState.dealerPosition, 
        sb: gameState.sbPosition, 
        bb: gameState.bbPosition 
      });
      
      // Clear all existing badges first
      document.querySelectorAll('.position-badges').forEach(container => {
        container.innerHTML = '';
      });
      
      // Show badges during active game or showdown
      if (gameState.status !== 'IN_PROGRESS' && gameState.status !== 'COMPLETED') return;
      
      // Add dealer badge
      if (gameState.dealerPosition !== undefined) {
        const dealerContainer = document.querySelector(`.position-badges[data-seat-index="${gameState.dealerPosition}"]`);
        if (dealerContainer) {
          const badge = document.createElement('span');
          badge.className = 'position-badge dealer';
          badge.textContent = 'D';
          badge.title = 'Dealer';
          dealerContainer.appendChild(badge);
        }
      }
      
      // Add small blind badge
      if (gameState.sbPosition !== undefined) {
        const sbContainer = document.querySelector(`.position-badges[data-seat-index="${gameState.sbPosition}"]`);
        if (sbContainer) {
          const badge = document.createElement('span');
          badge.className = 'position-badge sb';
          badge.textContent = 'SB';
          badge.title = 'Small Blind';
          sbContainer.appendChild(badge);
        }
      }
      
      // Add big blind badge
      if (gameState.bbPosition !== undefined) {
        const bbContainer = document.querySelector(`.position-badges[data-seat-index="${gameState.bbPosition}"]`);
        if (bbContainer) {
          const badge = document.createElement('span');
          badge.className = 'position-badge bb';
          badge.textContent = 'BB';
          badge.title = 'Big Blind';
          bbContainer.appendChild(badge);
        }
      }
    }
    
    // ============================================
    // STEP 4C: UPDATE CARD BACKINGS ON SEATS
    // ============================================
    function updateSeatCardBackings(gameState, myHoleCards = null) {
      if (!gameState || !gameState.players) {
        debug('‚ö†Ô∏è No gameState or players for card backings');
        return;
      }
      
      debug('üÉè Updating seat card backings', { 
        players: gameState.players.length, 
        status: gameState.status,
        playerSeats: gameState.players.map(p => p.seatIndex),
        myHoleCards: myHoleCards
      });
      
      // Loop through all seats
      for (let i = 0; i < 9; i++) {
        const cardBacksContainer = document.querySelector(`.seat-cards[data-seat-index="${i}"]`);
        if (!cardBacksContainer) {
          debug(`‚ö†Ô∏è No card backs container found for seat ${i}`);
          continue;
        }
        
        // Find player in this seat
        const player = gameState.players.find(p => p.seatIndex === i);
        
        // Clear existing card backs
        cardBacksContainer.innerHTML = '';
        
        // Show card backs for IN_PROGRESS or COMPLETED (showdown)
        const shouldShowCards = player && (gameState.status === 'IN_PROGRESS' || gameState.status === 'COMPLETED');
        
        if (shouldShowCards) {
          const isMe = player.userId === userId;
          
          // SPECTATOR LOGIC: Spectators see CARD BACKS (not hole cards) for all players
          if (isSpectator) {
            // Spectators see card backs for all players (they're watching the game)
            debug(`üëÅÔ∏è Spectator view: Showing card backs for seat ${i} (folded: ${player.folded})`);
            for (let j = 0; j < 2; j++) {
              const cardBack = document.createElement('img');
              cardBack.className = 'seat-card-back';
              cardBack.src = '/cards/back.png';
              cardBack.alt = 'Card';
              
              // Grey out if folded
              if (player.folded) {
                cardBack.classList.add('folded');
              }
              
              cardBacksContainer.appendChild(cardBack);
            }
          } else if (isMe && myHoleCards && myHoleCards.length === 2) {
            // MY seat - show actual cards (only if I'm seated, not spectator)
            debug(`‚úÖ Adding MY actual cards for seat ${i}`, { cards: myHoleCards });
            myHoleCards.forEach(card => {
              const cardImg = document.createElement('img');
              cardImg.className = 'seat-card-front';
              cardImg.src = getCardImagePath(card);
              cardImg.alt = card;
              cardImg.onerror = function() {
                this.src = '/cards/back.png';
              };
              cardBacksContainer.appendChild(cardImg);
            });
          } else {
            // Other players - show card backs
            debug(`‚úÖ Adding card backs for seat ${i} (folded: ${player.folded}, status: ${gameState.status})`);
            for (let j = 0; j < 2; j++) {
              const cardBack = document.createElement('img');
              cardBack.className = 'seat-card-back';
              cardBack.src = '/cards/back.png';
              cardBack.alt = 'Card';
              
              // Grey out if folded
              if (player.folded) {
                cardBack.classList.add('folded');
              }
              
              cardBacksContainer.appendChild(cardBack);
            }
          }
        } else {
          debug(`‚ùå Not showing cards for seat ${i} (hasPlayer: ${!!player}, status: ${gameState.status})`);
        }
      }
    }
    
    // ============================================
    // STEP 5: CLAIM SEAT
    // ============================================
    // Track user's own pending seat requests
    let myPendingRequests = new Map(); // seatIndex -> requestId
    
    // ARCHITECTURAL FIX: Track ALL pending seat requests (from any player)
    // This prevents duplicate requests - players see when a seat is requested
    let allPendingRequests = new Map(); // seatIndex -> { requestId, userId, username, requestedChips }
    
    async function claimSeat(seatIndex) {
      // Prevent duplicate calls
      if (isClaimingSeat) {
        debug('‚è∏Ô∏è  Already claiming a seat, ignoring duplicate call');
        return;
      }
      
      // ARCHITECTURAL FIX: Check if ANYONE has a pending request for this seat
      if (allPendingRequests.has(seatIndex)) {
        const pendingRequest = allPendingRequests.get(seatIndex);
        if (pendingRequest.userId === userId) {
        showNotification('You already have a pending request for this seat', 'info');
        } else {
          showNotification(`Seat ${seatIndex + 1} is already requested by ${pendingRequest.username}. Please wait for host approval.`, 'warning');
        }
        return;
      }
      
      isClaimingSeat = true;
      debug(`ü™ë Requesting seat ${seatIndex}...`);
      
      // UNIFIED FLOW: ALWAYS prompt for nickname and chips, ALWAYS create request
      // Prompt for nickname
      const nickname = prompt(
        'üéÆ Choose your nickname (3-15 characters):\n\n' +
        'Letters, numbers, and underscores only.\n' +
        'Leave blank for auto-generated name.',
        ''
      );
      
      // User cancelled
      if (nickname === null) {
        isClaimingSeat = false;
        return;
      }
      
      // Validate nickname if provided
      if (nickname && (nickname.length < 3 || nickname.length > 15)) {
        alert('Nickname must be 3-15 characters');
        isClaimingSeat = false;
        return;
      }
      
      if (nickname && !/^[a-zA-Z0-9_]+$/.test(nickname)) {
        alert('Nickname can only contain letters, numbers, and underscores');
        isClaimingSeat = false;
        return;
      }
      
      // Prompt for desired stack
      const chipsInput = prompt(
        'üí∞ Enter your desired starting stack:\n\n' +
        'Minimum: 1 chip\n' +
        'Leave blank for default (1000 chips)',
        '1000'
      );
      
      // User cancelled
      if (chipsInput === null) {
        isClaimingSeat = false;
        return;
      }
      
      // Parse chips (use default if empty or invalid)
      let requestedChips = 1000; // Default
      if (chipsInput && chipsInput.trim() !== '') {
        const parsed = parseInt(chipsInput.trim());
        if (!isNaN(parsed) && parsed > 0) {
          requestedChips = parsed;
        }
      }
      
      try {
        const response = await fetch(`/api/engine/claim-seat`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            roomId: roomId,
            userId: userId,
            seatIndex: seatIndex,
            nickname: nickname || undefined,
            requestedChips: requestedChips
          })
        });
        
        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || 'Failed to request seat');
        }
        
        const data = await response.json();
        
        // Handle response
        if (data.autoApproved) {
          // Host auto-approved - seat claimed immediately
          debug('‚úÖ Seat auto-approved (host)', { seatIndex });
          showNotification('Seat claimed successfully!', 'success');
          setTimeout(() => loadRoom(), 500); // Refresh to show seat
        } else if (data.requiresApproval && data.requestId) {
          // Non-host: Store request ID and show pending
          myPendingRequests.set(seatIndex, data.requestId);
          debug('‚è≥ Seat request sent, waiting for host approval', { requestId: data.requestId, seatIndex });
          showNotification('Seat request sent to host. Waiting for approval...', 'info');
          loadRoom(); // Refresh to show pending status
        }
        
        isClaimingSeat = false;
        
      } catch (error) {
        debug('‚ùå Request seat error', { error: error.message });
        console.error('Failed to request seat:', error.message);
        showNotification(error.message || 'Failed to request seat', 'error');
        isClaimingSeat = false;
      }
    }
    
    // ============================================
    // STEP 6: START HAND / NEXT HAND
    // ============================================
    async function startHand() {
      const btn = document.getElementById('startBtn');
      const isNextHand = btn.textContent.includes('NEXT');
      
      debug(isNextHand ? 'üé¨ Starting NEXT hand...' : 'üéÆ Starting FIRST hand...');
      
      try {
        // Clear UI before starting new hand
        myHoleCards = null; // Clear stored hole cards
        
        // Use defensive checks for all DOM elements
        const communityCards = document.getElementById('communityCards');
        const myCards = document.getElementById('myCards');
        const currentBet = document.getElementById('currentBet');
        const actionButtons = document.getElementById('actionButtons');
        const myCardsSection = document.getElementById('myCardsSection');
        
        if (communityCards) communityCards.innerHTML = '';
        if (myCards) myCards.innerHTML = '';
        
        // Reset pot display
        updatePotDisplay({ pot: 0, mainPot: 0, sidePots: [], totalPot: 0 });
        
        if (currentBet) currentBet.textContent = '0';
        if (actionButtons) actionButtons.style.display = 'none';
        if (myCardsSection) myCardsSection.style.display = 'none';
        
        // Collect sandbox config if enabled (only for first hand, not next hand)
        let sandboxConfig = null;
        if (!isNextHand) {
          const sandboxEnabled = document.getElementById('sandboxModeToggle')?.checked;
          console.log('üß™ [SANDBOX] Check:', { sandboxEnabled, isNextHand });
          if (sandboxEnabled) {
            sandboxConfig = collectSandboxConfig();
            console.log('üß™ [SANDBOX] Collected config:', sandboxConfig);
            if (!sandboxConfig || sandboxConfig.players.length === 0) {
              showNotification('Sandbox mode enabled but no player cards set. Disable sandbox or set cards.', 'warning');
              console.error('üß™ [SANDBOX] No players found in config!', sandboxConfig);
              return;
            }
            console.log('üß™ [SANDBOX] Sending config with', sandboxConfig.players.length, 'players');
          }
        }
        
        // Use correct endpoint
        const endpoint = isNextHand ? '/api/engine/next-hand' : '/api/engine/deal-cards';
        
        const requestBody = {
          roomId: roomId,
          userId: userId
        };
        
        if (sandboxConfig) {
          requestBody.sandboxConfig = sandboxConfig;
          console.log('üß™ [SANDBOX] Sending request with config:', JSON.stringify(requestBody, null, 2));
        }
        
        const response = await fetch(endpoint, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(requestBody)
        });
        
        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || 'Failed to start hand');
        }
        
        const data = await response.json();
        debug('‚úÖ Hand started', data);
        
        // Store game state ID
        if (data.gameStateId) {
          gameId = data.gameStateId;
        }
        
        // Show game state immediately
        if (data.gameState) {
          const gs = data.gameState;
          
          document.getElementById('communitySection').style.display = 'block';
          updatePotDisplay(gs);
          document.getElementById('currentBet').textContent = gs.currentBet || 0;
          
          const actorText = document.getElementById('currentActor');
          if (gs.currentActorSeat !== undefined) {
            actorText.textContent = `(Seat ${gs.currentActorSeat + 1}'s turn)`;
            actorText.style.display = 'inline';
          }
          
          // Show hand number
          if (gs.handNumber) {
            debug(`üìä Hand #${gs.handNumber}`);
          }
          
          debug('‚úÖ Game state displayed', { pot: gs.pot, currentBet: gs.currentBet, handNumber: gs.handNumber });
        }
        
        // Show cards
        if (data.cards && data.cards.length === 2) {
          myHoleCards = data.cards; // Store globally
          renderMyCards(data.cards);
          
          // ARCHITECTURAL FIX: Update hand rank display after receiving hole cards
          if (data.gameState) {
            updateHandRankDisplay(data.gameState, myHoleCards);
          }
        }
        
        // Reset button text
        btn.textContent = 'üéÆ START HAND';
        btn.style.display = 'none';
        
        // Reload seats to show updated chips
        setTimeout(loadRoom, 500);
        
      } catch (error) {
        debug('‚ùå Start hand error', { error: error.message });
        alert('‚ùå Failed to start hand: ' + error.message);
      }
    }
    
    // ============================================
    // STEP 7: RENDER MY CARDS
    // ============================================
    async function renderMyCards(cards) {
      debug('üÉè Rendering hole cards', { cards });
      
      const section = document.getElementById('myCardsSection');
      const cardsDiv = document.getElementById('myCards');
      
      section.style.display = 'block';
      cardsDiv.innerHTML = '';
      
      cards.forEach(card => {
        const cardImg = document.createElement('img');
        cardImg.className = 'card card-img';
        cardImg.src = getCardImagePath(card);
        cardImg.alt = card;
        cardImg.onerror = function() {
          // Fallback if image doesn't exist
          this.src = '/cards/back.png';
        };
        cardsDiv.appendChild(cardImg);
      });
      
      // Show action buttons only if not a spectator
      if (!isSpectator) {
      document.getElementById('actionButtons').style.display = 'flex';
      
      // Fetch game state and let updateActionButtons handle everything
      try {
        const gameStateResponse = await fetch(`/api/engine/game/${roomId}`);
        if (gameStateResponse.ok) {
          const gameData = await gameStateResponse.json();
          updateActionButtons(gameData);
          evaluateHandStrength(cards, gameData.communityCards || []);
        }
      } catch (error) {
        debug('‚ö†Ô∏è Could not fetch game state', error);
        }
      } else {
        // Spectators cannot see action buttons
        document.getElementById('actionButtons').style.display = 'none';
      }
      
      debug('‚úÖ Cards rendered');
    }
    
    // ============================================
    // STEP 7B: FETCH MY HOLE CARDS
    // ============================================
    async function fetchMyCards() {
      debug('üîí Fetching my hole cards...');
      
      try {
        const response = await fetch(`/api/engine/my-cards/${roomId}/${userId}`);
        
        if (!response.ok) {
          const error = await response.json();
          console.log('‚ö†Ô∏è Could not fetch cards:', error.error);
          return; // Not an error - might not be in this hand
        }
        
        const data = await response.json();
        debug('‚úÖ My cards fetched', data);
        
        if (data.cards && data.cards.length === 2) {
          myHoleCards = data.cards; // Store globally
          renderMyCards(data.cards);
        }
        
      } catch (error) {
        debug('‚ö†Ô∏è Fetch my cards error', { error: error.message });
      }
    }
    
    // ============================================
    // STEP 8: PERFORM ACTION (with debounce)
    // ============================================
    let actionInProgress = false;
    
    async function performAction(action, amount) {
      // Prevent spectators from performing actions
      if (isSpectator) {
        debug('‚ö†Ô∏è Spectators cannot perform actions');
        showNotification('You are a spectator and cannot play. Request a seat to join the game.', 'warning');
        return;
      }
      
      if (actionInProgress) {
        debug('‚ö†Ô∏è Action in progress, blocking double-click');
        return;
      }
      
      actionInProgress = true;
      debug(`üéÆ Performing action: ${action} $${amount}`);
      
      try {
        const response = await fetch('/api/engine/action', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            roomId: roomId,
            userId: userId,
            action: action,
            amount: amount
          })
        });
        
        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || 'Failed to perform action');
        }
        
        const data = await response.json();
        debug('‚úÖ Action performed', data);
        
        // UI will update via WebSocket broadcast automatically
        
      } catch (error) {
        debug('‚ùå Action error', { error: error.message });
        // Silently ignore "Hand is complete" errors - this is expected at showdown
        if (error.message.includes('Hand is complete')) {
          debug('‚ÑπÔ∏è Hand already complete - ignoring action');
          return;
        }
        // For other errors, just log them (no blocking alert)
        console.error('Action failed:', error.message);
      } finally {
        // Reset after 500ms
        setTimeout(() => {
          actionInProgress = false;
          debug('üîì Action debounce released');
        }, 500);
      }
    }
    
    // ============================================
    // STEP 8A: UPDATE ACTION BUTTONS (Single source of truth)
    // ============================================
    function updateActionButtons(gameState) {
      // Find my player
      const myPlayer = gameState.players?.find(p => p.userId === userId);
      if (!myPlayer) return;
      
      // ARCHITECTURAL FIX: During SHOWDOWN, hide action buttons and show SHOW/MUCK buttons
      if (gameState.street === 'SHOWDOWN' && gameState.status === 'COMPLETED') {
        // Hide action buttons
        const actionButtons = document.getElementById('actionButtons');
        if (actionButtons) {
          actionButtons.style.display = 'none';
        }
        
        // Show showdown controls if player didn't fold
        if (!myPlayer.folded) {
          const showdownControls = document.getElementById('showdownControls');
          if (showdownControls) {
            // Check if player already showed/mucked
            const hasShown = showdownActions[userId] === 'SHOW' || showdownActions[userId] === 'MUCK';
            if (!hasShown) {
              showdownControls.classList.add('show');
            } else {
              showdownControls.classList.remove('show');
            }
          }
        }
        return; // Don't update action buttons during showdown
      }
      
      // Hide showdown controls during normal play
      const showdownControls = document.getElementById('showdownControls');
      if (showdownControls) {
        showdownControls.classList.remove('show');
      }
      
      // Show action buttons during normal play
      const actionButtons = document.getElementById('actionButtons');
      if (actionButtons) {
        actionButtons.style.display = 'flex';
      }
      
      const currentBet = gameState.currentBet || 0;
      // FIX: Use betThisStreet (street-scoped) instead of bet (cumulative) for call amount calculation
      // bet persists across streets for side pot calculation, but betThisStreet resets to 0 on new street
      const myBet = myPlayer.betThisStreet || 0;
      
      // CRITICAL FIX: Call amount can NEVER be negative
      // If myBet >= currentBet, player has already matched (CHECK)
      // Clamp to 0 minimum, and cap at player's available chips
      const rawCallAmount = currentBet - myBet;
      
      // WARNING: If myBet > currentBet, something is wrong with bet tracking
      if (myBet > currentBet && currentBet > 0) {
        console.warn(`‚ö†Ô∏è [BET TRACKING] Player bet (${myBet}) exceeds currentBet (${currentBet})!`, {
          userId: myPlayer.userId?.substr(0, 8),
          seatIndex: myPlayer.seatIndex,
          currentBet,
          myBet,
          myChips: myPlayer.chips,
          street: gameState.street
        });
      }
      
      const callAmountNeeded = Math.max(0, rawCallAmount);
      const callAmount = Math.min(callAmountNeeded, myPlayer.chips || 0);
      
      // ARCHITECTURAL TRUTH: currentActorSeat can be null (no one can act)
      // If currentActorSeat is null, hide buttons (runout/advance should happen automatically)
      const isMyTurn = gameState.currentActorSeat !== null && gameState.currentActorSeat === myPlayer.seatIndex;
      
      // ARCHITECTURAL TRUTH: Check if player can actually act
      // FUNDAMENTAL RULE: A player with 0 chips cannot act (they've already gone all-in)
      // Also check if currentActorSeat is null (no one can act)
      const canAct = gameState.currentActorSeat !== null && // Someone must be able to act
                     !myPlayer.folded && 
                     myPlayer.chips > 0 && // Must have chips to act
                     !(myPlayer.status === 'ALL_IN' && myPlayer.chips === 0); // Cannot be full all-in
      
      debug('üîÑ Updating buttons', { 
        currentBet, 
        myBet, 
        myBetCumulative: myPlayer.bet || 0,  // Log both for debugging
        rawCallAmount,
        callAmountNeeded, 
        callAmount, 
        myChips: myPlayer.chips,
        myStatus: myPlayer.status,
        isMyTurn,
        canAct,
        street: gameState.street
      });
      
      const foldBtn = document.getElementById('foldBtn');
      const callBtn = document.getElementById('callBtn');
      const raiseBtn = document.getElementById('raiseBtn');
      const callBtnText = document.getElementById('callBtnText');
      const callAmountSpan = document.getElementById('callAmount');
      
      // ARCHITECTURAL FIX: If player has 0 chips, completely hide buttons (not just disable)
      // This prevents confusion - 0-chip players cannot act, period
      if (myPlayer.chips === 0 || (myPlayer.status === 'ALL_IN' && myPlayer.chips === 0)) {
        if (actionButtons) {
          actionButtons.style.display = 'none';
        }
        debug('üö´ Player has 0 chips - hiding action buttons completely');
        return; // Exit early - no buttons to show
      }
      
      // SET ONCLICK HANDLERS ONCE
      if (callAmount === 0) {
        callBtnText.textContent = 'CHECK';
        callAmountSpan.style.display = 'none';
        callBtn.onclick = () => performAction('CHECK', 0);
      } else {
        callBtnText.textContent = 'CALL';
        callAmountSpan.style.display = 'inline';
        callAmountSpan.textContent = callAmount;
        callBtn.onclick = () => performAction('CALL', callAmount);
      }
      
      foldBtn.onclick = () => performAction('FOLD', 0);
      
      // ARCHITECTURAL FIX: Show "BET" when no bet exists, "RAISE" when bet exists
      if (currentBet === 0) {
        raiseBtn.textContent = 'BET';
      } else {
        raiseBtn.textContent = 'RAISE';
      }
      
      // FIX: Use betThisStreet for raise modal calculation (consistent with call amount fix)
      raiseBtn.onclick = () => openRaiseModal(currentBet, myPlayer.chips, myPlayer.betThisStreet || 0);
      
      // APPLY VISUAL STATE
      // ARCHITECTURAL FIX: Only show buttons if it's my turn AND I can actually act
      if (isMyTurn && canAct) {
        // YOUR TURN - active pulse
        if (actionButtons) {
          actionButtons.style.display = 'flex';
        }
        foldBtn.classList.add('active');
        callBtn.classList.add('active');
        raiseBtn.classList.add('active');
        foldBtn.classList.remove('not-your-turn');
        callBtn.classList.remove('not-your-turn');
        raiseBtn.classList.remove('not-your-turn');
        foldBtn.disabled = false;
        callBtn.disabled = false;
        raiseBtn.disabled = false;
        debug('‚úÖ Your turn - buttons active with pulse');
      } else {
        // NOT YOUR TURN - hide buttons completely
        if (actionButtons) {
          actionButtons.style.display = 'none';
        }
        foldBtn.classList.remove('active');
        callBtn.classList.remove('active');
        raiseBtn.classList.remove('active');
        foldBtn.classList.add('not-your-turn');
        callBtn.classList.add('not-your-turn');
        raiseBtn.classList.add('not-your-turn');
        foldBtn.disabled = true;
        callBtn.disabled = true;
        raiseBtn.disabled = true;
        debug('‚è∏Ô∏è Not your turn - buttons hidden');
      }
      
      // HIGHLIGHT CURRENT PLAYER SEAT
      document.querySelectorAll('.seat').forEach(seat => {
        seat.classList.remove('current-turn');
      });
      
      const currentSeat = document.querySelector(`.seat[data-seat-index="${gameState.currentActorSeat}"]`);
      if (currentSeat) {
        currentSeat.classList.add('current-turn');
        debug(`üí° Highlighted seat ${gameState.currentActorSeat}`);
      }
    }
    
    // ============================================
    // STEP 8B: HANDLE HAND COMPLETE
    // ============================================
    function handleHandComplete(gameState) {
      debug('üèÜ Hand complete', gameState);
      
      // Update dock center - hand complete
      updateDockGameState('Hand complete');
      
      // Hide action buttons
      document.getElementById('actionButtons').style.display = 'none';
      
      // ARCHITECTURAL FIX: Hide runout message when hand completes
      const runoutMessage = document.getElementById('runoutMessage');
      if (runoutMessage) {
        runoutMessage.classList.remove('show');
      }
      
      // ARCHITECTURAL FIX: Hide hand rank display when hand completes
      updateHandRankDisplay(gameState, myHoleCards);
      
      // Store current game state
      currentGameState = gameState;
      
      if (gameState.winners && gameState.winners.length > 0) {
        const winners = gameState.winners;
        
        // GOLDEN PATH: Calculate pot BEFORE payout (sum of all winner amounts)
        const potBeforePayout = winners.reduce((sum, w) => sum + w.amount, 0);
        
        debug(`üèÜ Winners: ${winners.length}, Pot before payout: $${potBeforePayout}`);
        
        // Get winner info
        const winner = winners[0];
          const winnerPlayer = gameState.players.find(p => p.seatIndex === winner.seatIndex);
          const winnerSeat = document.querySelector(`.seat[data-seat-index="${winner.seatIndex}"]`);
          const winnerName = winnerPlayer?.nickname || winnerSeat?.querySelector('.seat-player')?.textContent?.replace('@', '') || `Seat ${winner.seatIndex + 1}`;
          
        // GOLDEN PATH: Set pot display to show pot BEFORE payout
        const potDisplayEl = document.querySelector('.pot-display-center');
        const mainPotEl = document.getElementById('mainPotAmount');
        const totalPotEl = document.getElementById('totalPotAmount');
        
        if (potDisplayEl && mainPotEl) {
          // Set pot to BEFORE payout value (so animation can decrement from here)
          mainPotEl.textContent = formatChipAmount(potBeforePayout).replace('$', '').trim();
          currentPotValue = potBeforePayout; // Track this as current
          
          // Also update total pot if visible
          if (totalPotEl && totalPotEl.style.display !== 'none') {
            totalPotEl.textContent = formatChipAmount(potBeforePayout).replace('$', '').trim();
          }
          
          // Show winner overlay (doesn't touch pot number - it's already set above)
          potDisplayEl.innerHTML = `
            <div class="winner-pot-display" style="text-align: center; animation: winnerGlow 2s ease-in-out infinite;">
              <div style="color: #FFD700; font-size: 0.85rem; font-weight: 600; margin-bottom: 0.2rem; text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);">${winnerName} wins</div>
              <div style="color: #00ff88; font-size: 1.8rem; font-weight: 700; text-shadow: 0 0 15px rgba(0, 255, 136, 0.6);">$${formatChipAmount(potBeforePayout).replace('$', '').trim()}</div>
            </div>
          `;
          
          // Add winner glow animation
          if (!document.getElementById('winnerGlowKeyframes')) {
            const style = document.createElement('style');
            style.id = 'winnerGlowKeyframes';
            style.textContent = `
              @keyframes winnerGlow {
                0%, 100% { 
                  transform: scale(1);
                  filter: brightness(1);
                }
                50% { 
                  transform: scale(1.05);
                  filter: brightness(1.2);
                }
              }
            `;
            document.head.appendChild(style);
          }
        }
        
        // HIGHLIGHT WINNER'S SEAT
        highlightWinnerSeat(winner.seatIndex);
        
        // DETECT ALL-IN RUNOUT: Check if all players were all-in AND cards increased significantly
        const currentCards = gameState.communityCards || [];
        const previousCardsCount = previousCommunityCards.length;
        const newCardsCount = currentCards.length - previousCardsCount;
        
        // All-in runout detection: All players all-in AND multiple new cards (3+ cards = flop+turn+river)
        const allPlayersAllIn = gameState.players?.every(p => 
          p.folded || p.status === 'ALL_IN'
        ) || false;
        const isAllInRunoutScenario = allPlayersAllIn && newCardsCount >= 3;
        
        // If this is an all-in runout, trigger the animation NOW (before showing winner)
        if (isAllInRunoutScenario && !isAllInRunout) {
          debug('üÉè All-in runout detected in hand_complete - triggering card animation');
          isAllInRunout = true;
          
          // Render cards with animation (this will update previousCommunityCards)
          renderCommunityCards(currentCards);
        } else if (currentCards.length > 0) {
          // Normal case: just render cards normally (no animation)
          renderCommunityCards(currentCards);
        }
        
        // SHOW/MUCK CONTROLS - PRINCIPLE: ALL players who reached showdown get controls
        const myPlayer = gameState.players?.find(p => p.userId === userId);
        const didIFold = myPlayer && myPlayer.folded;
        
        if (myPlayer && !didIFold) {
          document.getElementById('showdownControls').classList.add('show');
        }
        
        // GOLDEN PATH: After 3 seconds, animate ONCE - pot decrements, chips increment SYNCHRONIZED
        setTimeout(() => {
          // Clear winner highlight
          clearWinnerHighlight();
          
          // Calculate chips BEFORE payout (final chips - winnings)
          const chipsBeforePayout = new Map();
          gameState.players.forEach(p => {
            const winner = winners.find(w => w.seatIndex === p.seatIndex);
            if (winner) {
              chipsBeforePayout.set(p.seatIndex, (p.chips || 0) - winner.amount);
            } else {
              chipsBeforePayout.set(p.seatIndex, p.chips || 0);
            }
          });
          
          // Set chips to BEFORE values (so animation can increment from here)
          gameState.players.forEach(p => {
            const seat = document.querySelector(`.seat[data-seat-index="${p.seatIndex}"]`);
            const chipsEl = seat?.querySelector('.seat-chips');
            if (chipsEl) {
              const beforeChips = chipsBeforePayout.get(p.seatIndex) || (p.chips || 0);
              const formatted = formatChipAmount(beforeChips);
              chipsEl.innerHTML = `<span style="color: #00ff88;">$</span>${formatted.replace('$', '').trim()}`;
              previousPlayerChips.set(p.seatIndex, beforeChips); // Set tracking to BEFORE value
            }
          });
          
          // CRITICAL FIX: Restore pot display structure WITHOUT destroying it
          // Just clear the winner overlay but preserve the structure
          if (potDisplayEl) {
            // Restore the original pot display structure
            potDisplayEl.innerHTML = `
              <div class="pot-amount-container">
                <div class="pot-amount" id="mainPotAmount">${formatChipAmount(potBeforePayout).replace('$', '').trim()}</div>
                <div class="pot-total-row" id="potTotalRow" style="display: none;">
                  <span class="pot-total-label" id="potTotalLabel">total</span>
                  <span class="pot-total-amount" id="totalPotAmount">0</span>
                </div>
              </div>
              <div id="sidePotsContainer" class="side-pots-container" style="display: none; margin-top: 10px;">
                <div class="side-pot-label" style="font-size: 0.7rem; color: var(--muted); margin-bottom: 5px;">SIDE POTS</div>
                <div id="sidePotsList" style="display: flex; flex-direction: column; gap: 5px;"></div>
              </div>
            `;
            // Re-get references after restoring structure
            const mainPotElRestored = document.getElementById('mainPotAmount');
            const totalPotElRestored = document.getElementById('totalPotAmount');
            
            // CRITICAL FIX: Start pot and chip animations SYNCHRONIZED (same start time)
            const animationStartTime = Date.now();
            const duration = 1200; // ms - same duration for both
            
            // Animate pot decrementing (from potBeforePayout to 0)
            if (mainPotElRestored && potBeforePayout > 0) {
              const animatePot = () => {
                const elapsed = Date.now() - animationStartTime;
                const progress = Math.min(elapsed / duration, 1);
              const eased = 1 - Math.pow(1 - progress, 3); // Ease out cubic
                const currentPot = Math.max(0, Math.round(potBeforePayout * (1 - eased)));
                const formatted = formatChipAmount(currentPot).replace('$', '').trim();
                mainPotElRestored.textContent = formatted;
              
              // Also animate total pot if visible
                if (totalPotElRestored && totalPotElRestored.style.display !== 'none') {
                  totalPotElRestored.textContent = formatted;
              }
              
              if (progress < 1) {
                  requestAnimationFrame(animatePot);
              } else {
                  mainPotElRestored.textContent = '0';
                  if (totalPotElRestored && totalPotElRestored.style.display !== 'none') {
                    totalPotElRestored.textContent = '0';
                }
                currentPotValue = 0;
              }
            };
              requestAnimationFrame(animatePot);
          }
          
            // Animate winner stacks incrementing SYNCHRONIZED (same start time as pot)
            winners.forEach((winner, index) => {
              const winnerPlayer = gameState.players.find(p => p.seatIndex === winner.seatIndex);
              const beforeChips = chipsBeforePayout.get(winner.seatIndex) || 0;
                const finalChips = winnerPlayer.chips || 0;
              const difference = finalChips - beforeChips;
              
              const seat = document.querySelector(`.seat[data-seat-index="${winner.seatIndex}"]`);
              const chipsEl = seat?.querySelector('.seat-chips');
              if (chipsEl && difference > 0) {
                // CRITICAL FIX: Start at same time as pot (minimal stagger for visual effect only)
                    setTimeout(() => {
                  const animateChips = () => {
                    const elapsed = Date.now() - animationStartTime; // Use SAME start time
                    const progress = Math.min(elapsed / duration, 1);
                        const eased = 1 - Math.pow(1 - progress, 3); // Ease out cubic
                    const currentChips = Math.round(beforeChips + (difference * eased));
                    const formatted = formatChipAmount(currentChips);
                        chipsEl.innerHTML = `<span style="color: #00ff88;">$</span>${formatted.replace('$', '').trim()}`;
                        
                        if (progress < 1) {
                      requestAnimationFrame(animateChips);
                        } else {
                          const finalFormatted = formatChipAmount(finalChips);
                          chipsEl.innerHTML = `<span style="color: #00ff88;">$</span>${finalFormatted.replace('$', '').trim()}`;
                          previousPlayerChips.set(winner.seatIndex, finalChips);
                        }
                      };
                  requestAnimationFrame(animateChips);
                }, index * 50); // Minimal stagger (50ms) for visual effect only, not functional delay
              }
            });
            
            // CRITICAL FIX: Wait for ALL animations to complete before syncing
            // Pot animation: duration (1200ms)
            // Chip animations: duration (1200ms) + max stagger (winners.length * 50ms)
            const maxStagger = Math.max(0, (winners.length - 1) * 50);
            const totalAnimationTime = duration + maxStagger;
            
          setTimeout(() => {
              // Now sync final values WITHOUT animating (updateSeatChips will see previousPlayerChips already equals final, so no animation)
              // But first, ensure all previousPlayerChips are set to final (for non-winners too)
              gameState.players.forEach(p => {
                previousPlayerChips.set(p.seatIndex, p.chips || 0);
              });
              
              // Update pot display normally (will restore proper structure)
              updatePotDisplay({ pot: 0, mainPot: 0, sidePots: [], totalPot: 0 });
              
              // Update seat chips - but since previousPlayerChips already equals final, no animation will occur
            updateSeatChips(gameState.players);
            }, totalAnimationTime + 100); // Extra 100ms buffer to ensure all animations complete
            
          } else {
            // Fallback: just reset normally
            updatePotDisplay({ pot: 0, mainPot: 0, sidePots: [], totalPot: 0 });
            gameState.players.forEach(p => {
              previousPlayerChips.set(p.seatIndex, p.chips || 0);
            });
            updateSeatChips(gameState.players);
          }
          
          // Show START button for host
          const startBtn = document.getElementById('startBtn');
          if (startBtn && isHost) {
          startBtn.style.display = 'inline-block';
            startBtn.disabled = false;
            startBtn.textContent = 'üéÆ START HAND';
          }
              
          // Hide show/muck controls after delay
          setTimeout(() => {
              document.getElementById('showdownControls').classList.remove('show');
          }, 2000);
          
        }, 3000); // 3 second delay to show winner
      }
    }
    
    // ============================================
    // RAISE MODAL FUNCTIONS
    // ============================================
    let raiseModalData = {
      currentBet: 0,
      pot: 0,
      stack: 0,
      minRaise: 0,
      maxRaise: 0
    };
    
    function openRaiseModal(currentBet, playerStack, currentPlayerBet = 0) {
      // Get pot from current game state (use totalPot if available, otherwise mainPot or pot)
      const pot = currentGameState 
        ? (currentGameState.totalPot || currentGameState.mainPot || currentGameState.pot || 0)
        : (parseInt(document.getElementById('mainPotAmount')?.textContent.replace(/[^0-9]/g, '') || '0') || 0);
      
      // ARCHITECTURAL FIX: When no bet exists, min bet is big blind. When bet exists, min raise is 2x currentBet
      const bigBlind = currentGameState?.bigBlind || 10;
      const minRaise = currentBet === 0 ? bigBlind : (currentBet * 2 || bigBlind);
      
      // maxRaise = total stack (chips + current bet) - this is the maximum total bet possible
      const maxRaise = playerStack + currentPlayerBet; // Total stack for ALL-IN
      
      raiseModalData = {
        currentBet,
        pot,
        stack: playerStack,
        minRaise,
        maxRaise
      };
      
      // Update panel info
      document.getElementById('raiseModalPot').textContent = '$' + pot;
      document.getElementById('raiseModalStack').textContent = '$' + playerStack;
      document.getElementById('raiseModalMin').textContent = '$' + minRaise;
      
      // ARCHITECTURAL FIX: Update submit button text to show BET/RAISE
      const submitBtn = document.getElementById('raiseSubmitBtn');
      if (submitBtn) {
        submitBtn.textContent = currentBet === 0 ? 'BET' : 'RAISE';
      }
      
      // Setup slider
      const slider = document.getElementById('raiseSlider');
      slider.min = minRaise;
      slider.max = maxRaise;
      slider.value = minRaise;
      
      // Setup input
      const input = document.getElementById('raiseAmount');
      input.min = minRaise;
      input.max = maxRaise;
      input.value = minRaise;
      
      // Update display
      document.getElementById('raiseSliderValue').textContent = '$' + minRaise;
      
      // Show panel
      document.getElementById('raisePanel').style.display = 'block';
      
      // Wire up slider/input sync
      slider.oninput = function() {
        const value = parseInt(this.value);
        input.value = value;
        document.getElementById('raiseSliderValue').textContent = '$' + value;
      };
      
      input.oninput = function() {
        const value = parseInt(this.value) || minRaise;
        const clamped = Math.max(minRaise, Math.min(maxRaise, value));
        slider.value = clamped;
        document.getElementById('raiseSliderValue').textContent = '$' + clamped;
      };
    }
    
    function closeRaisePanel() {
      document.getElementById('raisePanel').style.display = 'none';
    }
    
    function setRaisePreset(preset) {
      const { pot, minRaise, maxRaise } = raiseModalData;
      let amount;
      
      switch(preset) {
        case 'quarter':
          amount = Math.floor(pot * 0.25);
          break;
        case 'half':
          amount = Math.floor(pot * 0.5);
          break;
        case 'threequarter':
          amount = Math.floor(pot * 0.75);
          break;
        case 'pot':
          amount = pot;
          break;
        case 'double':
          amount = pot * 2;
          break;
        case 'allin':
          // ALL-IN: Show custom confirmation modal
          showAllInConfirmation(maxRaise, () => {
            closeRaisePanel();
            performAction('ALL_IN', 0);
          });
          return; // Exit early, don't update slider
        default:
          amount = minRaise;
      }
      
      // Clamp to valid range
      amount = Math.max(minRaise, Math.min(maxRaise, amount));
      
      // Update UI
      document.getElementById('raiseAmount').value = amount;
      document.getElementById('raiseSlider').value = amount;
      document.getElementById('raiseSliderValue').textContent = '$' + amount;
    }
    
    function submitRaise() {
      const amount = parseInt(document.getElementById('raiseAmount').value);
      const { minRaise, maxRaise, stack, currentBet } = raiseModalData;
      
      if (amount < minRaise) {
        alert(`Minimum ${currentBet === 0 ? 'bet' : 'raise'} is $${minRaise}`);
        return;
      }
      
      if (amount > maxRaise) {
        alert(`Maximum ${currentBet === 0 ? 'bet' : 'raise'} is $${maxRaise} (your total stack)`);
        return;
      }
      
      // If amount equals total stack (ALL-IN), show custom confirmation
      if (amount === maxRaise) {
        showAllInConfirmation(maxRaise, () => {
          closeRaisePanel();
          performAction('ALL_IN', 0); // ALL_IN doesn't need amount parameter
        });
      } else {
      closeRaisePanel();
        // ARCHITECTURAL FIX: Send BET when no bet exists, RAISE when bet exists
        const action = currentBet === 0 ? 'BET' : 'RAISE';
        performAction(action, amount);
      }
    }
    
    // Helper: Highlight winner's seat
    function highlightWinnerSeat(seatIndex) {
      const seatsDiv = document.getElementById('seats');
      const seatDivs = seatsDiv.querySelectorAll('.seat');
      
      seatDivs.forEach(seatDiv => {
        const label = seatDiv.querySelector('.seat-label');
        if (label && label.textContent === `Seat ${seatIndex + 1}`) {
          seatDiv.classList.add('winner');
        }
      });
    }
    
    // Helper: Clear winner highlight
    function clearWinnerHighlight() {
      const seatsDiv = document.getElementById('seats');
      const seatDivs = seatsDiv.querySelectorAll('.seat.winner');
      seatDivs.forEach(seatDiv => {
        seatDiv.classList.remove('winner');
      });
    }
    
    // ============================================
    // SHOW/MUCK FUNCTIONALITY
    // ============================================
    async function showCards() {
      debug('üÉè Player chose to SHOW cards');
      
      try {
        const response = await fetch('/api/engine/showdown-action', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            roomId: roomId,
            userId: userId,
            action: 'SHOW'
          })
        });
        
        if (!response.ok) {
          const error = await response.json();
          console.error('‚ùå Show cards error:', error);
          debug('‚ùå Show cards failed', error);
          return;
        }
        
        const result = await response.json();
        debug('‚úÖ Cards shown to table', result);
        
        // Track that we showed
        showdownActions[userId] = 'SHOW';
        
        // Hide controls
        document.getElementById('showdownControls').classList.remove('show');
        
        // NO NEED to manually display - WebSocket will handle it for all players
        
      } catch (error) {
        console.error('‚ùå Show cards network error:', error);
        debug('‚ùå Show cards network error', { error: error.message });
      }
    }
    
    async function muckCards() {
      debug('üóëÔ∏è Player chose to MUCK cards');
      
      try {
        const response = await fetch('/api/engine/showdown-action', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            roomId: roomId,
            userId: userId,
            action: 'MUCK'
          })
        });
        
        if (!response.ok) {
          const error = await response.json();
          console.error('‚ùå Muck cards error:', error);
          debug('‚ùå Muck cards failed', error);
          return;
        }
        
        const result = await response.json();
        debug('‚úÖ Cards mucked', result);
        
        // Track that we mucked
        showdownActions[userId] = 'MUCK';
        
        // Hide controls
        document.getElementById('showdownControls').classList.remove('show');
        
      } catch (error) {
        console.error('‚ùå Muck cards network error:', error);
        debug('‚ùå Muck cards network error', { error: error.message });
      }
    }
    
    // ============================================
    // ALL-IN CONFIRMATION MODAL FUNCTIONS
    // ============================================
    function showAllInConfirmation(amount, onConfirm) {
      // If user checked "don't ask again", skip confirmation
      if (allInDontAskAgain) {
        onConfirm();
        return;
      }
      
      // Store the callback
      pendingAllInAction = onConfirm;
      
      // Update modal content
      document.getElementById('allinConfirmAmount').textContent = `$${amount.toLocaleString()}`;
      document.getElementById('allinDontAskAgain').checked = false;
      
      // Show modal
      document.getElementById('allinConfirmOverlay').classList.add('show');
    }
    
    function confirmAllIn() {
      const dontAskAgain = document.getElementById('allinDontAskAgain').checked;
      if (dontAskAgain) {
        allInDontAskAgain = true; // Remember for this game session
      }
      
      // Hide modal
      document.getElementById('allinConfirmOverlay').classList.remove('show');
      
      // Execute pending action
      if (pendingAllInAction) {
        pendingAllInAction();
        pendingAllInAction = null;
      }
    }
    
    function cancelAllIn() {
      // Hide modal
      document.getElementById('allinConfirmOverlay').classList.remove('show');
      
      // Clear pending action
      pendingAllInAction = null;
    }
    
    // ============================================
    // STEP 8C: RENDER COMMUNITY CARDS
    // ============================================
    // Track previous community cards to avoid re-animating
    let previousCommunityCards = [];
    let isAllInRunout = false; // Track if we're in an all-in runout animation

    function renderCommunityCards(cards) {
      debug('üÉè Rendering community cards', { cards });
      
      const communityDiv = document.getElementById('communityCards');
      
      // ARCHITECTURAL FIX: Update hand rank display when community cards change
      if (currentGameState && myHoleCards && myHoleCards.length === 2) {
        // Create a temporary game state with updated community cards for evaluation
        const tempGameState = { ...currentGameState, communityCards: cards };
        updateHandRankDisplay(tempGameState, myHoleCards);
      }
      
      // Determine which cards are NEW (not in previous render)
      const newCards = cards.filter(card => !previousCommunityCards.includes(card));
      
      // Detect all-in runout: if all players are all-in AND cards increased by more than 1
      const allPlayersAllIn = currentGameState?.players?.every(p => 
        p.folded || p.status === 'ALL_IN'
      ) || false;
      const isRunout = newCards.length > 1 && allPlayersAllIn && !isAllInRunout;
      
      // Only clear and re-render if cards actually changed
      if (newCards.length > 0 || cards.length < previousCommunityCards.length) {
        // If all-in runout, animate cards one by one
        if (isRunout) {
          isAllInRunout = true;
          communityDiv.innerHTML = '';
          
          // Show existing cards first
          previousCommunityCards.forEach(card => {
            const cardImg = document.createElement('img');
            cardImg.className = 'card-img';
            cardImg.src = getCardImagePath(card);
            cardImg.alt = card;
            cardImg.onerror = function() {
              this.src = '/cards/back.png';
            };
            communityDiv.appendChild(cardImg);
          });
          
          // Deal new cards one by one with dramatic delay
          newCards.forEach((card, index) => {
            setTimeout(() => {
              const cardImg = document.createElement('img');
              cardImg.className = 'card-img new-card';
              cardImg.style.opacity = '0';
              cardImg.style.transform = 'scale(0.5) rotateY(180deg)';
              cardImg.src = getCardImagePath(card);
              cardImg.alt = card;
              cardImg.onerror = function() {
                this.src = '/cards/back.png';
              };
              communityDiv.appendChild(cardImg);
              
              // Animate card flip-in
              setTimeout(() => {
                cardImg.style.transition = 'all 0.5s ease-out';
                cardImg.style.opacity = '1';
                cardImg.style.transform = 'scale(1) rotateY(0deg)';
              }, 50);
              
              // If this is the last card, reset flag
              if (index === newCards.length - 1) {
                setTimeout(() => {
                  isAllInRunout = false;
                }, 600);
              }
            }, index * 800); // 800ms delay between each card for dramatic effect
          });
          
          // Update tracking immediately (for hand strength evaluation)
          previousCommunityCards = [...cards];
        } else {
          // Normal card rendering (no animation)
      communityDiv.innerHTML = '';
      
      cards.forEach(card => {
        const cardImg = document.createElement('img');
        cardImg.className = 'card-img';
          
          // Only add 'new-card' class if this card wasn't in previous render
          if (newCards.includes(card)) {
            cardImg.classList.add('new-card');
          }
          
        cardImg.src = getCardImagePath(card);
        cardImg.alt = card;
        cardImg.onerror = function() {
          this.src = '/cards/back.png';
        };
        communityDiv.appendChild(cardImg);
      });
        
        // Update tracking
        previousCommunityCards = [...cards];
        }
      }
      
      document.getElementById('communitySection').style.display = 'block';
      
      // Re-evaluate hand strength when community cards change
      const myCardsDiv = document.getElementById('myCards');
      if (myCardsDiv && myCardsDiv.dataset.cards) {
        const myCards = JSON.parse(myCardsDiv.dataset.cards);
        evaluateHandStrength(myCards, cards);
      }
    }
    
    // ============================================
    // STEP 8D: EVALUATE AND DISPLAY HAND STRENGTH
    // ============================================
    function evaluateHandStrength(holeCards, communityCards) {
      // Store cards for re-evaluation
      const myCardsDiv = document.getElementById('myCards');
      myCardsDiv.dataset.cards = JSON.stringify(holeCards);
      
      if (!holeCards || holeCards.length !== 2) return;
      if (!communityCards) communityCards = [];
      
      const allCards = [...holeCards, ...communityCards];
      
      // Simple hand evaluation (client-side approximation)
      const handDescription = getSimpleHandDescription(allCards);
      
      // Display hand strength (always show when player has cards)
      const strengthDiv = document.getElementById('handStrength');
      const textDiv = document.getElementById('handStrengthText');
      
      if (handDescription) {
        textDiv.textContent = handDescription;
        strengthDiv.style.display = 'block';
        debug('üé¥ Hand strength:', handDescription);
      } else {
        // Hide if no description (no cards yet)
        strengthDiv.style.display = 'none';
      }
    }
    
    /**
     * Simple client-side hand evaluation
     * Returns description like "Pair of AA", "Two Pair - QQ33"
     */
    function getSimpleHandDescription(cards) {
      if (cards.length < 2) return 'Incomplete Hand';
      
      // Parse ranks
      const rankMap = { '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, 'T': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14 };
      const rankCharMap = { 2: '2', 3: '3', 4: '4', 5: '5', 6: '6', 7: '7', 8: '8', 9: '9', 10: 'T', 11: 'J', 12: 'Q', 13: 'K', 14: 'A' };
      
      const ranks = cards.map(card => rankMap[card[0]]);
      const suits = cards.map(card => card[1]);
      
      // Count frequencies
      const rankCounts = {};
      ranks.forEach(r => rankCounts[r] = (rankCounts[r] || 0) + 1);
      
      const pairs = [];
      const trips = [];
      const quads = [];
      
      for (const [rank, count] of Object.entries(rankCounts)) {
        if (count === 4) quads.push(parseInt(rank));
        if (count === 3) trips.push(parseInt(rank));
        if (count === 2) pairs.push(parseInt(rank));
      }
      
      // Sort descending
      pairs.sort((a, b) => b - a);
      trips.sort((a, b) => b - a);
      quads.sort((a, b) => b - a);
      
      // Check flush
      const suitCounts = {};
      suits.forEach(s => suitCounts[s] = (suitCounts[s] || 0) + 1);
      const isFlush = Object.values(suitCounts).some(c => c >= 5);
      
      // Check straight (simplified)
      const uniqueRanks = [...new Set(ranks)].sort((a, b) => b - a);
      let isStraight = false;
      if (uniqueRanks.length >= 5) {
        for (let i = 0; i <= uniqueRanks.length - 5; i++) {
          if (uniqueRanks[i] - uniqueRanks[i + 4] === 4) {
            isStraight = true;
            break;
          }
        }
      }
      
      // Determine hand
      if (quads.length > 0) {
        return `Four of a Kind (${rankCharMap[quads[0]]}s)`;
      }
      if (trips.length > 0 && pairs.length > 0) {
        return `Full House (${rankCharMap[trips[0]]}${rankCharMap[trips[0]]}${rankCharMap[trips[0]]} over ${rankCharMap[pairs[0]]}${rankCharMap[pairs[0]]})`;
      }
      if (isFlush) {
        return 'Flush';
      }
      if (isStraight) {
        return 'Straight';
      }
      if (trips.length > 0) {
        return `Three of a Kind (${rankCharMap[trips[0]]}s)`;
      }
      if (pairs.length >= 2) {
        return `Two Pair (${rankCharMap[pairs[0]]}${rankCharMap[pairs[0]]} ${rankCharMap[pairs[1]]}${rankCharMap[pairs[1]]})`;
      }
      if (pairs.length === 1) {
        return `Pair (${rankCharMap[pairs[0]]}${rankCharMap[pairs[0]]})`;
      }
      
      // High card
      const highCard = Math.max(...ranks);
      return `High Card (${rankCharMap[highCard]})`;
    }
    
    // ============================================
    // STEP 9: RENDER COMMUNITY CARDS + POT
    // ============================================
    function renderCommunity(communityCards, pot, currentBet) {
      if (!communityCards || communityCards.length === 0) {
        document.getElementById('communitySection').style.display = 'none';
        return;
      }
      
      debug('üé¥ Rendering community cards', { communityCards, pot, currentBet });
      
      const section = document.getElementById('communitySection');
      const cardsDiv = document.getElementById('communityCards');
      
      section.style.display = 'block';
      cardsDiv.innerHTML = '';
      
      communityCards.forEach(card => {
        const cardDiv = document.createElement('div');
        cardDiv.className = 'card';
        cardDiv.style.backgroundImage = `url('/cards/${card}.png')`;
        cardsDiv.appendChild(cardDiv);
      });
      
      // Pot display updated via updatePotDisplay when gameState is set
      document.getElementById('currentBet').textContent = currentBet || 0;
      
      debug('‚úÖ Community cards rendered');
    }
    
    // ============================================
    // STEP 10: UPDATE TURN INDICATOR
    // ============================================
    function updateTurnIndicator(currentActorSeat) {
      const indicator = document.getElementById('turnIndicator');
      const actorText = document.getElementById('currentActor');
      
      if (currentActorSeat === null || currentActorSeat === undefined) {
        indicator.style.display = 'none';
        actorText.textContent = '';
        return;
      }
      
      // Check if it's our turn
      // (This is simplified - need to map userId to seat)
      actorText.textContent = `(Waiting for Seat ${currentActorSeat + 1})`;
      
      // TODO: Properly detect if current actor is us
      // indicator.style.display = 'inline';
    }
    
    // ============================================
    // üéõÔ∏è HOST CONTROLS FUNCTIONS
    // ============================================
    // Modal Functions
    function openHostControlsModal() {
      document.getElementById('hostControlsModal').style.display = 'flex';
    }
    
    function closeHostControlsModal() {
      document.getElementById('hostControlsModal').style.display = 'none';
    }
    
    function openPlayerSettingsModal() {
      document.getElementById('playerSettingsModal').style.display = 'flex';
    }
    
    function closePlayerSettingsModal() {
      document.getElementById('playerSettingsModal').style.display = 'none';
    }
    
    function closeModalOnOverlay(event, modalId) {
      if (event.target.id === modalId) {
        document.getElementById(modalId).style.display = 'none';
      }
    }
    
    async function loadHostControls() {
      // Show/hide header buttons based on host status
      const hostBtn = document.getElementById('hostControlsBtn');
      if (hostBtn) {
        hostBtn.style.display = isHost ? 'inline-flex' : 'none';
      }
      
      if (!isHost) {
        // Non-hosts only see settings button
        return;
      }
      
      // Hosts: load host controls content
      debug('üéõÔ∏è Loading host controls...');
      
      try {
        const response = await fetch(`/api/engine/host-controls/${roomId}/${userId}`);
        if (!response.ok) {
          console.error('Failed to load host controls');
          return;
        }
        
        const data = await response.json();
        debug('‚úÖ Host controls loaded', data);
        
        // Update blinds inputs
        document.getElementById('hostSmallBlindInput').value = data.room.smallBlind;
        document.getElementById('hostBigBlindInput').value = data.room.bigBlind;
        
        // Render players
        renderHostPlayerList(data.players);
        
        // Update chip adjustment dropdown
        updateChipAdjustmentDropdown(data.players);
        
        // Load pending seat requests
        loadPendingSeatRequests();
        
      } catch (error) {
        console.error('Error loading host controls:', error);
      }
    }
    
    // Refresh host controls when room state changes (seats updated, etc.)
    function refreshHostControls() {
      if (isHost) {
        loadHostControls();
      }
    }
    
    // ============================================
    // SEAT REQUEST FUNCTIONS
    // ============================================
    
    async function loadPendingSeatRequests() {
      if (!isHost) return;
      
      try {
        const response = await fetch(`/api/rooms/${roomId}/seat-requests?hostId=${userId}`);
        if (!response.ok) {
          console.error('Failed to load seat requests');
          return;
        }
        
        const data = await response.json();
        const container = document.getElementById('pendingSeatRequests');
        const requestsSection = document.getElementById('pendingSeatRequestsSection');
        
        if (!data.requests || data.requests.length === 0) {
          container.innerHTML = '<div class="empty-state">No pending requests</div>';
          if (requestsSection) requestsSection.style.display = 'none';
          // Hide badge
          const badge = document.getElementById('pendingRequestsBadge');
          if (badge) badge.style.display = 'none';
          return;
        }
        
        // Show requests section
        if (requestsSection) requestsSection.style.display = 'block';
        
        // Update badge count
        const badge = document.getElementById('pendingRequestsBadge');
        if (badge) {
          badge.textContent = data.requests.length;
          badge.style.display = data.requests.length > 0 ? 'inline-block' : 'none';
        }
        
        // Render requests inline with approve/reject buttons (compact layout)
        container.innerHTML = data.requests.map(req => `
          <div class="seat-request-item-compact">
            <div class="seat-request-info-compact">
              <div class="seat-request-name-compact">@${req.username}</div>
              <div class="seat-request-details-compact">
                Seat ${req.seatIndex + 1} ‚Ä¢ $${req.requestedChips.toLocaleString()}
              </div>
            </div>
            <div class="seat-request-actions-compact">
              <button class="approve-btn-compact" onclick="approveSeatRequestInline('${req.id}')" title="Approve">
                ‚úÖ
              </button>
              <button class="reject-btn-compact" onclick="rejectSeatRequestInline('${req.id}')" title="Reject">
                ‚ùå
              </button>
            </div>
          </div>
        `).join('');
      } catch (error) {
        console.error('Error loading seat requests:', error);
      }
    }
    
    // Inline approve/reject functions for compact seat requests
    async function approveSeatRequestInline(requestId) {
      if (!isHost) return;
      
      try {
        const response = await fetch(`/api/rooms/${roomId}/approve-seat-request`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            hostId: userId,
            requestId: requestId
          })
        });
        
        if (!response.ok) {
          const error = await response.json();
          showNotification(error.error || 'Failed to approve request', 'error');
          return;
        }
        
        showNotification('Seat request approved', 'success');
        loadPendingSeatRequests(); // Refresh list (will update badge)
        refreshHostControls(); // Refresh player list
        loadRoom(); // Refresh room state
      } catch (error) {
        console.error('Error approving seat request:', error);
        showNotification('Failed to approve request', 'error');
      }
    }
    
    async function rejectSeatRequestInline(requestId) {
      if (!isHost) return;
      
      try {
        const response = await fetch(`/api/rooms/${roomId}/reject-seat-request`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            hostId: userId,
            requestId: requestId
          })
        });
        
        if (!response.ok) {
          const error = await response.json();
          showNotification(error.error || 'Failed to reject request', 'error');
          return;
        }
        
        showNotification('Seat request rejected', 'info');
        loadPendingSeatRequests(); // Refresh list (will update badge)
      } catch (error) {
        console.error('Error rejecting seat request:', error);
        showNotification('Failed to reject request', 'error');
      }
    }
    
    // Popup functions removed - approval/rejection now done inline from host controls list
    
    async function getSeatRequestById(requestId) {
      try {
        const response = await fetch(`/api/rooms/${roomId}/seat-requests?hostId=${userId}`);
        if (!response.ok) return null;
        
        const data = await response.json();
        return data.requests?.find(r => r.id === requestId) || null;
      } catch (error) {
        console.error('Error getting seat request:', error);
        return null;
      }
    }
    
    // Simple notification function (fallback if showToast doesn't exist)
    // Top-right notification system
    // Elegant corner notification for player approvals
    function showCornerNotification(message, type = 'info') {
      const notification = document.createElement('div');
      notification.className = 'corner-notification';
      notification.style.cssText = `
        position: fixed;
        bottom: 20px;
        right: 20px;
        background: rgba(0, 0, 0, 0.9);
        color: ${type === 'info' ? '#00d9ff' : '#ff9500'};
        padding: 1rem 1.5rem;
        border-radius: 10px;
        border: 2px solid ${type === 'info' ? '#00d9ff' : '#ff9500'};
        font-size: 0.9rem;
        font-weight: 500;
        z-index: 9999;
        animation: slideInRight 0.3s ease-out, fadeOut 0.3s ease-in 2.7s;
        box-shadow: 0 4px 20px rgba(0, 217, 255, 0.3);
      `;
      notification.textContent = message;
      
      // Add animation keyframes if not exists
      if (!document.getElementById('cornerNotificationKeyframes')) {
        const style = document.createElement('style');
        style.id = 'cornerNotificationKeyframes';
        style.textContent = `
          @keyframes slideInRight {
            from { transform: translateX(400px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
          }
          @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
          }
        `;
        document.head.appendChild(style);
      }
      
      document.body.appendChild(notification);
      
      // Remove after 3s
      setTimeout(() => notification.remove(), 3000);
    }
    
    function showNotification(message, type = 'info') {
      // Try showToast first (if it exists)
      if (typeof showToast === 'function') {
        showToast(message, type);
        return;
      }
      
      // Create notification popup in top-right
      const notification = document.createElement('div');
      notification.className = `notification-popup notification-${type}`;
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: rgba(27, 27, 35, 0.95);
        backdrop-filter: blur(10px);
        border: 1px solid ${type === 'error' ? 'rgba(255, 59, 59, 0.3)' : type === 'success' ? 'rgba(0, 212, 170, 0.3)' : 'rgba(255, 165, 0, 0.3)'};
        border-radius: 12px;
        padding: 16px 20px;
        color: #e9eef7;
        font-size: 0.9rem;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        z-index: 10000;
        max-width: 400px;
        animation: slideInRight 0.3s ease-out;
        display: flex;
        align-items: center;
        gap: 12px;
      `;
      
      const icon = type === 'error' ? '‚ùå' : type === 'success' ? '‚úÖ' : '‚ÑπÔ∏è';
      notification.innerHTML = `
        <span style="font-size: 1.2rem;">${icon}</span>
        <span style="flex: 1;">${message}</span>
        <button onclick="this.parentElement.remove()" style="background: none; border: none; color: #9aa3b2; cursor: pointer; font-size: 1.2rem; padding: 0; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center;">√ó</button>
      `;
      
      document.body.appendChild(notification);
      
      // Auto-remove after 5 seconds
      setTimeout(() => {
        if (notification.parentElement) {
          notification.style.animation = 'slideOutRight 0.3s ease-in';
          setTimeout(() => notification.remove(), 300);
        }
      }, 5000);
      
      // Add click to dismiss
      notification.querySelector('button').addEventListener('click', () => {
        notification.style.animation = 'slideOutRight 0.3s ease-in';
        setTimeout(() => notification.remove(), 300);
      });
    }
    
    // Add CSS animations
    if (!document.getElementById('notificationStyles')) {
      const style = document.createElement('style');
      style.id = 'notificationStyles';
      style.textContent = `
        @keyframes slideInRight {
          from {
            transform: translateX(100%);
            opacity: 0;
          }
          to {
            transform: translateX(0);
            opacity: 1;
          }
        }
        @keyframes slideOutRight {
          from {
            transform: translateX(0);
            opacity: 1;
          }
          to {
            transform: translateX(100%);
            opacity: 0;
          }
        }
        .badge-count {
          display: inline-block;
          background: #ff5100;
          color: white;
          border-radius: 12px;
          padding: 2px 8px;
          font-size: 0.75rem;
          font-weight: 700;
          margin-left: 6px;
          min-width: 20px;
          text-align: center;
        }
      `;
      document.head.appendChild(style);
    }
    
    function renderHostPlayerList(players) {
      const container = document.getElementById('hostPlayerList');
      const countEl = document.getElementById('hostPlayerCount');
      
      if (!container || !countEl) {
        debug('‚ö†Ô∏è Host player list elements not found');
        return;
      }
      
      // All players in this list are actually seated (spectators are NOT in room_seats)
      countEl.textContent = players.length;
      
      if (players.length === 0) {
        container.innerHTML = '<div class="empty-state">No players seated</div>';
        return;
      }
      
      // Render players with stack input and kick button (compact layout)
      container.innerHTML = players.map(player => {
        // NOTE: If player is in this list, they're actually seated (not a spectator)
        // Spectators are NOT in room_seats, so they won't appear here
        return `
        <div class="player-item-compact">
          <div class="player-item-info-compact">
            <div class="player-item-name-compact">
              @${player.nickname}
              ${player.userId === userId ? ' <span class="you-badge">(YOU)</span>' : ''}
            </div>
            <div class="player-item-details-compact">
              <span class="seat-badge">Seat ${player.seatIndex + 1}</span>
              <div class="stack-input-group" style="display: flex; gap: 6px; align-items: center;">
                <input 
                  type="number" 
                  id="stackInput_${player.seatIndex}" 
                  value="${player.chips}" 
                  min="0" 
                  step="1"
                  class="stack-input-compact"
                  style="width: 80px; padding: 4px 6px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.2); border-radius: 4px; color: #e9eef7; font-size: 0.85rem;"
                  onchange="updatePlayerStack(${player.seatIndex}, this.value)"
                >
                <button 
                  class="update-stack-btn-compact" 
                  onclick="updatePlayerStack(${player.seatIndex}, document.getElementById('stackInput_${player.seatIndex}').value)"
                  title="Update stack"
                  style="padding: 4px 8px; background: rgba(0,212,170,0.1); border: 1px solid #00d4aa; border-radius: 4px; color: #00d4aa; font-size: 0.75rem; cursor: pointer;"
                >
                  ‚úì
                </button>
              </div>
            </div>
          </div>
          ${player.userId !== userId ? `
            <button class="kick-btn-compact" onclick="kickPlayer('${player.userId}')" title="Kick player">
              üö´
            </button>
          ` : ''}
        </div>
      `;
      }).join('');
    }
    
    async function updatePlayerStack(seatIndex, newChips) {
      const chips = parseInt(newChips);
      
      if (isNaN(chips) || chips < 0) {
        alert('Invalid chip amount. Must be a positive number.');
        return;
      }
      
      debug(`üí∞ Updating seat ${seatIndex} stack to ${chips}`);
      
      try {
        const response = await fetch('/api/engine/host-controls/update-stack', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            roomId,
            hostId: userId,
            seatIndex,
            newChips: chips
          })
        });
        
        if (!response.ok) {
          const error = await response.json();
          alert(`Failed to update stack: ${error.error}`);
          return;
        }
        
        debug('‚úÖ Stack updated');
        loadHostControls(); // Refresh panel
        loadRoom(); // Refresh seats
        
      } catch (error) {
        console.error('Error updating stack:', error);
        alert('Failed to update stack');
      }
    }
    
    async function kickPlayer(targetUserId) {
      if (!confirm('Are you sure you want to kick this player? They will be removed from their seat.')) {
        return;
      }
      
      debug('üö´ Kicking player:', targetUserId);
      
      try {
        const response = await fetch('/api/engine/host-controls/kick-player', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            roomId,
            hostId: userId,
            targetUserId
          })
        });
        
        if (!response.ok) {
          const error = await response.json();
          alert(`Failed to kick player: ${error.error}`);
          return;
        }
        
        debug('‚úÖ Player kicked');
        loadHostControls(); // Refresh panel
        loadRoom(); // Refresh seats
        
      } catch (error) {
        console.error('Error kicking player:', error);
        alert('Failed to kick player');
      }
    }
    
    // ARCHITECTURAL FIX: Kick player from seat (called from seat UI)
    async function kickPlayerFromSeat(targetUserId, seatIndex) {
      debug('üö´ Kicking player from seat:', { targetUserId, seatIndex });
      await kickPlayer(targetUserId);
    }
    
    // ARCHITECTURAL FIX: Update seat request status visually
    function updateSeatRequestStatus(seatIndex, isRequested, requesterName = null) {
      const seatElement = document.querySelector(`.seat[data-seat-index="${seatIndex}"]`);
      if (!seatElement) return;
      
      if (isRequested) {
        seatElement.classList.add('seat-requested');
        const chipsElement = seatElement.querySelector('.seat-chips');
        const playerElement = seatElement.querySelector('.seat-player');
        if (chipsElement && requesterName) {
          chipsElement.textContent = `Requested by ${requesterName}`;
          chipsElement.style.color = '#ff9500';
          chipsElement.style.fontStyle = 'italic';
        }
        if (playerElement) {
          playerElement.textContent = 'REQUESTED';
        }
        seatElement.onclick = null; // Disable clicking
        seatElement.style.opacity = '0.7';
      } else {
        seatElement.classList.remove('seat-requested');
        const chipsElement = seatElement.querySelector('.seat-chips');
        const playerElement = seatElement.querySelector('.seat-player');
        if (chipsElement) {
          chipsElement.style.color = '';
          chipsElement.style.fontStyle = '';
        }
        if (playerElement && !seatElement.classList.contains('taken')) {
          playerElement.textContent = 'EMPTY';
          chipsElement.textContent = 'CLAIM';
          seatElement.onclick = () => claimSeat(seatIndex);
        }
        seatElement.style.opacity = '';
      }
    }
    
    async function updateBlinds() {
      const smallBlind = parseInt(document.getElementById('hostSmallBlindInput').value);
      const bigBlind = parseInt(document.getElementById('hostBigBlindInput').value);
      
      if (bigBlind <= smallBlind) {
        alert('Big blind must be greater than small blind!');
        return;
      }
      
      if (smallBlind < 1 || bigBlind < 2) {
        alert('Blinds must be positive integers!');
        return;
      }
      
      debug('üí∞ Updating blinds:', { smallBlind, bigBlind });
      
      try {
        const response = await fetch('/api/engine/host-controls/update-blinds', {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            roomId,
            hostId: userId,
            smallBlind,
            bigBlind
          })
        });
        
        if (!response.ok) {
          const error = await response.json();
          alert(`Failed to update blinds: ${error.error}`);
          return;
        }
        
        const result = await response.json();
        debug('‚úÖ Blinds updated', result);
        
        if (result.applied === 'queued') {
          alert(`‚è≥ Blinds queued: $${smallBlind}/$${bigBlind}\n\nWill apply after current hand ends.`);
        } else {
          alert(`‚úÖ Blinds updated to $${smallBlind}/$${bigBlind}`);
        }
        
      } catch (error) {
        console.error('Error updating blinds:', error);
        alert('Failed to update blinds');
      }
    }
    
    // ============================================
    // HOST: CHIP ADJUSTMENT
    // ============================================
    function updateChipAdjustmentDropdown(players) {
      const chipAdjustSeat = document.getElementById('chipAdjustSeat');
      if (!chipAdjustSeat) return;
      
      if (players.length === 0) {
        chipAdjustSeat.innerHTML = '<option value="">No players seated</option>';
        return;
      }
      
      chipAdjustSeat.innerHTML = '<option value="">Select a player...</option>' + 
        players.map(player => `
          <option value="${player.seatIndex}">
            Seat ${player.seatIndex + 1}: @${player.nickname} ($${player.chips.toLocaleString()})
          </option>
        `).join('');
    }
    
    async function adjustPlayerChips() {
      const seatSelect = document.getElementById('chipAdjustSeat');
      const amountInput = document.getElementById('chipAdjustAmount');
      
      const seatIndex = parseInt(seatSelect.value);
      const newAmount = parseInt(amountInput.value);
      
      // Validation
      if (isNaN(seatIndex) || seatIndex === '') {
        alert('‚ùå Please select a player!');
        return;
      }
      
      if (isNaN(newAmount) || newAmount < 0) {
        alert('‚ùå Please enter a valid amount (minimum $0)!');
        return;
      }
      
      const playerName = seatSelect.options[seatSelect.selectedIndex].text;
      const confirmed = confirm(`üí∞ Adjust ${playerName}'s chips to $${newAmount.toLocaleString()}?`);
      
      if (!confirmed) return;
      
      debug('üíµ Adjusting chips:', { seatIndex, newAmount });
      
      try {
        const response = await fetch('/api/engine/host-controls/adjust-chips', {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            roomId,
            hostId: userId,
            seatIndex,
            newAmount
          })
        });
        
        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || 'Failed to adjust chips');
        }
        
        const result = await response.json();
        
        if (result.queued) {
          debug('‚è≥ Chips queued for next hand');
          alert(`‚è≥ ${playerName}'s chips will update to $${newAmount.toLocaleString()} at the end of this hand`);
        } else {
          debug('‚úÖ Chips adjusted');
          alert(`‚úÖ ${playerName}'s chips updated to $${newAmount.toLocaleString()}`);
        }
        
        // Refresh to show updated chips
        loadRoom();
        loadHostControls();
        
      } catch (error) {
        console.error('Error adjusting chips:', error);
        alert(`‚ùå Failed: ${error.message}`);
      }
    }
    
    // ============================================
    // HOST CONTROL ENHANCEMENTS
    // ============================================
    
    let gamePaused = false;
    let actionTimerSeconds = 0;
    let roomLocked = false;
    
    // Toggle Room Lock
    async function toggleRoomLock() {
      roomLocked = !roomLocked;
      const btn = document.getElementById('lockBtnText');
      
      try {
        const response = await fetch('/api/engine/host-controls/room-lock', {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            roomId, 
            hostId: userId, 
            locked: roomLocked 
          })
        });
        
        if (!response.ok) throw new Error('Failed to toggle room lock');
        
        if (roomLocked) {
          btn.textContent = 'UNLOCK ROOM';
          alert('üîí Room locked. No new players can join.');
        } else {
          btn.textContent = 'LOCK ROOM';
          alert('üîì Room unlocked. Players can join again.');
        }
        
        debug('üîí Room lock toggled:', roomLocked);
        
      } catch (error) {
        console.error('Error toggling room lock:', error);
        alert('‚ùå Failed to toggle room lock.');
        roomLocked = !roomLocked; // Revert
      }
    }
    
    // Open Kick Player Modal (simplified - just shows list in existing UI)
    function openKickPlayerModal() {
      alert('üí° Use the KICK buttons next to each player in the Current Players section below');
      // Scroll to player list
      document.getElementById('hostPlayerList')?.scrollIntoView({ behavior: 'smooth' });
    }
    
    // Toggle Pause Game
    async function togglePauseGame() {
      const btn = document.getElementById('pauseGameBtn');
      gamePaused = !gamePaused;
      
      if (gamePaused) {
        btn.querySelector('.btn-text').textContent = 'RESUME GAME';
        btn.classList.add('paused');
        alert('‚è∏Ô∏è Game paused. Players cannot take actions.');
      } else {
        btn.querySelector('.btn-text').textContent = 'PAUSE GAME';
        btn.classList.remove('paused');
        alert('‚ñ∂Ô∏è Game resumed. Players can continue.');
      }
      
      // TODO: Implement backend pause/resume logic
      // Will need to broadcast pause state to all players via socket
      debug('‚è∏Ô∏è Game pause toggled:', gamePaused);
    }
    
    // Force Next Hand
    async function forceNextHand() {
      const confirmed = confirm('‚è≠Ô∏è Skip to next hand?\n\nThis will end the current hand immediately and move to the next one.\n\nContinue?');
      if (!confirmed) return;
      
      try {
        const response = await fetch('/api/engine/host-controls/force-next-hand', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ roomId, hostId: userId })
        });
        
        if (!response.ok) throw new Error('Failed to force next hand');
        
        alert('‚è≠Ô∏è Moving to next hand...');
        loadRoom();
        
      } catch (error) {
        console.error('Error forcing next hand:', error);
        alert('‚ùå Failed to skip hand. Ensure game is in progress.');
      }
    }
    
    // Set Action Timer
    function setActionTimer(seconds) {
      actionTimerSeconds = seconds;
      
      // Update display (both old and new compact display)
      const display = document.getElementById('actionTimerDisplay');
      if (display) {
      display.textContent = seconds === 0 ? 'OFF' : `${seconds}s`;
      }
      
      // Update button states (old, compact, and tiny buttons)
      document.querySelectorAll('.timer-btn, .timer-btn-compact, .timer-btn-tiny').forEach(btn => {
        btn.classList.remove('active');
        const btnValue = btn.textContent.trim();
        if ((seconds === 0 && btnValue === 'OFF') || 
            (btnValue === `${seconds}s`)) {
          btn.classList.add('active');
        }
      });
      
      // Save to localStorage
      localStorage.setItem('pokergeek_action_timer', seconds);
      
      debug('‚è±Ô∏è Action timer set to:', seconds === 0 ? 'OFF' : `${seconds}s`);
      
      // TODO: Implement backend timer logic
      // Will need to track time per player action and auto-fold on timeout
    }
    
    // Toggle Auto-Start
    async function toggleAutoStart() {
      const checkbox = document.getElementById('autoStartToggle');
      const autoStart = checkbox.checked;
      
      try {
        const response = await fetch('/api/engine/host-controls/toggle-autostart', {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            roomId,
            hostId: userId,
            autoStartEnabled: autoStart
          })
        });
        
        if (!response.ok) {
          throw new Error('Failed to update auto-start setting');
        }
        
        localStorage.setItem('pokergeek_auto_start', autoStart);
        
        if (autoStart) {
          showToast('‚úÖ Auto-start enabled - hands will start automatically', 'success');
          debug('üîÑ Auto-start enabled');
        } else {
          showToast('‚èπÔ∏è Auto-start disabled - use Start Hand button', 'info');
          debug('‚èπÔ∏è Auto-start disabled');
        }
      } catch (error) {
        console.error('Error toggling auto-start:', error);
        // Revert checkbox
        checkbox.checked = !autoStart;
        showToast('‚ùå Failed to update auto-start setting', 'error');
      }
    }
    
    // Toggle Spectator Mode
    function toggleSpectatorMode() {
      const checkbox = document.getElementById('spectatorToggle');
      const enabled = checkbox.checked;
      
      localStorage.setItem('pokergeek_spectator_mode', enabled);
      
      if (enabled) {
        debug('üëÅÔ∏è Spectator mode enabled');
      } else {
        debug('üö´ Spectator mode disabled');
      }
    }
    
    // Reset All Stacks
    async function resetAllStacks() {
      const confirmed = confirm('üîÑ RESET ALL STACKS?\n\nThis will:\n- Set all players back to starting chips\n- Keep players seated\n- Not affect current hand\n\nContinue?');
      if (!confirmed) return;
      
      try {
        const response = await fetch('/api/engine/host-controls/reset-stacks', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ roomId, hostId: userId })
        });
        
        if (!response.ok) throw new Error('Failed to reset stacks');
        
        alert('üîÑ All player stacks reset to starting amount!');
        loadRoom();
        loadHostControls();
        
      } catch (error) {
        console.error('Error resetting stacks:', error);
        alert('‚ùå Failed to reset stacks.');
      }
    }
    
    // End Game
    async function endGame() {
      const confirmed = confirm('üõë END GAME?\n\nThis will:\n- End current game immediately\n- Clear all player seats\n- Return to lobby\n\nThis CANNOT be undone.\n\nContinue?');
      if (!confirmed) return;
      
      const doubleCheck = confirm('‚ö†Ô∏è Are you ABSOLUTELY sure?\n\nAll game progress will be lost.');
      if (!doubleCheck) return;
      
      try {
        const response = await fetch('/api/engine/host-controls/end-game', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ roomId, hostId: userId })
        });
        
        if (!response.ok) throw new Error('Failed to end game');
        
        alert('üõë Game ended. Returning to lobby...');
        window.location.href = '/';
        
      } catch (error) {
        console.error('Error ending game:', error);
        alert('‚ùå Failed to end game.');
      }
    }
    
    // ============================================
    // TABLE COLOR (All Players)
    // ============================================
    function changeFeltColor(color) {
      document.body.setAttribute('data-felt', color);
      localStorage.setItem('pokergeek_felt_color', color);
      
      // Update active button
      document.querySelectorAll('.color-btn').forEach(btn => {
        btn.classList.remove('active');
        if (btn.dataset.color === color) {
          btn.classList.add('active');
        }
      });
      
      debug('üé® Felt color changed:', color);
    }
    
    // 4-Color Deck Toggle
    function toggleFourColorDeck(enabled) {
      localStorage.setItem('pokergeek_four_color', enabled);
      debug('üÉè 4-Color Deck:', enabled);
      // Implementation will be added when designs are ready
    }
    
    // Card Back Design
    function changeCardBack(design) {
      localStorage.setItem('pokergeek_card_back', design);
      debug('üé¥ Card back changed:', design);
      // Implementation will be added when designs are ready
    }
    
    // Animation Speed
    function changeAnimSpeed(speed) {
      const speeds = { fast: 200, normal: 400, slow: 600 };
      document.documentElement.style.setProperty('--anim-speed', speeds[speed] + 'ms');
      localStorage.setItem('pokergeek_anim_speed', speed);
      debug('‚ö° Animation speed:', speed);
    }
    
    // Auto-Muck Toggle
    function toggleAutoMuck(enabled) {
      localStorage.setItem('pokergeek_auto_muck', enabled);
      debug('üôà Auto-muck:', enabled);
    }
    
    // Chip Display Format
    function changeChipFormat(format) {
      localStorage.setItem('pokergeek_chip_format', format);
      debug('üí∞ Chip format:', format);
      // Refresh chip displays on seats
      refreshChipDisplays();
    }
    
    // Format chip amount based on selected format
    function formatChipAmount(amount, format = null) {
      if (!format) {
        format = localStorage.getItem('pokergeek_chip_format') || 'full';
      }
      
      switch (format) {
        case 'compact':
          if (amount >= 1000000) {
            return `$${(amount / 1000000).toFixed(1)}M`;
          } else if (amount >= 1000) {
            return `$${(amount / 1000).toFixed(1)}K`;
          }
          return `$${amount.toLocaleString()}`;
        
        case 'bigblinds':
          // Get big blind from room data or current game state
          let bigBlind = 20; // Default fallback
          
          // Try to get from room data first (most reliable)
          const roomData = window.currentRoomData;
          if (roomData && roomData.room && roomData.room.bigBlind) {
            bigBlind = roomData.room.bigBlind;
          } else if (currentGameState) {
            // Try to get from game state
            // Check if we can infer from current bet (if at preflop, currentBet is BB)
            if (currentGameState.street === 'PREFLOP' && currentGameState.currentBet) {
              bigBlind = currentGameState.currentBet;
            } else if (currentGameState.bbPosition !== undefined) {
              // Try to get BB amount from players array
              const bbPlayer = currentGameState.players.find(p => p.seatIndex === currentGameState.bbPosition);
              if (bbPlayer && bbPlayer.bet) {
                bigBlind = bbPlayer.bet;
              }
            }
          }
          
          if (bigBlind > 0) {
            const bbCount = Math.round(amount / bigBlind);
            return `${bbCount} BB`;
          }
          return `$${amount.toLocaleString()}`;
        
        case 'full':
        default:
          return `$${amount.toLocaleString()}`;
      }
    }
    
    // Refresh all chip displays on the table
    function refreshChipDisplays() {
      // Refresh seat chips
      const seats = document.querySelectorAll('.seat-chips');
      seats.forEach(chipEl => {
        const seatDiv = chipEl.closest('.seat');
        if (!seatDiv) return;
        
        const seatIndex = parseInt(seatDiv.dataset.seatIndex);
        if (isNaN(seatIndex)) return;
        
        // Get chip amount from text content or data attribute
        const currentText = chipEl.textContent;
        const amountMatch = currentText.match(/\$?([\d,]+)/);
        if (amountMatch) {
          const amount = parseInt(amountMatch[1].replace(/,/g, ''));
          if (!isNaN(amount)) {
            // Format with green dollar sign
            const formatted = formatChipAmount(amount);
            chipEl.innerHTML = `<span style="color: #00ff88;">$</span>${formatted.replace('$', '').trim()}`;
          }
        }
      });
      
      // Refresh pot display
      const potEl = document.getElementById('pot');
      if (potEl) {
        const potText = potEl.textContent;
        const potMatch = potText.match(/\$?([\d,]+)/);
        if (potMatch) {
          const potAmount = parseInt(potMatch[1].replace(/,/g, ''));
          if (!isNaN(potAmount)) {
            const format = localStorage.getItem('pokergeek_chip_format') || 'full';
            // Pot always shows full format (not BB)
            if (format === 'bigblinds') {
              potEl.textContent = formatChipAmount(potAmount, 'full');
            } else {
              potEl.textContent = formatChipAmount(potAmount);
            }
          }
        }
      }
      
      // Refresh player list chips in host controls
      const playerChips = document.querySelectorAll('.chips-badge');
      playerChips.forEach(chipEl => {
        const chipText = chipEl.textContent;
        const amountMatch = chipText.match(/\$?([\d,]+)/);
        if (amountMatch) {
          const amount = parseInt(amountMatch[1].replace(/,/g, ''));
          if (!isNaN(amount)) {
            // Format with green dollar sign
            const formatted = formatChipAmount(amount);
            chipEl.innerHTML = `<span style="color: #00ff88;">$</span>${formatted.replace('$', '').trim()}`;
      }
        }
      });
    }
    
    // Action Confirmation Toggle
    function toggleActionConfirm(enabled) {
      localStorage.setItem('pokergeek_action_confirm', enabled);
      debug('‚ö†Ô∏è Action confirmation:', enabled);
    }
    
    // ============================================
    // SANDBOX MODE FUNCTIONS
    // ============================================
    
    // Toggle sandbox mode visibility
    function toggleSandboxMode(enabled) {
      const controls = document.getElementById('sandboxControls');
      if (enabled) {
        controls.style.display = 'block';
        // Get seats from stored data
        const seats = window.currentSeatsData?.seats || window.currentSeatsData || [];
        console.log('üß™ [SANDBOX] Toggled ON, rendering with seats:', seats);
        renderSandboxPlayerList(seats);
      } else {
        controls.style.display = 'none';
      }
    }
    
    // Update sandbox section visibility based on game state
    function updateSandboxVisibility(hasActiveGame, seats) {
      const sandboxSection = document.getElementById('sandboxSection');
      if (!sandboxSection) return;
      
      // Only show sandbox when no active game and user is host
      if (!hasActiveGame && isHost) {
        sandboxSection.style.display = 'block';
        // Refresh player list if sandbox is enabled
        if (document.getElementById('sandboxModeToggle')?.checked) {
          renderSandboxPlayerList(seats);
        }
      } else {
        sandboxSection.style.display = 'none';
      }
    }
    
    // Render player list for sandbox editing
    function renderSandboxPlayerList(seats) {
      const container = document.getElementById('sandboxPlayerList');
      if (!container) {
        console.error('üß™ [SANDBOX] Container not found!');
        return;
      }
      
      // Get seats from parameter or fetch from stored data
      if (!seats) {
        // Try to get from current seats data (stored in loadRoom)
        const seatsData = window.currentSeatsData;
        console.log('üß™ [SANDBOX] No seats param, fetching from window.currentSeatsData:', seatsData);
        if (seatsData && seatsData.seats) {
          seats = seatsData.seats; // Use seats array from API response
        } else if (Array.isArray(seatsData)) {
          seats = seatsData;
        } else {
          seats = [];
        }
      }
      
      // Filter out nulls (seats array is sparse - has nulls for empty seats)
      const occupiedSeats = Array.isArray(seats) ? seats.filter(s => s && s.userId) : [];
      
      console.log('üß™ [SANDBOX] Rendering player list:', { 
        seatsArray: seats, 
        occupiedSeats,
        count: occupiedSeats.length 
      });
      
      if (occupiedSeats.length === 0) {
        container.innerHTML = '<p style="color: #9aa3b2; font-size: 0.85rem;">No players seated. Seat players first.</p>';
        return;
      }
      
      let html = '<h5 style="font-size: 0.9rem; color: #e9eef7; margin-bottom: 12px;">üë• Set Player Cards & Stacks</h5>';
      
      occupiedSeats.forEach(seat => {
        if (!seat || !seat.userId) return; // Skip empty seats (shouldn't happen after filter, but safety check)
        
        const nickname = seat.nickname || `Player ${seat.seatIndex + 1}`;
        const currentChips = seat.chips || seat.chipsInPlay || seat.chips_in_play || 1000;
        
        html += `
          <div class="sandbox-player-item" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.1); border-radius: 6px; padding: 12px; margin-bottom: 8px;">
            <h6 style="margin: 0 0 8px 0; font-size: 0.9rem; color: #00d4aa;">Seat ${seat.seatIndex + 1}: ${nickname}</h6>
            <div class="sandbox-player-controls" style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px;">
              <div>
                <small style="color: #9aa3b2; font-size: 0.75rem;">Card 1:</small>
                <input type="text" 
                       id="sandboxCard1_${seat.seatIndex}" 
                       placeholder="Ah" 
                       maxlength="2" 
                       class="sandbox-card-input" 
                       style="width: 100%; padding: 6px; text-align: center; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.2); border-radius: 4px; color: #e9eef7; font-family: 'Courier New', monospace; font-size: 0.9rem;">
              </div>
              <div>
                <small style="color: #9aa3b2; font-size: 0.75rem;">Card 2:</small>
                <input type="text" 
                       id="sandboxCard2_${seat.seatIndex}" 
                       placeholder="Kd" 
                       maxlength="2" 
                       class="sandbox-card-input" 
                       style="width: 100%; padding: 6px; text-align: center; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.2); border-radius: 4px; color: #e9eef7; font-family: 'Courier New', monospace; font-size: 0.9rem;">
              </div>
              <div>
                <small style="color: #9aa3b2; font-size: 0.75rem;">Stack:</small>
                <input type="number" 
                       id="sandboxStack_${seat.seatIndex}" 
                       value="${currentChips}" 
                       min="0" 
                       class="form-input compact" 
                       style="width: 100%; padding: 6px;">
              </div>
            </div>
          </div>
        `;
      });
      
      container.innerHTML = html;
    }
    
    // Collect sandbox config from form inputs
    function collectSandboxConfig() {
      const players = [];
      const boardCards = [];
      
      // Get all seated players from seats data (filter out nulls - seats array is sparse)
      const seatsArray = window.currentSeatsData?.seats || window.currentSeatsData || [];
      const seats = Array.isArray(seatsArray) ? seatsArray.filter(s => s && s.userId) : [];
      console.log('üß™ [SANDBOX] Collecting config, seats:', seats, 'from:', seatsArray);
      
      if (!seats || seats.length === 0) {
        console.error('üß™ [SANDBOX] No seats data found!', { 
          currentSeatsData: window.currentSeatsData,
          seatsArray,
          seats 
        });
        return { players: [], boardCards: null };
      }
      
      seats.forEach((seat, idx) => {
        if (!seat || !seat.userId) {
          console.log(`üß™ [SANDBOX] Skipping invalid seat at index ${idx}:`, seat);
          return;
        }
        
        const card1Id = `sandboxCard1_${seat.seatIndex}`;
        const card2Id = `sandboxCard2_${seat.seatIndex}`;
        const stackId = `sandboxStack_${seat.seatIndex}`;
        
        const card1El = document.getElementById(card1Id);
        const card2El = document.getElementById(card2Id);
        const stackEl = document.getElementById(stackId);
        
        console.log(`üß™ [SANDBOX] Seat ${seat.seatIndex + 1}:`, {
          card1El: !!card1El,
          card2El: !!card2El,
          stackEl: !!stackEl,
          card1Value: card1El?.value,
          card2Value: card2El?.value
        });
        
        if (!card1El || !card2El || !stackEl) {
          console.warn(`üß™ [SANDBOX] Missing inputs for seat ${seat.seatIndex}`);
          return;
        }
        
        const card1 = card1El.value.trim().toUpperCase();
        const card2 = card2El.value.trim().toUpperCase();
        const stack = parseInt(stackEl.value) || seat.chips || seat.chipsInPlay || seat.chips_in_play || 1000;
        
        // Only include if both cards are set
        if (card1 && card2 && card1.length === 2 && card2.length === 2) {
          players.push({
            seatIndex: seat.seatIndex,
            userId: seat.userId,
            holeCards: [card1, card2],
            chips: stack
          });
          console.log(`üß™ [SANDBOX] Added player ${seat.seatIndex}:`, { card1, card2, stack });
        } else {
          console.log(`üß™ [SANDBOX] Skipping seat ${seat.seatIndex} - cards not set:`, { card1, card2 });
        }
      });
      
      // Collect board cards (optional)
      const flop1 = document.getElementById('sandboxFlop1')?.value.trim().toUpperCase();
      const flop2 = document.getElementById('sandboxFlop2')?.value.trim().toUpperCase();
      const flop3 = document.getElementById('sandboxFlop3')?.value.trim().toUpperCase();
      const turn = document.getElementById('sandboxTurn')?.value.trim().toUpperCase();
      const river = document.getElementById('sandboxRiver')?.value.trim().toUpperCase();
      
      if (flop1 && flop2 && flop3) {
        boardCards.push(flop1, flop2, flop3);
        if (turn && turn.length === 2) boardCards.push(turn);
        if (river && river.length === 2) boardCards.push(river);
      }
      
      return {
        players,
        boardCards: boardCards.length > 0 ? boardCards : null
      };
    }
    
    // Hotkeys Toggle
    let hotkeysEnabled = false;
    function toggleHotkeys(enabled) {
      hotkeysEnabled = enabled;
      localStorage.setItem('pokergeek_hotkeys', enabled);
      debug('‚å®Ô∏è Hotkeys:', enabled);
      
      if (enabled) {
        document.addEventListener('keydown', handleHotkey);
      } else {
        document.removeEventListener('keydown', handleHotkey);
      }
    }
    
    // Hotkey Handler
    function handleHotkey(e) {
      if (!hotkeysEnabled) return;
      
      // Don't trigger if typing in input
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
      
      const key = e.key.toLowerCase();
      const foldBtn = document.getElementById('foldBtn');
      const callBtn = document.getElementById('callBtn');
      const raiseBtn = document.getElementById('raiseBtn');
      
      if (key === 'f' && foldBtn && !foldBtn.disabled) {
        e.preventDefault();
        foldBtn.click();
      } else if (key === 'c' && callBtn && !callBtn.disabled) {
        e.preventDefault();
        callBtn.click();
      } else if (key === 'r' && raiseBtn && !raiseBtn.disabled) {
        e.preventDefault();
        raiseBtn.click();
      }
    }
    
    // Load all saved settings on page load
    (function loadSavedFeltColor() {
      const savedColor = localStorage.getItem('pokergeek_felt_color') || 'green';
      document.body.setAttribute('data-felt', savedColor);
      
      // Set active button (wait for DOM to be ready)
      setTimeout(() => {
        const activeBtn = document.querySelector(`.color-btn[data-color="${savedColor}"]`);
        if (activeBtn) activeBtn.classList.add('active');
      }, 100);
      
      debug('üé® Loaded saved felt color:', savedColor);
    })();
    
    // ============================================
    // CIRCULAR SEAT POSITIONING (Proper Ellipse)
    // ============================================
    function calculateSeatPositions() {
      // üîí HARDCODED POSITIONS - Locked from UI sandbox tool (final lock)
      // All seats: 210√ó210px uniform size (slightly smaller, no blur)
      // Used for: 10 players OR lobby mode (all 10 seats visible)
      return [
        { index: 0, x: 667, y: 150, width: 210, height: 210 },
        { index: 1, x: 946, y: 171, width: 210, height: 210 },
        { index: 2, x: 1179, y: 358, width: 210, height: 210 },
        { index: 3, x: 1179, y: 625, width: 210, height: 210 },
        { index: 4, x: 946, y: 829, width: 210, height: 210 },
        { index: 5, x: 667, y: 842, width: 210, height: 210 },
        { index: 6, x: 388, y: 829, width: 210, height: 210 },
        { index: 7, x: 163, y: 625, width: 210, height: 210 },
        { index: 8, x: 163, y: 358, width: 210, height: 210 },
        { index: 9, x: 388, y: 171, width: 210, height: 210 }
      ];
    }
    
    // ============================================
    // DYNAMIC SEAT POSITIONING (Based on Occupied Seats)
    // ============================================
    function calculateDynamicSeatPositions(occupiedSeatIndices, gameState = null) {
      // Sort occupied seats to maintain order
      const sortedSeats = [...occupiedSeatIndices].sort((a, b) => a - b);
      const count = sortedSeats.length;
      
      // üîí LOCKED POSITIONS FOR 2 PLAYERS (with perspective fix)
      if (count === 2) {
        // Find current user's seat
        let userSeatIndex = null;
        sortedSeats.forEach(seatIdx => {
          const seatEl = document.querySelector(`.seat[data-seat-index="${seatIdx}"]`);
          if (seatEl && seatEl.classList.contains('me')) {
            userSeatIndex = seatIdx;
          }
        });
        
        const topPosition = { x: 806, y: 206, width: 267, height: 267 };
        const bottomPosition = { x: 806, y: 945, width: 267, height: 267 };
        
        const positions = [];
        sortedSeats.forEach((seatIndex) => {
          const isUserSeat = userSeatIndex === seatIndex;
          positions.push({
            index: seatIndex,
            x: isUserSeat ? bottomPosition.x : topPosition.x,
            y: isUserSeat ? bottomPosition.y : topPosition.y,
            width: isUserSeat ? bottomPosition.width : topPosition.width,
            height: isUserSeat ? bottomPosition.height : topPosition.height
          });
        });
        
        return positions;
      }
      
      // üîí LOCKED POSITIONS FOR 3 PLAYERS
      if (count === 3) {
        const positions = [];
        sortedSeats.forEach((seatIndex) => {
          const pos = [
            { index: 0, x: 802, y: 928, width: 280, height: 280 },
            { index: 1, x: 1251, y: 336, width: 280, height: 280 },
            { index: 2, x: 366, y: 336, width: 280, height: 280 },
          ].find(p => p.index === seatIndex);
          if (pos) positions.push(pos);
        });
        return positions;
      }
      
      // üîí LOCKED POSITIONS FOR 4 PLAYERS
      if (count === 4) {
        const positions = [];
        sortedSeats.forEach((seatIndex) => {
          const pos = [
            { index: 0, x: 799, y: 924, width: 280, height: 280 },
            { index: 1, x: 1321, y: 572, width: 280, height: 280 },
            { index: 2, x: 796, y: 256, width: 280, height: 280 },
            { index: 3, x: 284, y: 593, width: 280, height: 280 },
          ].find(p => p.index === seatIndex);
          if (pos) positions.push(pos);
        });
        return positions;
      }
      
      // üîí LOCKED POSITIONS FOR 5 PLAYERS
      if (count === 5) {
        const positions = [];
        sortedSeats.forEach((seatIndex) => {
          const pos = [
            { index: 0, x: 800, y: 965, width: 290, height: 290 },
            { index: 1, x: 1097, y: 206, width: 270, height: 270 },
            { index: 2, x: 1375, y: 707, width: 290, height: 290 },
            { index: 3, x: 249, y: 721, width: 290, height: 290 },
            { index: 4, x: 532, y: 214, width: 290, height: 290 },
          ].find(p => p.index === seatIndex);
          if (pos) positions.push(pos);
        });
        return positions;
      }
      
      // üîí LOCKED POSITIONS FOR 6 PLAYERS
      if (count === 6) {
        const positions = [];
        sortedSeats.forEach((seatIndex) => {
          const pos = [
            { index: 0, x: 798, y: 940, width: 265, height: 265 },
            { index: 1, x: 1296, y: 355, width: 265, height: 265 },
            { index: 2, x: 1312, y: 889, width: 265, height: 265 },
            { index: 3, x: 799, y: 243, width: 265, height: 265 },
            { index: 4, x: 334, y: 912, width: 265, height: 265 },
            { index: 5, x: 323, y: 345, width: 265, height: 265 },
          ].find(p => p.index === seatIndex);
          if (pos) positions.push(pos);
        });
        return positions;
      }
      
      // üîí LOCKED POSITIONS FOR 7 PLAYERS
      if (count === 7) {
        const positions = [];
        sortedSeats.forEach((seatIndex) => {
          const pos = [
            { index: 0, x: 799, y: 960, width: 242, height: 242 },
            { index: 1, x: 1049, y: 219, width: 242, height: 242 },
            { index: 2, x: 1400, y: 513, width: 242, height: 242 },
            { index: 3, x: 1195, y: 923, width: 242, height: 242 },
            { index: 4, x: 394, y: 919, width: 242, height: 242 },
            { index: 5, x: 226, y: 513, width: 242, height: 242 },
            { index: 6, x: 573, y: 223, width: 242, height: 242 },
          ].find(p => p.index === seatIndex);
          if (pos) positions.push(pos);
        });
        return positions;
      }
      
      // üîí LOCKED POSITIONS FOR 8 PLAYERS
      if (count === 8) {
        const positions = [];
        sortedSeats.forEach((seatIndex) => {
          const pos = [
            { index: 0, x: 796, y: 972, width: 221, height: 221 },
            { index: 1, x: 1166, y: 281, width: 221, height: 221 },
            { index: 2, x: 1443, y: 601, width: 221, height: 221 },
            { index: 3, x: 1169, y: 956, width: 221, height: 221 },
            { index: 4, x: 811, y: 215, width: 221, height: 221 },
            { index: 5, x: 458, y: 934, width: 221, height: 221 },
            { index: 6, x: 170, y: 616, width: 221, height: 221 },
            { index: 7, x: 426, y: 268, width: 221, height: 221 },
          ].find(p => p.index === seatIndex);
          if (pos) positions.push(pos);
        });
        return positions;
      }
      
      // üîí LOCKED POSITIONS FOR 9 PLAYERS
      if (count === 9) {
        const positions = [];
        sortedSeats.forEach((seatIndex) => {
          const pos = [
            { index: 0, x: 795, y: 974, width: 220, height: 220 },
            { index: 1, x: 1304, y: 339, width: 220, height: 220 },
            { index: 2, x: 1414, y: 638, width: 220, height: 220 },
            { index: 3, x: 1126, y: 953, width: 220, height: 220 },
            { index: 4, x: 975, y: 252, width: 220, height: 220 },
            { index: 5, x: 653, y: 246, width: 220, height: 220 },
            { index: 6, x: 444, y: 952, width: 220, height: 220 },
            { index: 7, x: 185, y: 624, width: 220, height: 220 },
            { index: 8, x: 350, y: 311, width: 220, height: 220 },
          ].find(p => p.index === seatIndex);
          if (pos) positions.push(pos);
        });
        return positions;
      }
      
      // üîí LOCKED POSITIONS FOR 10 PLAYERS
      if (count === 10) {
        const positions = [];
        sortedSeats.forEach((seatIndex) => {
          const pos = [
            { index: 0, x: 800, y: 180, width: 232, height: 232 },
            { index: 1, x: 1135, y: 205, width: 232, height: 232 },
            { index: 2, x: 1415, y: 430, width: 232, height: 232 },
            { index: 3, x: 1415, y: 750, width: 232, height: 232 },
            { index: 4, x: 1135, y: 995, width: 232, height: 232 },
            { index: 5, x: 800, y: 1010, width: 232, height: 232 },
            { index: 6, x: 466, y: 995, width: 232, height: 232 },
            { index: 7, x: 196, y: 750, width: 232, height: 232 },
            { index: 8, x: 196, y: 430, width: 232, height: 232 },
            { index: 9, x: 466, y: 205, width: 232, height: 232 },
          ].find(p => p.index === seatIndex);
          if (pos) positions.push(pos);
        });
        return positions;
      }
      
      // Fallback: return empty array (shouldn't reach here with 2-10 players)
      console.warn(`‚ö†Ô∏è No locked positions for ${count} players`);
      return [];
    }

    function applySeatPositions() {
      // Get the table's current scale factor (accounts for zoom lock)
      const table = document.getElementById('pokerTable');
      let scale = 1;
      if (table) {
        const computedStyle = getComputedStyle(table);
        const transform = computedStyle.transform;
        if (transform && transform !== 'none') {
          // Extract scale from matrix or scale() transform
          const matrixMatch = transform.match(/matrix\(([^)]+)\)/);
          if (matrixMatch) {
            const values = matrixMatch[1].split(',').map(v => parseFloat(v.trim()));
            // CSS transform matrix: [scaleX, skewY, skewX, scaleY, translateX, translateY]
            scale = values[0] || 1; // Use scaleX (should be same as scaleY for uniform scale)
          } else {
            const scaleMatch = transform.match(/scale\(([^)]+)\)/);
            if (scaleMatch) {
              scale = parseFloat(scaleMatch[1]);
            }
          }
        }
      }
      
      // Determine if we should use dynamic positioning
      const isGameActive = currentGameState && 
        (currentGameState.status === 'IN_PROGRESS' || currentGameState.status === 'COMPLETED');
      
      // Get occupied seat indices
      // CRITICAL: When hand is active, use players from gameState (who are actually in the hand)
      // Otherwise, use DOM seats (for lobby/preview)
      let occupiedSeats = [];
      if (isGameActive && currentGameState.players && currentGameState.players.length > 0) {
        // Hand is active - use players from gameState (actual players in the hand)
        occupiedSeats = currentGameState.players
          .map(p => p.seatIndex)
          .filter(idx => idx !== undefined && idx !== null);
        debug('üéØ Using gameState players for positioning', { 
          playerCount: occupiedSeats.length, 
          seats: occupiedSeats.sort((a,b) => a-b) 
        });
      } else {
        // Lobby/preview - use DOM seats
        document.querySelectorAll('.seat:not(.empty)').forEach(seat => {
          const index = parseInt(seat.dataset.seatIndex);
          if (!isNaN(index)) {
            occupiedSeats.push(index);
          }
        });
      }
      
      // Use dynamic positioning ONLY after a hand starts:
      // - Hand must be active (IN_PROGRESS or COMPLETED)
      // - AND we have 2-9 players in the hand
      // - AND user is NOT a spectator (spectators always see all 10 seats)
      // In lobby (before hand starts), always use hardcoded positions
      const useDynamic = isGameActive && occupiedSeats.length >= 2 && occupiedSeats.length < 10 && !isSpectator;
      
      // Get positions (dynamic or hardcoded)
      const dynamicPositions = useDynamic 
        ? calculateDynamicSeatPositions(occupiedSeats, currentGameState)
        : null;
      
      const hardcodedPositions = calculateSeatPositions();
      
      // Apply positions to occupied seats (dynamic if game active, hardcoded otherwise)
      const positionsToApply = useDynamic ? dynamicPositions : hardcodedPositions;
      
      positionsToApply.forEach(pos => {
        const seat = document.querySelector(`.seat[data-seat-index="${pos.index}"]`);
        
        // ARCHITECTURAL FIX: Position ALL seats for spectators (empty + occupied)
        // Spectators need to see the full table layout (all 10 seats) to understand where they can claim
        // Active players only see occupied seats (compact dynamic layout)
        const shouldPosition = seat && (isSpectator || !seat.classList.contains('empty'));
        
        if (shouldPosition) {
          // CRITICAL: Dynamic positions from calculateDynamicSeatPositions() are in TABLE COORDINATES (unscaled)
          // Hardcoded positions from calculateSeatPositions() are in VIEWPORT COORDINATES (scaled)
          // We need to handle them differently:
          const isDynamic = useDynamic;
          
          let tableX, tableY, tableWidth, tableHeight;
          
          if (isDynamic) {
            // Dynamic positions are already in table coordinates (unscaled) - use directly
            tableX = pos.x;
            tableY = pos.y;
            tableWidth = pos.width;
            tableHeight = pos.height;
          } else {
            // Hardcoded positions are in viewport coordinates (scaled) - convert to table coords
            tableX = pos.x / scale;
            tableY = pos.y / scale;
            tableWidth = pos.width / scale;
            tableHeight = pos.height / scale;
          }
          
          // Set center position (left/top are center positions because of translate(-50%, -50%))
          seat.style.left = `${tableX}px`;
          seat.style.top = `${tableY}px`;
          
          // Clear any transform scale, keep only translate for centering
          seat.style.transform = 'translate(-50%, -50%)';
          
          // Set size on seat container
          if (tableWidth) seat.style.width = `${tableWidth}px`;
          if (tableHeight) seat.style.height = `${tableHeight}px`;
          
          // Also apply size to the actual tile element (this is what renders)
          const seatTile = seat.querySelector('.seat-tile');
          if (seatTile && tableWidth && tableHeight) {
            seatTile.style.width = `${tableWidth}px`;
            seatTile.style.height = `${tableHeight}px`;
            
            // Set CSS custom properties for proportional scaling
            // Base size is 210px (default), scale factor is tileWidth / 210
            const scaleFactor = tableWidth / 210;
            seatTile.style.setProperty('--tile-scale', scaleFactor);
            seatTile.style.setProperty('--tile-width', `${tableWidth}px`);
          }
        }
      });
      
      // For empty seats when using hardcoded layout (lobby OR spectators OR 10 players)
      // Position all empty seats using hardcoded positions
      if (!useDynamic) {
        hardcodedPositions.forEach(pos => {
          if (!occupiedSeats.includes(pos.index)) {
            const seat = document.querySelector(`.seat[data-seat-index="${pos.index}"]`);
            if (seat && seat.classList.contains('empty')) {
              const tableX = pos.x / scale;
              const tableY = pos.y / scale;
              
              seat.style.left = `${tableX}px`;
              seat.style.top = `${tableY}px`;
              seat.style.transform = 'translate(-50%, -50%)';
              seat.style.width = `${pos.width / scale}px`;
              seat.style.height = `${pos.height / scale}px`;
              
              const seatTile = seat.querySelector('.seat-tile');
              if (seatTile && pos.width && pos.height) {
                seatTile.style.width = `${pos.width / scale}px`;
                seatTile.style.height = `${pos.height / scale}px`;
                
                // Set CSS custom properties for proportional scaling (empty seats too)
                const scaleFactor = (pos.width / scale) / 210;
                seatTile.style.setProperty('--tile-scale', scaleFactor);
                seatTile.style.setProperty('--tile-width', `${pos.width / scale}px`);
              }
            }
        }
      });
      }
      
      debug('üìç Applied seat positions', { 
        dynamic: useDynamic, 
        occupiedCount: occupiedSeats.length,
        gameActive: isGameActive,
        isSpectator: isSpectator
      });
      
      // Update seat position classes for avatar/username positioning
      updateSeatPositionClasses();
      
      // Ensure chips are always inside tiles (consistency)
      document.querySelectorAll('.seat-chips').forEach(chips => {
        chips.classList.remove('heads-up-chips', 'heads-up-left', 'heads-up-right');
        const seatTile = chips.closest('.seat-tile');
        if (seatTile && !seatTile.contains(chips)) {
          seatTile.appendChild(chips);
        }
      });
    }
    
    // ============================================
    // UPDATE SEAT POSITION CLASSES (Top/Bottom)
    // ============================================
    function updateSeatPositionClasses() {
      // Table center Y is 600px (from zoom lock: 1600√ó1200px, center at 800,600)
      const tableCenterY = 600;
      
      document.querySelectorAll('.seat').forEach(seat => {
        // Remove existing position classes
        seat.classList.remove('seat-top', 'seat-bottom');
        
        // Get seat's Y position (from style.top, accounting for translate(-50%, -50%))
        const topValue = seat.style.top;
        if (topValue) {
          const seatY = parseFloat(topValue);
          if (!isNaN(seatY)) {
            // Top seats: Y < center, Bottom seats: Y >= center
            if (seatY < tableCenterY) {
              seat.classList.add('seat-top');
            } else {
              seat.classList.add('seat-bottom');
            }
          }
        }
      });
    }
    
    // ============================================
    // ZOOM LOCK SYSTEM
    // ============================================
    function setupZoomLock() {
      const wrapper = document.getElementById('tableWrapper');
      const table = document.getElementById('pokerTable');
      
      if (!wrapper || !table) {
        console.warn('‚ö†Ô∏è Zoom lock elements not found');
        return;
      }

      const updateScale = () => {
        const containerWidth = wrapper.clientWidth;
        const containerHeight = wrapper.clientHeight;
        const stageWidth = 1600;
        const stageHeight = 1200;

        const scaleX = containerWidth / stageWidth;
        const scaleY = containerHeight / stageHeight;
        const scale = Math.min(scaleX, scaleY);

        const scaledWidth = stageWidth * scale;
        const scaledHeight = stageHeight * scale;
        const offsetX = (containerWidth - scaledWidth) / 2;
        const offsetY = (containerHeight - scaledHeight) / 2;

        table.style.left = `${offsetX}px`;
        table.style.top = `${offsetY}px`;
        table.style.transform = `scale(${scale})`;
        
        debug('üîç Zoom lock updated', { scale, offsetX, offsetY });
        
        // Reapply seat positions after scale changes (to account for coordinate conversion)
        if (typeof applySeatPositions === 'function') {
          setTimeout(() => applySeatPositions(), 0);
        }
      };

      updateScale();
      window.addEventListener('resize', updateScale);
      new ResizeObserver(updateScale).observe(wrapper);
      
      debug('‚úÖ Zoom lock initialized');
    }
    
    // ============================================
    // INITIALIZE ON LOAD
    // ============================================
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        init();
        setupZoomLock();
      });
    } else {
      init();
      setupZoomLock();
    }
  </script>
  
  <!-- Liquid Glass SVG Filter - Required for glass distortion effect -->
  <svg xmlns="http://www.w3.org/2000/svg" width="0" height="0" style="position:absolute; overflow:hidden">
    <defs>
      <filter id="glass-distortion" x="0%" y="0%" width="100%" height="100%">
        <feTurbulence type="fractalNoise" baseFrequency="0.008 0.008" numOctaves="2" seed="92" result="noise" />
        <feGaussianBlur in="noise" stdDeviation="2" result="blurred" />
        <feDisplacementMap in="SourceGraphic" in2="blurred" scale="39" xChannelSelector="R" yChannelSelector="G" />
      </filter>
    </defs>
  </svg>
</body>
</html>


