<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PokerGeek - Minimal Table</title>
  <style>
    /* Design Tokens */
    :root {
      --bg: #0b0b12;
      --text: #e9eef7;
      --muted: #9aa3b2;
      --accent: #ff5100;
      --teal: #00d4aa;
      --error: #ff3b3b;
      --felt-current: #197a45;
      --font-main: "Inter", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      --font-mono: "JetBrains Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --shadow-md: 0 8px 18px rgba(0,0,0,.35);
      --shadow-lg: 0 12px 28px rgba(0,0,0,.45);
      --shadow-xl: 0 18px 44px rgba(0,0,0,.55);
    }

    /* Felt color presets */
    body[data-felt="green"] { --felt-current: #197a45; }
    body[data-felt="red"] { --felt-current: #6b1414; }
    body[data-felt="black"] { --felt-current: #1a1a1a; }
    body[data-felt="blue"] { --felt-current: #0f2942; }
    body[data-felt="grey"] { --felt-current: #2a2a2a; }
    body[data-felt="tan"] { --felt-current: #6b5642; }
    body[data-felt="purple"] { --felt-current: #3a1450; }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      background: #0b0b12;
      color: #e9eef7;
      font-family: 'Inter', system-ui, -apple-system, Arial, sans-serif;
      padding: 20px;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
    }
    
    /* ============================================ */
    /* ZOOM LOCK TABLE WRAPPER */
    /* ============================================ */
    .table-wrapper {
      width: 100%;
      min-height: 1000px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--bg);
      position: relative;
      overflow: visible;
      margin-bottom: 30px;
    }

    .poker-table {
      position: absolute;
      width: 1600px;
      height: 1200px;
      transform-origin: top left;
      pointer-events: auto;
      z-index: 0;
    }

    /* Oval Felt Background */
    .table-felt {
      position: absolute;
      inset: 24px;
      border-radius: 360px;
      border: 2px solid #0d1117;
      background: var(--felt-current);
      box-shadow: 
        inset 0 0 0 16px rgba(0,0,0,.35), 
        inset 0 0 80px rgba(0,0,0,.45);
      z-index: 0;
    }

    .table-felt::after {
      content: "";
      position: absolute;
      inset: -24px;
      border-radius: inherit;
      box-shadow: 0 16px 56px rgba(0,0,0,.55);
      pointer-events: none;
    }

    /* Board Center (Community Cards + Pot) */
    .board-center {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 16px;
      z-index: 5;
      pointer-events: none;
    }

    .community-cards-center {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      justify-content: center;
    }
    
    /* Community card styling */
    .community-cards-center .card-img {
      width: 110px;
      aspect-ratio: 5/7;
      border-radius: 10px;
      box-shadow: 
        0 0 30px rgba(255, 255, 255, 0.15),
        0 12px 40px rgba(0, 0, 0, 0.8);
      object-fit: cover;
      border: 2px solid rgba(255,255,255,0.3);
      transition: all 0.3s ease;
    }
    
    .community-cards-center .card-img:hover {
      transform: translateY(-4px);
      box-shadow: 
        0 0 40px rgba(255, 255, 255, 0.25),
        0 16px 50px rgba(0, 0, 0, 0.9);
    }
    
    /* Card entrance animation */
    @keyframes cardFlip {
      0% {
        transform: rotateY(90deg) scale(0.8);
        opacity: 0;
      }
      50% {
        transform: rotateY(45deg) scale(1.05);
      }
      100% {
        transform: rotateY(0deg) scale(1);
        opacity: 1;
      }
    }
    
    .community-cards-center .card-img.new-card {
      animation: cardFlip 0.5s ease-out forwards;
    }

    .pot-display-center {
      padding: 28px 56px;
      border-radius: 24px;
      background: linear-gradient(135deg, rgba(0,0,0,.98) 0%, rgba(20,20,30,.98) 100%);
      border: 3px solid rgba(255,215,0,.6);
      text-align: center;
      box-shadow: 
        inset 0 0 40px -10px rgba(255, 215, 0, 0.3),
        0 0 0 1px rgba(255,215,0,.3),
        0 0 60px rgba(255,215,0,.4),
        var(--shadow-xl);
      pointer-events: auto;
      backdrop-filter: blur(10px);
    }

    .pot-label {
      font-size: 14px;
      color: var(--muted);
      letter-spacing: .2em;
      font-weight: 800;
      margin-bottom: 8px;
      text-transform: uppercase;
      text-shadow: 0 2px 4px rgba(0,0,0,0.6);
    }

    .pot-amount {
      font-family: var(--font-mono);
      font-size: 52px;
      color: #ffd700;
      font-weight: 900;
      text-shadow: 
        0 0 20px rgba(255, 215, 0, 0.8),
        0 4px 12px rgba(0, 0, 0, 0.8);
      letter-spacing: 0.05em;
    }

    /* Seats Layer */
    .seats-layer {
      position: absolute;
      inset: 0;
      z-index: 10;
    }
    
    h1 {
      color: #ff5100;
      margin-bottom: 10px;
    }
    
    /* Clean Table Header */
    .table-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 24px;
      background: rgba(255,255,255,0.03);
      border-radius: 12px;
      margin-bottom: 20px;
      border: 1px solid rgba(255,255,255,0.08);
    }
    
    .room-code-display {
      display: flex;
      align-items: baseline;
      gap: 12px;
    }
    
    .room-code-label {
      color: rgba(255,255,255,0.5);
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 1px;
      font-weight: 600;
    }
    
    .room-code {
      color: #00d4aa;
      font-size: 1.8rem;
      font-weight: 700;
      letter-spacing: 2px;
      font-family: 'Courier New', monospace;
    }
    
    .connection-indicator {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .connection-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #ff3b3b;
      box-shadow: 0 0 12px rgba(255, 59, 59, 0.6);
      transition: all 0.3s ease;
    }
    
    .connection-indicator.connected .connection-dot {
      background: #00d4aa;
      box-shadow: 0 0 12px rgba(0, 212, 170, 0.6);
    }
    
    .seats-grid {
      position: relative;
      width: 100%;
      height: 100%;
    }
    
    .seat {
      position: absolute;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, rgba(20,20,40,0.95) 0%, rgba(30,30,50,0.95) 100%);
      border: 2px solid rgba(255,255,255,0.2);
      border-radius: 16px;
      padding: 16px 14px;
      width: 220px;
      aspect-ratio: 1 / 1;
      backdrop-filter: blur(20px) saturate(120%);
      box-shadow: 
        inset 0 0 20px -5px rgba(255, 255, 255, 0.1),
        0 10px 30px rgba(0, 0, 0, 0.6);
      display: flex;
      flex-direction: column;
      justify-content: space-evenly;
      align-items: center;
      gap: 4px;
    }
    
    /* YOUR seat - same aspect ratio, just bigger */
    .seat.me {
      width: 260px;
      aspect-ratio: 1 / 1;
      padding: 18px 16px;
      border: 3px solid var(--teal);
      background: linear-gradient(135deg, rgba(0, 212, 170, 0.15) 0%, rgba(0, 180, 140, 0.15) 100%);
      box-shadow: 
        inset 0 0 30px -6px rgba(0, 212, 170, 0.3), 
        0 0 0 3px rgba(0,212,170,.5),
        0 0 50px rgba(0,212,170,.6),
        0 12px 40px rgba(0, 0, 0, 0.8);
      gap: 8px;
    }
    
    .seat.empty {
      border: 2px dashed rgba(0, 212, 170, 0.5);
      background: linear-gradient(135deg, rgba(0, 212, 170, 0.03) 0%, rgba(0, 180, 140, 0.03) 100%);
      cursor: pointer;
      transition: background 0.3s ease, border 0.3s ease, box-shadow 0.3s ease;
    }
    
    .seat.empty:hover {
      background: linear-gradient(135deg, rgba(0, 212, 170, 0.15) 0%, rgba(0, 180, 140, 0.15) 100%);
      border: 2px solid var(--teal);
      box-shadow: 
        inset 0 0 30px -6px rgba(0, 212, 170, 0.25),
        0 0 0 2px rgba(0,212,170,.4),
        0 0 40px rgba(0, 212, 170, 0.5),
        0 12px 35px rgba(0, 0, 0, 0.7);
      transform: translate(-50%, -50%) scale(1.02);
    }
    
    .seat.taken {
      border: 2px solid rgba(255,215,0,0.6);
      background: linear-gradient(135deg, rgba(255,215,0,0.08) 0%, rgba(255,195,0,0.08) 100%);
      box-shadow: 
        inset 0 0 20px -5px rgba(255, 215, 0, 0.15),
        0 10px 30px rgba(0, 0, 0, 0.6);
    }
    
    .seat.winner {
      border-color: gold;
      background: rgba(255,215,0,0.2);
      box-shadow: 0 0 20px rgba(255,215,0,0.5);
      animation: winnerPulse 1.5s ease-in-out infinite;
    }
    
    @keyframes winnerPulse {
      0%, 100% {
        box-shadow: 0 0 20px rgba(255,215,0,0.5);
      }
      50% {
        box-shadow: 0 0 30px rgba(255,215,0,0.8);
      }
    }
    
    /* Current turn indicator - glowing border */
    @keyframes seatTurnGlow {
      0%, 100% {
        box-shadow: 0 0 0 3px #ffd700, 0 0 30px rgba(255, 215, 0, 0.6);
      }
      50% {
        box-shadow: 0 0 0 5px #ffd700, 0 0 50px rgba(255, 215, 0, 1);
      }
    }
    
    .seat.current-turn {
      border: 3px solid #ffd700;
      animation: seatTurnGlow 1.5s ease-in-out infinite;
    }
    
    .seat-label {
      font-size: clamp(0.7rem, 1.8vw, 0.9rem);
      color: #9aa3b2;
      margin-bottom: 0.5em;
      letter-spacing: 0.3px;
      width: 100%;
      text-align: center;
    }
    
    .seat-player {
      font-size: clamp(1.1rem, 2.5vw, 1.5rem);
      font-weight: 800;
      margin-bottom: 0.4em;
      color: var(--teal);
      text-shadow: 0 2px 10px rgba(0, 212, 170, 0.6);
      letter-spacing: 0.5px;
      width: 100%;
      text-align: center;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      flex-shrink: 0;
    }
    
    .seat-chips {
      color: #ffd700;
      font-weight: 600;
      font-size: clamp(0.85rem, 1.8vw, 1.1rem);
      text-shadow: 0 2px 6px rgba(255, 215, 0, 0.5);
      letter-spacing: 0.5px;
      width: 100%;
      text-align: center;
      flex-shrink: 0;
    }
    
    /* ðŸƒ SEAT CARD BACKINGS */
    .seat-cards {
      display: flex;
      gap: 8px;
      margin-top: 8px;
      justify-content: center;
      min-height: 70px;
      flex-shrink: 1;
    }
    
    .seat-card-back, .seat-card-front {
      width: 60px;
      height: 84px;
      border-radius: 6px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.6);
      transition: transform 0.3s ease, opacity 0.3s ease, filter 0.3s ease;
      object-fit: cover;
    }
    
    .seat-card-back:hover, .seat-card-front:hover {
      transform: translateY(-4px);
    }
    
    .seat-card-back.folded, .seat-card-front.folded {
      opacity: 0.3;
      filter: grayscale(100%);
    }
    
    .seat-card-back.hidden {
      display: none;
    }
    
    /* ðŸŽ° DEALER & BLIND BADGES */
    .position-badges {
      display: flex;
      gap: 4px;
      margin-top: 4px;
      justify-content: center;
    }
    
    .position-badge {
      font-size: 0.7rem;
      padding: 2px 6px;
      border-radius: 4px;
      font-weight: 600;
      border: 1px solid;
    }
    
    .position-badge.dealer {
      background: linear-gradient(135deg, #ffaa00, #ff8800);
      color: #0b0b12;
      border-color: #ffcc44;
    }
    
    .position-badge.sb {
      background: linear-gradient(135deg, #00aaff, #0088ff);
      color: white;
      border-color: #44ccff;
    }
    
    .position-badge.bb {
      background: linear-gradient(135deg, #ff3b3b, #ff0000);
      color: white;
      border-color: #ff6666;
    }
    
    /* ðŸ† WINNER BANNER - Modern Design */
    .winner-banner {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, rgba(15,15,25,0.98), rgba(20,20,30,0.98));
      border: 2px solid #ff5100;
      border-radius: 20px;
      padding: 40px 60px;
      font-size: 2rem;
      font-weight: 700;
      color: #e9eef7;
      box-shadow: 0 16px 48px rgba(255, 81, 0, 0.4), 0 0 0 1px rgba(255, 81, 0, 0.2);
      z-index: 1000;
      animation: winnerBannerPop 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
      display: none;
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      text-align: center;
      min-width: 400px;
      max-width: 600px;
    }
    
    .winner-banner::before {
      content: '';
      position: absolute;
      inset: 0;
      z-index: -1;
      border-radius: 20px;
      background: linear-gradient(135deg, rgba(255, 81, 0, 0.1), rgba(0, 212, 170, 0.05));
      opacity: 0.5;
    }
    
    .winner-banner::after {
      content: '';
      position: absolute;
      inset: -2px;
      z-index: -2;
      border-radius: 22px;
      background: linear-gradient(135deg, rgba(255, 81, 0, 0.3), rgba(0, 212, 170, 0.2));
      filter: blur(20px);
      opacity: 0.6;
    }
    
    @keyframes winnerBannerPop {
      0% {
        transform: translate(-50%, -50%) scale(0.8);
        opacity: 0;
      }
      50% {
        transform: translate(-50%, -50%) scale(1.05);
      }
      100% {
        transform: translate(-50%, -50%) scale(1);
        opacity: 1;
      }
    }
    
    .winner-banner.show {
      display: block;
    }
    
    .winner-banner small {
      display: block;
      margin-top: 12px;
      font-size: 1.2rem;
      font-weight: 500;
      line-height: 1.4;
    }
    
    .winner-banner .winner-name {
      color: #ff5100;
      text-shadow: 0 0 20px rgba(255, 81, 0, 0.5);
    }
    
    .winner-banner .winner-amount {
      color: #00d4aa;
      text-shadow: 0 0 20px rgba(0, 212, 170, 0.5);
    }
    
    /* ðŸƒ SHOW/MUCK CONTROLS */
    .showdown-controls {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, rgba(15,15,25,0.95), rgba(20,20,30,0.95));
      border: 2px solid #ff5100;
      border-radius: 12px;
      padding: 20px;
      display: none;
      z-index: 999;
      box-shadow: 0 8px 24px rgba(0,0,0,0.5);
    }
    
    .showdown-controls.show {
      display: block;
    }
    
    .showdown-controls h3 {
      margin: 0 0 12px 0;
      color: #ff5100;
      font-size: 1rem;
      text-align: center;
    }
    
    .showdown-controls .button-group {
      display: flex;
      gap: 12px;
    }
    
    .showdown-controls button {
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 0.9rem;
    }
    
    .showdown-controls button.show-btn {
      background: linear-gradient(135deg, #00dd88, #00aa66);
      color: white;
    }
    
    .showdown-controls button.show-btn:hover {
      background: linear-gradient(135deg, #00ff99, #00cc77);
      transform: scale(1.05);
    }
    
    .showdown-controls button.muck-btn {
      background: linear-gradient(135deg, #666, #444);
      color: white;
    }
    
    .showdown-controls button.muck-btn:hover {
      background: linear-gradient(135deg, #777, #555);
      transform: scale(1.05);
    }
    
    /* ðŸš¨ CUSTOM ALL-IN CONFIRMATION MODAL */
    .allin-confirm-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(8px);
      z-index: 10000;
      display: none;
      align-items: center;
      justify-content: center;
      animation: fadeIn 0.2s ease-out;
    }
    
    .allin-confirm-overlay.show {
      display: flex;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    .allin-confirm-modal {
      background: linear-gradient(135deg, rgba(15,15,25,0.98), rgba(20,20,30,0.98));
      border: 3px solid #ff5100;
      border-radius: 16px;
      padding: 32px;
      max-width: 400px;
      width: 90%;
      box-shadow: 0 16px 48px rgba(255, 81, 0, 0.4);
      animation: modalSlideIn 0.3s ease-out;
    }
    
    @keyframes modalSlideIn {
      from {
        transform: translateY(-20px);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }
    
    .allin-confirm-header h2 {
      margin: 0 0 20px 0;
      color: #ff5100;
      font-size: 1.5rem;
      text-align: center;
      font-family: 'JetBrains Mono', monospace;
    }
    
    .allin-confirm-body {
      margin-bottom: 24px;
    }
    
    .allin-confirm-body p {
      color: #e9eef7;
      font-size: 1rem;
      margin: 12px 0;
      text-align: center;
    }
    
    .allin-confirm-body strong {
      color: #ff5100;
      font-size: 1.2em;
    }
    
    .allin-warning {
      color: #ff6b6b !important;
      font-weight: 600;
    }
    
    .allin-checkbox-label {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 16px;
      cursor: pointer;
      color: #9aa3b2;
      font-size: 0.9rem;
    }
    
    .allin-checkbox-label input[type="checkbox"] {
      width: 18px;
      height: 18px;
      cursor: pointer;
      accent-color: #ff5100;
    }
    
    .allin-confirm-actions {
      display: flex;
      gap: 12px;
      justify-content: center;
    }
    
    .allin-confirm-btn {
      padding: 12px 24px;
      border: none;
      border-radius: 8px;
      font-weight: 600;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.2s;
      font-family: 'JetBrains Mono', monospace;
    }
    
    .allin-confirm-btn.allin-cancel {
      background: rgba(255, 255, 255, 0.1);
      color: #e9eef7;
      border: 2px solid rgba(255, 255, 255, 0.2);
    }
    
    .allin-confirm-btn.allin-cancel:hover {
      background: rgba(255, 255, 255, 0.15);
      transform: translateY(-2px);
    }
    
    .allin-confirm-btn.allin-confirm {
      background: linear-gradient(135deg, #ff5100, #ff3300);
      color: white;
      border: 2px solid #ff5100;
    }
    
    .allin-confirm-btn.allin-confirm:hover {
      background: linear-gradient(135deg, #ff6600, #ff4400);
      transform: translateY(-2px);
      box-shadow: 0 8px 24px rgba(255, 81, 0, 0.4);
    }
    
    /* ðŸŽ›ï¸ HOST CONTROLS PANEL */
    .host-controls-panel {
      background: linear-gradient(135deg, rgba(255,81,0,0.1), rgba(255,81,0,0.05));
      border: 2px solid #ff5100;
      border-radius: 12px;
      padding: 0;
      margin-bottom: 20px;
      display: none; /* Hidden by default, shown for host only */
      overflow: hidden;
    }
    
    .host-controls-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px 20px;
      background: rgba(255,81,0,0.15);
      cursor: pointer;
      user-select: none;
      transition: background 0.2s;
    }
    
    .host-controls-header:hover {
      background: rgba(255,81,0,0.2);
    }
    
    .host-controls-header h3 {
      color: #ff5100;
      font-size: 1.1rem;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .host-badge {
      background: #ff5100;
      color: white;
      padding: 4px 10px;
      border-radius: 6px;
      font-size: 0.75rem;
      font-weight: 700;
    }
    
    .host-controls-content {
      max-height: 0;
      opacity: 0;
      transition: all 0.3s ease;
      pointer-events: none;
    }
    
    .host-controls-content.expanded {
      max-height: 600px;
      opacity: 1;
      pointer-events: auto;
      padding: 20px;
    }
    
    .host-section {
      background: rgba(255,255,255,0.05);
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 15px;
    }
    
    .host-section:last-child {
      margin-bottom: 0;
    }
    
    .host-section.priority-section {
      border: 2px solid #ff5100;
      background: rgba(255, 81, 0, 0.1);
    }
    
    .host-section h4 {
      color: #00d4aa;
      font-size: 0.95rem;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .player-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .player-item {
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      padding: 12px 15px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border: 1px solid rgba(255,255,255,0.1);
    }
    
    .player-item-info {
      flex: 1;
    }
    
    .player-item-name {
      color: #e9eef7;
      font-weight: 600;
      font-size: 1rem;
      margin-bottom: 4px;
    }
    
    .player-item-details {
      color: #999;
      font-size: 0.85rem;
      display: flex;
      gap: 15px;
    }
    
    .player-item-chips {
      color: gold;
    }
    
    .host-btn {
      padding: 8px 16px;
      border-radius: 6px;
      border: none;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      white-space: nowrap;
    }
    
    .host-btn.kick {
      background: #ff3b3b;
      color: white;
    }
    
    .host-btn.kick:hover {
      background: #ff5555;
      transform: scale(1.05);
    }
    
    /* ðŸª‘ SEAT REQUEST NOTIFICATION POPUP */
    .host-notification-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(8px);
      z-index: 10000;
      display: flex;
      align-items: center;
      justify-content: center;
      animation: fadeIn 0.2s ease-out;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    .host-notification-modal {
      background: linear-gradient(135deg, rgba(15,15,25,0.98), rgba(20,20,30,0.98));
      border: 3px solid #ff5100;
      border-radius: 16px;
      padding: 0;
      max-width: 450px;
      width: 90%;
      box-shadow: 0 16px 48px rgba(255, 81, 0, 0.4);
      animation: modalSlideIn 0.3s ease-out;
    }
    
    @keyframes modalSlideIn {
      from {
        transform: translateY(-20px);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }
    
    .host-notification-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px 24px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .host-notification-header h3 {
      margin: 0;
      color: #ff5100;
      font-size: 1.3rem;
      font-family: 'JetBrains Mono', monospace;
    }
    
    .host-notification-header .close-btn {
      background: none;
      border: none;
      color: #9aa3b2;
      font-size: 1.5rem;
      cursor: pointer;
      padding: 0;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
      transition: all 0.2s;
    }
    
    .host-notification-header .close-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      color: #e9eef7;
    }
    
    .host-notification-body {
      padding: 24px;
    }
    
    .host-notification-body p {
      color: #e9eef7;
      font-size: 1rem;
      margin: 0 0 20px 0;
      line-height: 1.6;
    }
    
    .host-notification-body strong {
      color: #00d4aa;
    }
    
    .request-details {
      margin-top: 16px;
    }
    
    .request-chip-input {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    .request-chip-input label {
      color: #9aa3b2;
      font-size: 0.9rem;
      min-width: 100px;
    }
    
    .request-chip-input .form-input {
      flex: 1;
      padding: 10px 12px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 6px;
      color: #e9eef7;
      font-size: 1rem;
    }
    
    .host-notification-actions {
      display: flex;
      gap: 12px;
      padding: 20px 24px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .host-notification-btn {
      flex: 1;
      padding: 12px 24px;
      border: none;
      border-radius: 8px;
      font-weight: 600;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.2s;
      font-family: 'JetBrains Mono', monospace;
    }
    
    .host-notification-btn.reject {
      background: rgba(255, 59, 59, 0.2);
      color: #ff6b6b;
      border: 2px solid #ff3b3b;
    }
    
    .host-notification-btn.reject:hover {
      background: rgba(255, 59, 59, 0.3);
      transform: translateY(-2px);
    }
    
    .host-notification-btn.approve {
      background: linear-gradient(135deg, #00d4aa, #00b894);
      color: white;
      border: 2px solid #00d4aa;
    }
    
    .host-notification-btn.approve:hover {
      background: linear-gradient(135deg, #00ffcc, #00d4aa);
      transform: translateY(-2px);
      box-shadow: 0 8px 24px rgba(0, 212, 170, 0.4);
    }
    
    /* Pending requests list */
    .seat-request-item {
      background: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
      padding: 12px 15px;
      margin-bottom: 10px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .seat-request-info {
      flex: 1;
    }
    
    .seat-request-name {
      color: #e9eef7;
      font-weight: 600;
      margin-bottom: 4px;
    }
    
    .seat-request-details {
      color: #9aa3b2;
      font-size: 0.85rem;
    }
    
    .seat-request-actions {
      display: flex;
      gap: 8px;
    }
    
    .seat-request-btn {
      padding: 6px 12px;
      border-radius: 6px;
      border: none;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .seat-request-btn.approve {
      background: #00d4aa;
      color: #0b0b12;
    }
    
    .seat-request-btn.reject {
      background: #ff3b3b;
      color: white;
    }
    
    .seat-request-btn:hover {
      transform: scale(1.05);
    }
    
    .empty-state {
      color: #9aa3b2;
      font-size: 0.9rem;
      text-align: center;
      padding: 20px;
      font-style: italic;
    }
    
    .blinds-controls {
      display: flex;
      gap: 15px;
      align-items: center;
      flex-wrap: wrap;
    }
    
    .blind-input-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .blind-input-group label {
      color: #9aa3b2;
      font-weight: 600;
      font-size: 0.9rem;
    }
    
    .blind-input-group input {
      width: 90px;
      padding: 10px;
      border-radius: 6px;
      border: 2px solid #333;
      background: rgba(0,0,0,0.4);
      color: #e9eef7;
      font-size: 1rem;
      font-weight: 600;
    }
    
    .blind-input-group input:focus {
      outline: none;
      border-color: #00d4aa;
    }
    
    .host-btn.update {
      background: #00d4aa;
      color: #0b0b12;
      padding: 10px 20px;
      font-size: 0.95rem;
    }
    
    .host-btn.update:hover {
      background: #00ffcc;
      transform: translateY(-2px);
    }
    
    .empty-state {
      color: #666;
      font-style: italic;
      text-align: center;
      padding: 15px;
    }
    
    .toggle-icon {
      color: #ff5100;
      font-size: 1.2rem;
      transition: transform 0.3s;
    }
    
    .toggle-icon.expanded {
      transform: rotate(180deg);
    }
    
    /* Section hints */
    .section-hint {
      font-size: 0.85rem;
      color: rgba(255,255,255,0.6);
      margin: -8px 0 12px 0;
      font-style: italic;
    }
    
    /* Form elements */
    .form-select, .form-input {
      width: 100%;
      padding: 10px;
      border-radius: 8px;
      background: rgba(255,255,255,0.08);
      color: white;
      border: 1px solid rgba(255,255,255,0.2);
      font-family: "Courier New", monospace;
      font-size: 0.95rem;
      transition: all 0.3s ease;
    }
    
    .form-select:focus, .form-input:focus {
      outline: none;
      border-color: var(--teal);
      background: rgba(255,255,255,0.12);
      box-shadow: 0 0 0 2px rgba(0, 212, 170, 0.2);
    }
    
    .chip-adjustment-controls {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    
    /* Player Settings Panel (Non-Hosts) */
    #playerSettingsPanel {
      max-width: 1400px;
      margin: 20px auto;
      background: rgba(20, 20, 40, 0.8);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 16px;
      padding: 24px;
      backdrop-filter: blur(10px);
    }
    
    #playerSettingsPanel .panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: pointer;
      user-select: none;
      padding-bottom: 16px;
      border-bottom: 2px solid rgba(255,255,255,0.1);
      margin-bottom: 20px;
    }
    
    #playerSettingsPanel .panel-header h2 {
      color: var(--teal);
      font-size: 1.3rem;
      font-weight: 700;
      margin: 0;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    #playerSettingsPanel .collapse-btn {
      background: transparent;
      border: none;
      cursor: pointer;
      padding: 8px;
    }
    
    #playerSettingsPanel .panel-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease;
    }
    
    #playerSettingsPanel .panel-content.expanded {
      max-height: 1000px;
    }
    
    .color-picker-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
      gap: 12px;
      margin-top: 16px;
    }
    
    .color-btn {
      background: rgba(255,255,255,0.05);
      border: 2px solid rgba(255,255,255,0.2);
      border-radius: 12px;
      padding: 12px;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }
    
    .color-btn:hover {
      background: rgba(255,255,255,0.1);
      border-color: var(--teal);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 212, 170, 0.3);
    }
    
    .color-btn.active {
      border-color: var(--accent);
      background: rgba(255, 81, 0, 0.1);
      box-shadow: 0 0 20px rgba(255, 81, 0, 0.4);
    }
    
    /* Toggle Switch */
    .toggle-switch {
      display: flex;
      align-items: center;
      gap: 12px;
      cursor: pointer;
    }
    
    .toggle-switch input[type="checkbox"] {
      position: absolute;
      opacity: 0;
      width: 0;
      height: 0;
    }
    
    .toggle-slider {
      position: relative;
      display: inline-block;
      width: 50px;
      height: 26px;
      background: rgba(255,255,255,0.1);
      border-radius: 13px;
      transition: all 0.3s;
      border: 2px solid rgba(255,255,255,0.2);
    }
    
    .toggle-slider::after {
      content: '';
      position: absolute;
      width: 18px;
      height: 18px;
      left: 2px;
      top: 2px;
      background: #e9eef7;
      border-radius: 50%;
      transition: all 0.3s;
    }
    
    .toggle-switch input:checked + .toggle-slider {
      background: #00d4aa;
      border-color: #00d4aa;
    }
    
    .toggle-switch input:checked + .toggle-slider::after {
      transform: translateX(24px);
    }
    
    .toggle-label {
      color: #e9eef7;
      font-size: 0.9rem;
    }
    
    /* Settings Select */
    .settings-select {
      width: 100%;
      padding: 10px 14px;
      background: rgba(255,255,255,0.05);
      border: 2px solid rgba(255,255,255,0.2);
      border-radius: 8px;
      color: #e9eef7;
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.3s;
    }
    
    .settings-select:hover {
      border-color: #00d4aa;
      background: rgba(255,255,255,0.08);
    }
    
    .settings-select:focus {
      outline: none;
      border-color: #00d4aa;
      box-shadow: 0 0 0 3px rgba(0, 212, 170, 0.2);
    }
    
    /* Setting Note */
    .setting-note {
      margin-top: 8px;
      font-size: 0.8rem;
      color: #9aa3b2;
      font-style: italic;
    }
    
    /* ============================================ */
    /* HOST CONTROLS PANEL - MATCHES PLAYER SETTINGS */
    /* ============================================ */
    
    #hostControlsPanel {
      max-width: 1400px;
      margin: 20px auto;
      background: rgba(20, 20, 40, 0.8);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 16px;
      padding: 24px;
      backdrop-filter: blur(10px);
      display: none; /* Hidden by default, shown only for hosts */
    }
    
    #hostControlsPanel .panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: pointer;
      user-select: none;
      padding-bottom: 16px;
      border-bottom: 2px solid rgba(255,255,255,0.1);
      margin-bottom: 20px;
    }
    
    #hostControlsPanel .panel-header h2 {
      color: var(--accent);
      font-size: 1.3rem;
      font-weight: 700;
      margin: 0;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    .host-badge {
      font-size: 0.7rem;
      background: rgba(255, 81, 0, 0.2);
      color: var(--accent);
      padding: 4px 10px;
      border-radius: 20px;
      border: 1px solid var(--accent);
      font-weight: 600;
      letter-spacing: 0.5px;
    }
    
    #hostControlsPanel .collapse-btn {
      background: transparent;
      border: none;
      cursor: pointer;
      padding: 8px;
    }
    
    #hostControlsPanel .panel-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease;
    }
    
    #hostControlsPanel .panel-content.expanded {
      max-height: 2000px;
    }
    
    .host-actions-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 12px;
      margin-top: 16px;
    }
    
    .host-control-btn {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      padding: 16px 12px;
      border-radius: 10px;
      font-family: "Courier New", monospace;
      font-weight: 600;
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.3s ease;
      border: 2px solid;
      background: rgba(255,255,255,0.03);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .host-control-btn .btn-icon {
      font-size: 1.5rem;
    }
    
    .host-control-btn .btn-text {
      font-size: 0.8rem;
      line-height: 1.2;
      text-align: center;
    }
    
    .host-control-btn.action {
      color: #00d4aa;
      border-color: #00d4aa;
    }
    
    .host-control-btn.action:hover {
      background: rgba(0, 212, 170, 0.2);
      border-color: #00ffcc;
      transform: translateY(-3px);
      box-shadow: 0 6px 20px rgba(0, 212, 170, 0.4);
    }
    
    .host-control-btn.update {
      color: #00d4aa;
      border-color: #00d4aa;
      width: 100%;
      margin-top: 12px;
    }
    
    .host-control-btn.update:hover {
      background: rgba(0, 212, 170, 0.2);
      border-color: #00ffcc;
      transform: translateY(-2px);
    }
    
    .host-control-btn.danger {
      color: #ff5151;
      border-color: #ff5151;
    }
    
    .host-control-btn.danger:hover {
      background: rgba(255, 81, 81, 0.2);
      border-color: #ff6666;
      transform: translateY(-3px);
      box-shadow: 0 6px 20px rgba(255, 81, 81, 0.4);
    }
    
    .host-control-btn.paused {
      background: rgba(249, 115, 22, 0.2);
      color: #f97316;
      border-color: #f97316;
    }
    
    .setting-group {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-bottom: 20px;
    }
    
    .setting-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 14px 16px;
      background: rgba(255,255,255,0.03);
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.1);
      margin-bottom: 12px;
    }
    
    .setting-label {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    
    .setting-label span {
      color: #e9eef7;
      font-size: 0.95rem;
      font-weight: 500;
    }
    
    .setting-label small {
      color: #9aa3b2;
      font-size: 0.8rem;
    }
    
    .timer-buttons {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 8px;
    }
    
    .timer-btn {
      flex: 1;
      min-width: 60px;
      padding: 10px 15px;
      background: rgba(255,255,255,0.05);
      color: #e9eef7;
      border: 2px solid rgba(255,255,255,0.2);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-family: "Courier New", monospace;
      font-size: 0.9rem;
      font-weight: 600;
    }
    
    .timer-btn:hover {
      background: rgba(0, 212, 170, 0.15);
      border-color: #00d4aa;
      color: #00d4aa;
      transform: translateY(-2px);
    }
    
    .timer-btn.active {
      background: #00d4aa;
      color: #0b0b12;
      border-color: #00d4aa;
      font-weight: 700;
      box-shadow: 0 0 15px rgba(0, 212, 170, 0.5);
    }
    
    .timer-status {
      text-align: center;
      padding: 12px;
      background: rgba(255,255,255,0.03);
      border-radius: 8px;
      font-family: "Courier New", monospace;
      color: #9aa3b2;
      margin-top: 8px;
      font-size: 0.9rem;
    }
    
    .timer-status span {
      color: #00d4aa;
      font-weight: 700;
      font-size: 1rem;
    }
    
    .blinds-controls {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-top: 16px;
    }
    
    .blind-input-group {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    
    .blind-input-group label {
      color: #e9eef7;
      font-size: 0.9rem;
      font-weight: 500;
      min-width: 100px;
    }
    
    .blind-input-group input,
    .blind-input-group select {
      flex: 1;
      padding: 10px 14px;
      background: rgba(255,255,255,0.05);
      border: 2px solid rgba(255,255,255,0.2);
      border-radius: 8px;
      color: #e9eef7;
      font-size: 0.9rem;
      font-family: "Courier New", monospace;
      font-weight: 600;
      transition: all 0.3s;
    }
    
    .blind-input-group input:focus,
    .blind-input-group select:focus {
      outline: none;
      border-color: #00d4aa;
      box-shadow: 0 0 0 3px rgba(0, 212, 170, 0.2);
      background: rgba(255,255,255,0.08);
    }
    
    .form-input {
      padding: 10px 14px;
      background: rgba(255,255,255,0.05);
      border: 2px solid rgba(255,255,255,0.2);
      border-radius: 8px;
      color: #e9eef7;
      font-size: 0.9rem;
      font-family: "Courier New", monospace;
      font-weight: 600;
      transition: all 0.3s;
    }
    
    .form-input:focus {
      outline: none;
      border-color: #00d4aa;
      box-shadow: 0 0 0 3px rgba(0, 212, 170, 0.2);
      background: rgba(255,255,255,0.08);
    }
    
    .danger-zone {
      border: 2px solid rgba(255, 81, 81, 0.3);
      border-radius: 12px;
      padding: 20px;
      background: rgba(255, 81, 81, 0.05);
      margin-top: 24px;
    }
    
    .danger-zone h4 {
      color: #ff5151;
      margin-bottom: 8px;
    }
    
    .danger-zone .section-hint {
      color: #ff8888;
    }
    
    /* Hotkey List */
    .hotkey-list div {
      padding: 6px 0;
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }
    
    .hotkey-list div:last-child {
      border-bottom: none;
    }
    
    kbd {
      display: inline-block;
      padding: 3px 8px;
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 4px;
      font-family: "Courier New", monospace;
      font-size: 0.85rem;
      color: #00d4aa;
      margin-right: 8px;
    }
    
    .color-preview {
      width: 60px;
      height: 60px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.4), inset 0 2px 8px rgba(255,255,255,0.1);
      transition: all 0.3s ease;
    }
    
    .color-btn:hover .color-preview {
      transform: scale(1.1);
    }
    
    .color-btn span {
      color: white;
      font-size: 0.85rem;
      font-weight: 600;
      font-family: "Courier New", monospace;
    }
    
    .controls {
      background: rgba(255,255,255,0.05);
      padding: 20px;
      border-radius: 12px;
      margin-bottom: 30px;
    }
    
    /* Subtle blink animation for active buttons */
    @keyframes subtlePulse {
      0%, 100% {
        opacity: 1;
        box-shadow: 0 0 0 rgba(255, 255, 255, 0);
      }
      50% {
        opacity: 0.85;
        box-shadow: 0 0 20px rgba(255, 255, 255, 0.15);
      }
    }
    
    /* BASE BUTTON STYLES - No liquid glass by default */
    .btn {
      padding: 18px 40px;
      background: #0b0b12;
      color: #e9eef7;
      border: 3px solid;
      border-radius: 8px;
      font-family: "Courier New", monospace;
      font-weight: 600;
      font-size: 20px;
      cursor: pointer;
      transition: all 0.2s ease;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    /* LIQUID GLASS EFFECT - ONLY FOR POKER TABLE ACTION BUTTONS */
    #actionButtons .btn,
    #foldBtn,
    #callBtn,
    #raiseBtn {
      /* LIQUID GLASS BASE */
      position: relative;
      isolation: isolate;
      background: rgba(15, 15, 25, 0.6); /* Base dark background for glass effect */
      border-radius: 12px; /* Slightly larger for glass effect */
      transition: all 0.3s ease;
      /* Remove conflicting styles - liquid glass handles backdrop-filter */
      backdrop-filter: none !important;
      -webkit-backdrop-filter: none !important;
      box-shadow: 0px 6px 24px rgba(0, 0, 0, 0.2);
      /* Ensure content appears above glass effect */
      z-index: 1;
    }
    
    /* LIQUID GLASS PSEUDO-ELEMENTS - ONLY FOR ACTION BUTTONS */
    #actionButtons .btn::before,
    #foldBtn::before,
    #callBtn::before,
    #raiseBtn::before {
      content: '';
      position: absolute;
      inset: 0;
      z-index: -1;
      border-radius: inherit;
      box-shadow: inset 0 0 20px -5px rgba(255, 255, 255, 0.7);
      background-color: rgba(255, 255, 255, 0.05);
      pointer-events: none;
    }
    
    #actionButtons .btn::after,
    #foldBtn::after,
    #callBtn::after,
    #raiseBtn::after {
      content: '';
      position: absolute;
      inset: 0;
      z-index: -2;
      border-radius: inherit;
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      filter: url(#glass-distortion);
      pointer-events: none;
    }
    
    /* Ensure button content (text/spans) appear above glass */
    #actionButtons .btn > *,
    #foldBtn > *,
    #callBtn > *,
    #raiseBtn > * {
      position: relative;
      z-index: 1;
    }
    
    /* YOUR TURN - Pulse animation with glass glow (action buttons only) */
    #actionButtons .btn.active,
    #foldBtn.active,
    #callBtn.active,
    #raiseBtn.active {
      animation: subtlePulse 2s ease-in-out infinite;
    }
    
    #actionButtons .btn.active::before,
    #foldBtn.active::before,
    #callBtn.active::before,
    #raiseBtn.active::before {
      background-color: rgba(255, 255, 255, 0.08);
      box-shadow: inset 0 0 25px -3px rgba(255, 255, 255, 0.9);
    }
    
    /* NOT YOUR TURN - Blurred (action buttons only) */
    #actionButtons .btn.not-your-turn,
    #foldBtn.not-your-turn,
    #callBtn.not-your-turn,
    #raiseBtn.not-your-turn {
      filter: blur(2px);
      opacity: 0.3;
      pointer-events: none;
      cursor: not-allowed;
    }
    
    #actionButtons .btn.not-your-turn::before,
    #foldBtn.not-your-turn::before,
    #callBtn.not-your-turn::before,
    #raiseBtn.not-your-turn::before {
      background-color: rgba(255, 255, 255, 0.02);
    }
    
    /* HOVER STATE - Enhanced glass effect (action buttons only) */
    #actionButtons .btn:hover:not(:disabled):not(.not-your-turn),
    #foldBtn:hover:not(:disabled):not(.not-your-turn),
    #callBtn:hover:not(:disabled):not(.not-your-turn),
    #raiseBtn:hover:not(:disabled):not(.not-your-turn) {
      transform: translateY(-2px);
      animation: none;
      box-shadow: 0px 8px 32px rgba(0, 0, 0, 0.3);
    }
    
    #actionButtons .btn:hover:not(:disabled):not(.not-your-turn)::before,
    #foldBtn:hover:not(:disabled):not(.not-your-turn)::before,
    #callBtn:hover:not(:disabled):not(.not-your-turn)::before,
    #raiseBtn:hover:not(:disabled):not(.not-your-turn)::before {
      background-color: rgba(255, 255, 255, 0.08);
    }
    
    #actionButtons .btn:active:not(:disabled):not(.not-your-turn),
    #foldBtn:active:not(:disabled):not(.not-your-turn),
    #callBtn:active:not(:disabled):not(.not-your-turn),
    #raiseBtn:active:not(:disabled):not(.not-your-turn) {
      transform: translateY(0);
      box-shadow: 0px 4px 16px rgba(0, 0, 0, 0.2);
    }
    
    /* Force white text on start button */
    #startBtn, #refreshBtn {
      color: #ffffff !important;
    }
    
    /* ============================================ */
    /* RAISE PANEL (Below Buttons - No Box) */
    /* ============================================ */
    .raise-panel {
      margin: 30px auto 0;
      max-width: 800px;
      padding: 20px 0;
      animation: panelSlideDown 0.3s ease-out;
    }
    
    @keyframes panelSlideDown {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    .raise-slider-section {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-bottom: 24px;
    }
    
    .raise-info {
      display: flex;
      justify-content: center;
      gap: 40px;
      margin-bottom: 20px;
      margin-top: 20px;
    }
    
    .raise-info-item {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    
    .raise-info-label {
      font-size: 13px;
      color: #9aa3b2;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .raise-info-value {
      font-size: 20px;
      font-weight: 700;
      color: #00d4aa;
      font-family: "Courier New", monospace;
    }
    
    .raise-presets {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 12px;
      margin-bottom: 20px;
    }
    
    .raise-preset-btn {
      padding: 12px;
      background: #0b0b12;
      color: #e9eef7;
      border: 2px solid #00d4aa;
      border-radius: 6px;
      font-family: "Courier New", monospace;
      font-weight: 600;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s ease;
      text-transform: uppercase;
    }
    
    .raise-preset-btn:hover {
      background: #00d4aa;
      color: #0b0b12;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 212, 170, 0.4);
    }
    
    
    .raise-input {
      padding: 12px 16px;
      background: #0b0b12;
      border: 2px solid rgba(0, 212, 170, 0.5);
      border-radius: 8px;
      color: #e9eef7;
      font-size: 18px;
      font-family: "Courier New", monospace;
      font-weight: 600;
      text-align: center;
      width: 200px;
      margin: 0 auto;
    }
    
    .raise-input:focus {
      outline: none;
      border-color: #00d4aa;
      box-shadow: 0 0 0 3px rgba(0, 212, 170, 0.2);
    }
    
    .raise-slider {
      width: 100%;
      height: 8px;
      background: rgba(0, 212, 170, 0.2);
      border-radius: 4px;
      outline: none;
      -webkit-appearance: none;
      appearance: none;
    }
    
    .raise-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      background: #00d4aa;
      cursor: pointer;
      border-radius: 50%;
      box-shadow: 0 2px 8px rgba(0, 212, 170, 0.5);
    }
    
    .raise-slider::-moz-range-thumb {
      width: 20px;
      height: 20px;
      background: #00d4aa;
      cursor: pointer;
      border-radius: 50%;
      border: none;
      box-shadow: 0 2px 8px rgba(0, 212, 170, 0.5);
    }
    
    .raise-slider-value {
      text-align: center;
      font-size: 32px;
      font-weight: 700;
      color: #00d4aa;
      font-family: "Courier New", monospace;
      margin-bottom: 8px;
    }
    
    .raise-actions {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-top: 20px;
    }
    
    .raise-actions .btn {
      min-width: 140px;
    }
    
    #raiseSubmitBtn {
      color: #00d4aa;
      border-color: #00d4aa;
    }
    
    #raiseSubmitBtn:hover {
      background: #00d4aa;
      color: #0b0b12;
    }
    
    /* ============================================ */
    
    /* FOLD - Red outline with liquid glass */
    #foldBtn {
      color: #dc2626;
      border-color: #dc2626;
    }
    
    #foldBtn::before {
      background-color: rgba(220, 38, 38, 0.1);
      box-shadow: inset 0 0 20px -5px rgba(220, 38, 38, 0.5);
    }
    
    #foldBtn:hover:not(:disabled) {
      background: rgba(220, 38, 38, 0.2);
      color: #ff6b6b;
      box-shadow: 0px 8px 32px rgba(220, 38, 38, 0.4);
    }
    
    #foldBtn:hover:not(:disabled)::before {
      background-color: rgba(220, 38, 38, 0.15);
      box-shadow: inset 0 0 25px -3px rgba(220, 38, 38, 0.7);
    }
    
    /* CALL - Teal outline with liquid glass */
    #callBtn {
      color: #00d4aa;
      border-color: #00d4aa;
    }
    
    #callBtn::before {
      background-color: rgba(0, 212, 170, 0.1);
      box-shadow: inset 0 0 20px -5px rgba(0, 212, 170, 0.5);
    }
    
    #callBtn:hover:not(:disabled) {
      background: rgba(0, 212, 170, 0.2);
      color: #00ffcc;
      box-shadow: 0px 8px 32px rgba(0, 212, 170, 0.4);
    }
    
    #callBtn:hover:not(:disabled)::before {
      background-color: rgba(0, 212, 170, 0.15);
      box-shadow: inset 0 0 25px -3px rgba(0, 212, 170, 0.7);
    }
    
    /* RAISE - Orange outline with liquid glass */
    #raiseBtn {
      color: #f97316;
      border-color: #f97316;
    }
    
    #raiseBtn::before {
      background-color: rgba(249, 115, 22, 0.1);
      box-shadow: inset 0 0 20px -5px rgba(249, 115, 22, 0.5);
    }
    
    #raiseBtn:hover:not(:disabled) {
      background: rgba(249, 115, 22, 0.2);
      color: #ff8c42;
      box-shadow: 0px 8px 32px rgba(249, 115, 22, 0.4);
    }
    
    #raiseBtn:hover:not(:disabled)::before {
      background-color: rgba(249, 115, 22, 0.15);
      box-shadow: inset 0 0 25px -3px rgba(249, 115, 22, 0.7);
    }
    
    
    .my-cards {
      background: rgba(0,212,170,0.1);
      border: 2px solid #00d4aa;
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 30px;
    }
    
    .my-cards h3 {
      color: #00d4aa;
      margin-bottom: 15px;
    }
    
    .cards-display {
      display: flex;
      gap: 10px;
    }
    
    .card {
      width: 80px;
      height: 112px;
      background-size: cover;
      background-position: center;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }
    
    .debug {
      background: rgba(255,255,255,0.03);
      padding: 15px;
      border-radius: 8px;
      font-family: 'Courier New', monospace;
      font-size: 0.85rem;
      color: #9aa3b2;
      max-height: 300px;
      overflow-y: auto;
    }
    
    .debug h4 {
      color: #ff5100;
      margin-bottom: 10px;
    }
    
    /* Calming UI Adjustments */
    .container {
      max-width: 1400px;
      margin: 0 auto;
    }
    
    h2 {
      color: rgba(255,255,255,0.9);
      font-weight: 600;
      font-size: 1.1rem;
      margin-bottom: 16px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    #currentActor {
      color: var(--accent);
      font-weight: 700;
    }
    
    /* Add padding for fixed navbar */
    body {
      padding-top: 100px;
    }
  </style>
  
  <!-- Global CSS for navbar -->
  <link rel="stylesheet" href="/css/pokergeek.css">
  
  <!-- Supabase SDK -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <!-- Unified Auth System -->
  <script src="/js/auth-manager.js"></script>
  <script src="/js/nav-shared.js"></script>
  <script src="/js/navbar-template.js"></script>
  
  <!-- Social Features -->
  <link rel="stylesheet" href="/css/social-modals.css">
  <script src="/js/social-modals.js"></script>
  
  <!-- Rank Styling -->
  <link rel="stylesheet" href="/css/rank-styling.css">
  <script src="/js/username-styling.js"></script>
</head>
<body>
  <!-- UNIFIED NAVBAR (Injected by navbar-template.js) -->
  <div id="navbar-container"></div>
  
  <!-- ðŸ† WINNER BANNER (hidden by default) -->
  <div class="winner-banner" id="winnerBanner"></div>
  
  <!-- ðŸƒ SHOW/MUCK CONTROLS (showdown only) -->
  <div class="showdown-controls" id="showdownControls">
    <h3>ðŸƒ Show your cards or muck?</h3>
    <div class="button-group">
      <button class="show-btn" onclick="showCards()">SHOW CARDS</button>
      <button class="muck-btn" onclick="muckCards()">MUCK</button>
    </div>
  </div>
  
  <!-- ðŸš¨ CUSTOM ALL-IN CONFIRMATION MODAL -->
  <div class="allin-confirm-overlay" id="allinConfirmOverlay">
    <div class="allin-confirm-modal">
      <div class="allin-confirm-header">
        <h2>ðŸš¨ Go All-In?</h2>
      </div>
      <div class="allin-confirm-body">
        <p>You are about to bet your entire stack of <strong id="allinConfirmAmount">$0</strong>.</p>
        <p class="allin-warning">This action cannot be undone.</p>
        <label class="allin-checkbox-label">
          <input type="checkbox" id="allinDontAskAgain">
          <span>Don't ask again this game</span>
        </label>
      </div>
      <div class="allin-confirm-actions">
        <button class="allin-confirm-btn allin-cancel" onclick="cancelAllIn()">Cancel</button>
        <button class="allin-confirm-btn allin-confirm" onclick="confirmAllIn()">Go All-In</button>
      </div>
    </div>
  </div>
  
  <div class="container">
    <!-- CLEAN HEADER -->
    <div class="table-header">
      <div class="room-code-display">
        <span class="room-code-label">Room</span>
        <span class="room-code" id="roomCode">---</span>
      </div>
      <div class="connection-indicator" id="socketStatus">
        <span class="connection-dot"></span>
      </div>
    </div>
    
    <!-- ðŸŽ›ï¸ HOST CONTROLS PANEL -->
    <div id="hostControlsPanel">
      <div class="panel-header">
        <h2>ðŸŽ›ï¸ HOST CONTROLS <span class="host-badge">ONLY YOU</span></h2>
        <button class="collapse-btn" onclick="toggleHostControls()">
        <span class="toggle-icon" id="hostToggleIcon">â–¼</span>
        </button>
      </div>
      
      <div class="panel-content" id="hostControlsContent">
        <!-- SEAT REQUESTS (Priority - Most Important) -->
        <div class="host-section priority-section">
          <h4>ðŸª‘ Pending Seat Requests</h4>
          <p class="section-hint">Players requesting to join mid-game</p>
          <div id="pendingSeatRequests">
            <div class="empty-state">No pending requests</div>
          </div>
        </div>
        
        <!-- ACTIVE GAME CONTROLS -->
        <div class="host-section">
          <h4>âš¡ Active Game Controls</h4>
          <p class="section-hint">Manage the current game</p>
          <div class="host-actions-grid">
            <button class="host-control-btn action" onclick="togglePauseGame()" id="pauseGameBtn">
              <span class="btn-icon">â¸ï¸</span>
              <span class="btn-text">PAUSE GAME</span>
            </button>
            <button class="host-control-btn action" onclick="forceNextHand()">
              <span class="btn-icon">â­ï¸</span>
              <span class="btn-text">NEXT HAND</span>
            </button>
            <button class="host-control-btn action" onclick="openKickPlayerModal()">
              <span class="btn-icon">ðŸ‘¢</span>
              <span class="btn-text">KICK PLAYER</span>
            </button>
          </div>
        </div>
        
        <!-- ROOM MANAGEMENT -->
        <div class="host-section">
          <h4>ðŸ”’ Room Management</h4>
          <p class="section-hint">Control who can join</p>
          <div class="host-actions-grid">
            <button class="host-control-btn action" onclick="toggleRoomLock()">
              <span class="btn-icon">ðŸ”’</span>
              <span class="btn-text" id="lockBtnText">LOCK ROOM</span>
            </button>
          </div>
        </div>
        
        <!-- BLIND CONTROLS -->
        <div class="host-section">
          <h4>ðŸ’° Blind Controls</h4>
          <p class="section-hint">Adjust blinds between hands</p>
          <div class="blinds-controls">
            <div class="blind-input-group">
              <label>Small Blind:</label>
              <input type="number" id="hostSmallBlindInput" value="10" min="1" class="form-input">
            </div>
            <div class="blind-input-group">
              <label>Big Blind:</label>
              <input type="number" id="hostBigBlindInput" value="20" min="2" class="form-input">
            </div>
            <button class="host-control-btn update" onclick="updateBlinds()">UPDATE BLINDS</button>
          </div>
        </div>
        
        <!-- GAME SETTINGS -->
        <div class="host-section">
          <h4>âš™ï¸ Game Settings</h4>
          
          <!-- Action Timer -->
          <div class="setting-group">
            <div class="setting-label">
              <span>â±ï¸ Action Timer</span>
              <small>Set time limit per decision (0 = unlimited)</small>
            </div>
            <div class="timer-buttons">
              <button class="timer-btn" onclick="setActionTimer(0)">OFF</button>
              <button class="timer-btn" onclick="setActionTimer(15)">15s</button>
              <button class="timer-btn" onclick="setActionTimer(30)">30s</button>
              <button class="timer-btn" onclick="setActionTimer(45)">45s</button>
              <button class="timer-btn" onclick="setActionTimer(60)">60s</button>
            </div>
            <div class="timer-status">
              Current: <span id="actionTimerDisplay">OFF</span>
            </div>
          </div>
          
          <!-- Auto-Start Toggle -->
          <div class="setting-row">
            <div class="setting-label">
              <span>ðŸ”„ Auto-Start Hands</span>
              <small>Automatically begin next hand when ready</small>
            </div>
            <label class="toggle-switch">
              <input type="checkbox" id="autoStartToggle" onchange="toggleAutoStart()" checked>
              <span class="toggle-slider"></span>
            </label>
          </div>
          
          <!-- Spectator Mode Toggle -->
          <div class="setting-row">
            <div class="setting-label">
              <span>ðŸ‘ï¸ Spectator Mode</span>
              <small>Allow kicked players to watch game</small>
            </div>
            <label class="toggle-switch">
              <input type="checkbox" id="spectatorToggle" onchange="toggleSpectatorMode()" checked>
              <span class="toggle-slider"></span>
            </label>
          </div>
        </div>
        
        <!-- DANGER ZONE -->
        <div class="host-section danger-zone">
          <h4>âš ï¸ Danger Zone</h4>
          <p class="section-hint">Destructive actions - use with caution</p>
          <div class="host-actions-grid">
            <button class="host-control-btn danger" onclick="resetAllStacks()">
              <span class="btn-icon">ðŸ”„</span>
              <span class="btn-text">RESET STACKS</span>
            </button>
            <button class="host-control-btn danger" onclick="endGame()">
              <span class="btn-icon">ðŸ›‘</span>
              <span class="btn-text">END GAME</span>
            </button>
            </div>
        </div>
      </div>
    </div>
    
    <!-- ðŸª‘ HOST NOTIFICATION POPUP (Seat Requests) -->
    <div class="host-notification-overlay" id="hostNotificationOverlay" style="display: none;">
      <div class="host-notification-modal">
        <div class="host-notification-header">
          <h3>ðŸª‘ Seat Request</h3>
          <button class="close-btn" onclick="closeHostNotification()">Ã—</button>
        </div>
        <div class="host-notification-body">
          <p><strong id="requestUsername">@player</strong> wants to join <strong>Seat <span id="requestSeatIndex">0</span></strong></p>
          <div class="request-details">
            <div class="request-chip-input">
              <label>Starting Chips:</label>
              <input type="number" id="requestChipAmount" value="1000" min="1" class="form-input">
            </div>
          </div>
        </div>
        <div class="host-notification-actions">
          <button class="host-notification-btn reject" onclick="rejectSeatRequest()">âŒ Reject</button>
          <button class="host-notification-btn approve" onclick="approveSeatRequest()">âœ… Approve</button>
        </div>
      </div>
    </div>
    
    <!-- âš™ï¸ PLAYER SETTINGS (Non-Host Players) -->
    <div id="playerSettingsPanel">
      <div class="panel-header">
        <h2>âš™ï¸ Player Settings</h2>
        <button class="collapse-btn" onclick="togglePlayerSettings()">
          <span class="toggle-icon" id="playerSettingsToggle">â–¼</span>
        </button>
      </div>
      
      <div class="panel-content" id="playerSettingsContent">
        <!-- TABLE COLOR -->
        <div class="host-section">
          <h4>ðŸŽ¨ Table Color</h4>
          <p class="section-hint">Choose your preferred felt color (saved locally)</p>
          <div class="color-picker-grid">
            <button class="color-btn" data-color="green" onclick="changeFeltColor('green')" title="Classic Green">
              <div class="color-preview" style="background: #197a45;"></div>
              <span>Green</span>
            </button>
            <button class="color-btn" data-color="red" onclick="changeFeltColor('red')" title="Ruby Red">
              <div class="color-preview" style="background: #6b1414;"></div>
              <span>Red</span>
            </button>
            <button class="color-btn" data-color="blue" onclick="changeFeltColor('blue')" title="Ocean Blue">
              <div class="color-preview" style="background: #0f2942;"></div>
              <span>Blue</span>
            </button>
            <button class="color-btn" data-color="black" onclick="changeFeltColor('black')" title="Midnight Black">
              <div class="color-preview" style="background: #1a1a1a;"></div>
              <span>Black</span>
            </button>
            <button class="color-btn" data-color="grey" onclick="changeFeltColor('grey')" title="Steel Grey">
              <div class="color-preview" style="background: #2a2a2a;"></div>
              <span>Grey</span>
            </button>
            <button class="color-btn" data-color="tan" onclick="changeFeltColor('tan')" title="Desert Tan">
              <div class="color-preview" style="background: #6b5642;"></div>
              <span>Tan</span>
            </button>
            <button class="color-btn" data-color="purple" onclick="changeFeltColor('purple')" title="Royal Purple">
              <div class="color-preview" style="background: #3a1450;"></div>
              <span>Purple</span>
            </button>
          </div>
        </div>
        
        <!-- 4-COLOR DECK -->
        <div class="host-section">
          <h4>ðŸƒ 4-Color Deck</h4>
          <p class="section-hint">Easier suit distinction (accessibility)</p>
          <label class="toggle-switch">
            <input type="checkbox" id="fourColorDeck" onchange="toggleFourColorDeck(this.checked)">
            <span class="toggle-slider"></span>
            <span class="toggle-label">Enable 4-Color Deck</span>
          </label>
          <p class="setting-note">Coming soon - will use distinct colors for each suit</p>
        </div>
        
        <!-- CARD BACK DESIGN -->
        <div class="host-section">
          <h4>ðŸŽ´ Card Back Design</h4>
          <p class="section-hint">Choose your card back style</p>
          <select id="cardBackSelect" onchange="changeCardBack(this.value)" class="settings-select">
            <option value="default">Classic</option>
            <option value="modern">Modern (Coming Soon)</option>
            <option value="minimal">Minimal (Coming Soon)</option>
            <option value="geometric">Geometric (Coming Soon)</option>
          </select>
        </div>
        
        <!-- ANIMATION SPEED -->
        <div class="host-section">
          <h4>âš¡ Animation Speed</h4>
          <p class="section-hint">Card dealing and chip animations</p>
          <select id="animSpeedSelect" onchange="changeAnimSpeed(this.value)" class="settings-select">
            <option value="fast">Fast (200ms)</option>
            <option value="normal" selected>Normal (400ms)</option>
            <option value="slow">Slow (600ms)</option>
          </select>
        </div>
        
        <!-- AUTO-MUCK -->
        <div class="host-section">
          <h4>ðŸ™ˆ Auto-Muck</h4>
          <p class="section-hint">Automatically hide losing hands at showdown</p>
          <label class="toggle-switch">
            <input type="checkbox" id="autoMuck" onchange="toggleAutoMuck(this.checked)">
            <span class="toggle-slider"></span>
            <span class="toggle-label">Enable Auto-Muck</span>
          </label>
        </div>
        
        <!-- CHIP DISPLAY FORMAT -->
        <div class="host-section">
          <h4>ðŸ’° Chip Display</h4>
          <p class="section-hint">How chips are shown</p>
          <select id="chipFormatSelect" onchange="changeChipFormat(this.value)" class="settings-select">
            <option value="full" selected>Full ($1,500)</option>
            <option value="compact">Compact ($1.5K)</option>
          </select>
        </div>
        
        <!-- ACTION CONFIRMATION -->
        <div class="host-section">
          <h4>âš ï¸ Action Confirmation</h4>
          <p class="section-hint">Confirm before big actions</p>
          <label class="toggle-switch">
            <input type="checkbox" id="actionConfirm" onchange="toggleActionConfirm(this.checked)">
            <span class="toggle-slider"></span>
            <span class="toggle-label">Confirm Big Bets/Folds</span>
          </label>
        </div>
        
        <!-- HOTKEYS -->
        <div class="host-section">
          <h4>âŒ¨ï¸ Keyboard Shortcuts</h4>
          <p class="section-hint">Quick actions with keyboard</p>
          <label class="toggle-switch">
            <input type="checkbox" id="hotkeysEnabled" onchange="toggleHotkeys(this.checked)">
            <span class="toggle-slider"></span>
            <span class="toggle-label">Enable Hotkeys</span>
          </label>
          <div class="hotkey-list" style="margin-top: 12px; font-size: 0.85rem; color: #9aa3b2;">
            <div><kbd>F</kbd> = Fold</div>
            <div><kbd>C</kbd> = Check/Call</div>
            <div><kbd>R</kbd> = Raise</div>
            <div><kbd>Space</kbd> = Confirm Action</div>
          </div>
        </div>
      </div>
    </div>
    
    <div class="controls">
      <button class="btn" id="startBtn" style="display:none">ðŸŽ® START HAND</button>
      <button class="btn" id="refreshBtn">ðŸ”„ REFRESH</button>
    </div>
    
    <!-- HIDDEN: Old top sections (deprecated - info now on table) -->
    <div style="display: none !important;">
      <div class="my-cards" id="communitySection">
        <div class="cards-display"></div>
        <span id="currentBet">0</span>
        <span id="currentBetDisplay">0</span>
      </div>
      
      <div class="my-cards" id="myCardsSection">
        <span id="turnIndicator"></span>
        <div class="cards-display" id="myCards"></div>
        <div id="handStrength">
          <div id="handStrengthText"></div>
        </div>
      </div>
    </div>
    
    <h2 style="margin-bottom: 15px;">Seats <span id="currentActor" style="font-size: 0.9rem; color: #ff5100; font-weight: normal;"></span></h2>
    
    <!-- ðŸŽ° POKER TABLE (Zoom-Locked) -->
    <div class="table-wrapper" id="tableWrapper">
      <div class="poker-table" id="pokerTable">
        <!-- Oval Felt Background -->
        <div class="table-felt"></div>
        
        <!-- Board Center (Community Cards + Pot) -->
        <div class="board-center">
          <div class="community-cards-center" id="communityCards"></div>
          <div class="pot-display-center">
            <div class="pot-label">POT</div>
            <div class="pot-amount" id="potAmount">$0</div>
          </div>
        </div>
        
        <!-- Seats Layer -->
        <div class="seats-layer">
          <div class="seats-grid" id="seats"></div>
        </div>
      </div>
    </div>
    
    <!-- ACTION BUTTONS (Below Table) -->
    <div id="actionButtons" style="display:none; margin-top: 30px; display: flex; justify-content: center; gap: 30px; max-width: 800px; margin-left: auto; margin-right: auto;">
      <button class="btn" id="foldBtn">FOLD</button>
      <button class="btn" id="callBtn"><span id="callBtnText">CALL</span> $<span id="callAmount">0</span></button>
      <button class="btn" id="raiseBtn">RAISE</button>
    </div>
    
    <!-- RAISE PANEL (Below Buttons) -->
    <div id="raisePanel" class="raise-panel" style="display: none;">
      <!-- Slider + Display Value (Top) -->
      <div class="raise-slider-section">
        <input type="range" id="raiseSlider" class="raise-slider" min="0" max="1000" step="1" />
        <div class="raise-slider-value" id="raiseSliderValue">$0</div>
        <input type="number" id="raiseAmount" class="raise-input" placeholder="Enter amount" />
      </div>
      
      <!-- Preset Buttons (Middle) -->
      <div class="raise-presets">
        <button class="raise-preset-btn" onclick="setRaisePreset('quarter')">1/4 Pot</button>
        <button class="raise-preset-btn" onclick="setRaisePreset('half')">1/2 Pot</button>
        <button class="raise-preset-btn" onclick="setRaisePreset('threequarter')">3/4 Pot</button>
        <button class="raise-preset-btn" onclick="setRaisePreset('pot')">Pot</button>
        <button class="raise-preset-btn" onclick="setRaisePreset('double')">2x Pot</button>
        <button class="raise-preset-btn" onclick="setRaisePreset('allin')">All-In</button>
      </div>
      
      <!-- Pot Info (Bottom) -->
      <div class="raise-info">
        <div class="raise-info-item">
          <span class="raise-info-label">Pot:</span>
          <span class="raise-info-value" id="raiseModalPot">$0</span>
        </div>
        <div class="raise-info-item">
          <span class="raise-info-label">Your Stack:</span>
          <span class="raise-info-value" id="raiseModalStack">$0</span>
        </div>
        <div class="raise-info-item">
          <span class="raise-info-label">Min Raise:</span>
          <span class="raise-info-value" id="raiseModalMin">$0</span>
        </div>
      </div>
      
      <!-- Submit Actions -->
      <div class="raise-actions">
        <button class="btn" style="background: #666; color: #fff; border-color: #666;" onclick="closeRaisePanel()">Cancel</button>
        <button class="btn" id="raiseSubmitBtn" onclick="submitRaise()">Raise</button>
      </div>
    </div>
    
    <div class="debug">
      <h4>Debug Console</h4>
      <div id="debugLog"></div>
    </div>
  </div>
  
  <script src="/socket.io/socket.io.js"></script>
  <script>
    // ============================================
    // GLOBAL STATE
    // ============================================
    let roomId = null;
    let userId = null;
    let gameId = null;
    let socket = null;
    let allInDontAskAgain = false; // Track "don't ask again" preference for current game session
    let pendingAllInAction = null; // Store pending ALL_IN action callback
    let showdownActions = {}; // Track who showed vs mucked: { userId: 'SHOW' | 'MUCK' }
    let isHost = false; // Track if current user is host
    let isClaimingSeat = false; // Prevent duplicate seat claims
    let currentGameState = null; // Track current game state for UI logic
    let myHoleCards = null; // Track user's hole cards to show on their seat tile
    let isSpectator = false; // Track if user is a spectator (not seated, game active)
    let mySeatIndex = null; // Track which seat the user is in (null if spectator)
    
    // ============================================
    // NAVIGATION PROTECTION
    // ============================================
    // Warn user before leaving active game
    window.addEventListener('beforeunload', (e) => {
      if (gameId && currentGameState && currentGameState.status !== 'waiting') {
        e.preventDefault();
        e.returnValue = 'You are in an active game. Are you sure you want to leave?';
        return e.returnValue;
      }
    });
    
    // Intercept navbar link clicks to confirm navigation
    document.addEventListener('DOMContentLoaded', () => {
      setTimeout(() => {
        const navLinks = document.querySelectorAll('.navbar-links a, .navbar-brand');
        navLinks.forEach(link => {
          link.addEventListener('click', (e) => {
            if (gameId && currentGameState && currentGameState.status !== 'waiting') {
              const confirmed = confirm('You are in an active game. Are you sure you want to leave?');
              if (!confirmed) {
                e.preventDefault();
              }
            }
          });
        });
      }, 100); // Small delay to ensure navbar is rendered
    });
    
    // ============================================
    // UTILITY: DEBUG LOGGING
    // ============================================
    function debug(message, data = null) {
      console.log(message, data);
      const log = document.getElementById('debugLog');
      const time = new Date().toLocaleTimeString();
      const entry = document.createElement('div');
      entry.textContent = `[${time}] ${message}`;
      if (data) {
        entry.textContent += ' ' + JSON.stringify(data, null, 2);
      }
      log.appendChild(entry);
      log.scrollTop = log.scrollHeight;
    }
    
    // ============================================
    // UTILITY: CARD IMAGE PATH CONVERTER
    // ============================================
    function getCardImagePath(card) {
      // Convert "Ah" â†’ "hearts_A.png", "Ks" â†’ "spades_K.png", "Td" â†’ "diamonds_10.png"
      if (!card || card.length < 2) return '/cards/back.png';
      
      const rank = card.slice(0, -1); // "A", "K", "T", "2", etc.
      const suitChar = card.slice(-1); // "h", "s", "d", "c"
      
      const suitMap = {
        'h': 'hearts',
        's': 'spades',
        'd': 'diamonds',
        'c': 'clubs'
      };
      
      const rankMap = {
        'T': '10'
      };
      
      const suit = suitMap[suitChar] || 'hearts';
      const finalRank = rankMap[rank] || rank;
      
      return `/cards/${suit}_${finalRank}.png`;
    }
    
    // ============================================
    // STEP 1: INITIALIZE
    // ============================================
    function init() {
      debug('ðŸŽ¬ Initializing minimal table...');
      
      // Get room ID from URL
      const urlParams = new URLSearchParams(window.location.search);
      roomId = urlParams.get('room');
      
      // PRIORITY 1: Check if user is authenticated via Supabase
      let isAuthenticated = false;
      
      try {
        // Check localStorage for Supabase session (standard location)
        const supabaseAuth = localStorage.getItem('sb-ztqcpuktihltfepnexcx-auth-token');
        if (supabaseAuth) {
          const authData = JSON.parse(supabaseAuth);
          if (authData && authData.user && authData.user.id) {
            userId = authData.user.id;
            isAuthenticated = true;
            sessionStorage.setItem('userId', userId);
            sessionStorage.setItem('userEmail', authData.user.email || 'Unknown');
            debug('âœ… Authenticated user detected:', { userId, email: authData.user.email });
          }
        }
      } catch (e) {
        debug('âš ï¸ Could not read Supabase auth:', e.message);
      }
      
      // PRIORITY 2: Try window.currentUser (if available)
      if (!userId && window.currentUser && window.currentUser.id) {
        userId = window.currentUser.id;
        isAuthenticated = true;
        sessionStorage.setItem('userId', userId);
        debug('âœ… Found window.currentUser:', userId);
      }
      
      // PRIORITY 3: Check sessionStorage
      if (!userId) {
        userId = sessionStorage.getItem('userId');
        
        // Validate UUID format (check if it's actually a UUID)
        const isValidUUID = userId && /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(userId);
        
        if (!isValidUUID) {
          // Clear invalid ID
          if (userId) {
            debug('âš ï¸ Invalid UUID detected, clearing:', userId);
            sessionStorage.removeItem('userId');
            userId = null;
          }
        }
      }
      
      // LAST RESORT: Generate guest UUID
      if (!userId) {
        userId = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
          const r = Math.random() * 16 | 0;
          const v = c === 'x' ? r : (r & 0x3 | 0x8);
          return v.toString(16);
        });
        sessionStorage.setItem('userId', userId);
        sessionStorage.setItem('isGuest', 'true');
        debug('âš ï¸ No auth found, generated guest UUID:', userId);
      }
      
      // Validate
      if (!roomId) {
        alert('âŒ No room ID in URL. Redirecting to lobby...');
        window.location.href = '/play';
        return;
      }
      
      debug('âœ… Initialized', { roomId, userId, isAuthenticated });
      
      // Wire up buttons
      document.getElementById('startBtn').onclick = startHand;
      document.getElementById('refreshBtn').onclick = loadRoom;
      
      // Initialize host controls settings from localStorage
      initializeHostSettings();
      
      // Connect WebSocket
      connectWebSocket();
      
      // CRITICAL: Hydrate game state before loading room
      hydrateGameState();
    }
    
    // Initialize host settings from localStorage
    function initializeHostSettings() {
      // Restore action timer
      const savedTimer = localStorage.getItem('pokergeek_action_timer');
      if (savedTimer) {
        actionTimerSeconds = parseInt(savedTimer);
        const display = document.getElementById('actionTimerDisplay');
        if (display) {
          display.textContent = actionTimerSeconds === 0 ? 'OFF' : `${actionTimerSeconds}s`;
          // Mark active button
          document.querySelectorAll('.timer-btn').forEach(btn => {
            const btnValue = btn.textContent.trim();
            if ((actionTimerSeconds === 0 && btnValue === 'OFF') ||
                (btnValue === `${actionTimerSeconds}s`)) {
              btn.classList.add('active');
            }
          });
        }
      }
      
      // Restore auto-start setting
      const autoStart = localStorage.getItem('pokergeek_auto_start');
      if (autoStart === 'false') {
        const checkbox = document.getElementById('autoStartToggle');
        if (checkbox) checkbox.checked = false;
      }
      
      // Restore spectator mode setting
      const spectatorMode = localStorage.getItem('pokergeek_spectator_mode');
      if (spectatorMode === 'false') {
        const checkbox = document.getElementById('spectatorToggle');
        if (checkbox) checkbox.checked = false;
      }
      
      // Expand both panels by default
      setTimeout(() => {
        const hostContent = document.getElementById('hostControlsContent');
        const playerContent = document.getElementById('playerSettingsContent');
        if (hostContent) hostContent.classList.add('expanded');
        if (playerContent) playerContent.classList.add('expanded');
      }, 100);
      
      debug('âš™ï¸ Host settings initialized from localStorage');
    }
    
    // ============================================
    // CRITICAL: HYDRATE GAME STATE ON REFRESH
    // ============================================
    async function hydrateGameState() {
      debug('ðŸ’§ Hydrating game state...');
      
      try {
        const response = await fetch(`/api/engine/hydrate/${roomId}/${userId}`);
        
        if (!response.ok) {
          debug('âš ï¸ Hydration failed, loading lobby state');
          loadRoom();
          return;
        }
        
        const data = await response.json();
        
        if (!data.hasActiveGame) {
          debug('â¸ï¸  No active game - loading lobby');
          loadRoom();
          return;
        }
        
        // ACTIVE GAME FOUND - RESTORE STATE
        debug('ðŸŽ® ACTIVE GAME FOUND - RESTORING STATE', {
          handNumber: data.gameState.handNumber,
          street: data.gameState.street,
          pot: data.gameState.pot
        });
        
        gameId = data.gameId;
        currentGameState = data.gameState; // Store for UI logic
        
        // Show community section
        document.getElementById('communitySection').style.display = 'block';
        
        // Render community cards
        if (data.gameState.communityCards && data.gameState.communityCards.length > 0) {
          renderCommunityCards(data.gameState.communityCards);
        }
        
        // Update pot and bet
        document.getElementById('potAmount').textContent = data.gameState.pot || 0;
        document.getElementById('currentBet').textContent = data.gameState.currentBet || 0;
        
        // Show current actor
        const actorText = document.getElementById('currentActor');
        if (data.gameState.currentActorSeat !== undefined) {
          actorText.textContent = `(Seat ${data.gameState.currentActorSeat}'s turn)`;
          actorText.style.display = 'inline';
        }
        
        // Render my hole cards
        if (data.myHoleCards && data.myHoleCards.length === 2) {
          myHoleCards = data.myHoleCards; // Store globally
          renderMyCards(data.myHoleCards);
        }
        
        // Show/hide action buttons based on turn
        const actionButtons = document.getElementById('actionButtons');
        if (data.isMyTurn && data.gameState.status === 'IN_PROGRESS') {
          actionButtons.style.display = 'flex';
          updateActionButtons(data.gameState);
        } else {
          actionButtons.style.display = 'none';
        }
        
        // Hide START button (game is active)
        document.getElementById('startBtn').style.display = 'none';
        
        // Update seat card backings (pass myHoleCards to show on my seat)
        updateSeatCardBackings(data.gameState, myHoleCards);
        
        // Update position badges (dealer, SB, BB)
        updatePositionBadges(data.gameState);
        
        debug('âœ… Game state restored successfully');
        
        // Still load room to get seat info
        loadRoom();
        
      } catch (error) {
        debug('âŒ Hydration error', { error: error.message });
        console.error('Hydration error:', error);
        loadRoom(); // Fallback to normal flow
      }
    }
    
    // ============================================
    // STEP 2: WEBSOCKET CONNECTION
    // ============================================
    function connectWebSocket() {
      debug('ðŸ”Œ Connecting WebSocket...');
      
      socket = io();
      
      socket.on('connect', () => {
        debug('âœ… Socket connected', { socketId: socket.id });
        document.getElementById('socketStatus').classList.add('connected');
        
        // Join room
        socket.emit('join_room', { roomId, userId });
        debug('ðŸ“¡ Sent join_room event', { roomId, userId });
      });
      
      socket.on('disconnect', (reason) => {
        debug('ðŸ”´ Socket disconnected', { reason });
        document.getElementById('socketStatus').classList.remove('connected');
      });
      
      socket.on('seat_update', (data) => {
        debug('ðŸª‘ Seat update received', data);
        loadRoom();
      });
      
      socket.on('hand_complete', (data) => {
        debug('ðŸ† Hand complete event received', data);
        
        if (data.gameState) {
          handleHandComplete(data.gameState);
        }
      });
      
      socket.on('hand_started', (data) => {
        debug('ðŸƒ Hand started event', data);
        
        // CRITICAL: Clear UI from previous hand (especially for guests)
        document.getElementById('communityCards').innerHTML = '';
        document.getElementById('myCards').innerHTML = '';
        document.getElementById('actionButtons').style.display = 'none';
        // Keep hand strength visible - it shows current hand throughout the game
        document.getElementById('myCardsSection').style.display = 'none';
        document.getElementById('startBtn').style.display = 'none';
        
        // Reset all-in runout flag for new hand
        isAllInRunout = false;
        previousCommunityCards = [];
        
        // Reset showdown actions tracking for new hand
        showdownActions = {};
        
        // Reset "don't ask again" preference for new hand (but keep for game session)
        // allInDontAskAgain stays true if user checked it (only resets on new game/room)
        
        // Store game state ID
        if (data.gameStateId) {
          gameId = data.gameStateId;
        }
        
        // Display public game state
        if (data.gameState) {
          const gs = data.gameState;
          currentGameState = gs; // Store for UI logic
          
          // Show community section
          document.getElementById('communitySection').style.display = 'block';
          document.getElementById('potAmount').textContent = gs.pot || 0;
          document.getElementById('currentBet').textContent = gs.currentBet || 0;
          
          // Show current actor
          const actorText = document.getElementById('currentActor');
          if (gs.currentActorSeat !== undefined) {
            actorText.textContent = `(Seat ${gs.currentActorSeat}'s turn)`;
            actorText.style.display = 'inline';
          }
          
          debug('âœ… Game state updated', { pot: gs.pot, currentBet: gs.currentBet, street: gs.street });
          
          // Update seat card backings (pass myHoleCards to show on my seat)
          updateSeatCardBackings(gs, myHoleCards);
          
          // Update position badges (dealer, SB, BB)
          updatePositionBadges(gs);
        }
        
        // Fetch my hole cards (for guests who didn't initiate the hand)
        fetchMyCards();
        
        // Reload to show updated seats/chips
        setTimeout(loadRoom, 500);
      });
      
      // Listen for action processed events
      socket.on('action_processed', (data) => {
        debug('ðŸŽ® Action processed', data);
        
        // Update game state display
        if (data.gameState) {
          const gs = data.gameState;
          currentGameState = gs; // Store for UI logic
          
          document.getElementById('potAmount').textContent = gs.pot || 0;
          document.getElementById('currentBet').textContent = gs.currentBet || 0;
          
          // Update current actor
          const actorText = document.getElementById('currentActor');
          if (gs.currentActorSeat !== undefined) {
            actorText.textContent = `(Seat ${gs.currentActorSeat}'s turn)`;
          }
          
          // Show community cards if any
          if (gs.communityCards && gs.communityCards.length > 0) {
            renderCommunityCards(gs.communityCards);
          }
          
          // CRITICAL: Show/update action buttons based on game state
          const actionButtons = document.getElementById('actionButtons');
          
          if (gs.status === 'IN_PROGRESS') {
            actionButtons.style.display = 'flex';
            updateActionButtons(gs);
          } else {
            actionButtons.style.display = 'none';
          }
          
          // Check if hand is over
          if (gs.status === 'COMPLETED') {
            handleHandComplete(gs);
          }
          
          // Update seat card backings (show folds, etc) (pass myHoleCards to show on my seat)
          updateSeatCardBackings(gs, myHoleCards);
          
          // Update position badges (dealer, SB, BB)
          updatePositionBadges(gs);
          
          // Update chips in real-time (CRITICAL: show chip stacks decreasing as players bet)
          updateSeatChips(gs.players);
        }
      });
      
      // Listen for showdown actions (show/muck)
      socket.on('showdown_action', (data) => {
        debug('ðŸƒ Showdown action received:', data);
        
        const { action, userId: actionUserId, seatIndex, nickname, holeCards } = data;
        
        // Track showdown action
        if (actionUserId) {
          showdownActions[actionUserId] = action;
        }
        
        if (action === 'SHOW' && holeCards) {
          // REPLACE card backs with actual card images
          const cardBacksContainer = document.querySelector(`.seat-cards[data-seat-index="${seatIndex}"]`);
          if (cardBacksContainer) {
            cardBacksContainer.innerHTML = ''; // Clear card backs
            
            // Display actual cards using images
            holeCards.forEach(card => {
              const cardImg = document.createElement('img');
              cardImg.className = 'seat-card-front';
              cardImg.src = getCardImagePath(card);
              cardImg.alt = card;
              cardImg.onerror = function() {
                // Fallback if image doesn't exist
                this.src = '/cards/back.png';
              };
              cardBacksContainer.appendChild(cardImg);
            });
            
            debug(`âœ… @${nickname} showed cards: ${holeCards.join(' ')}`);
          }
          
          // Update winner banner if this is the winner showing
          updateWinnerBannerIfNeeded();
        } else if (action === 'MUCK') {
          // Grey out card backs (already folded styling)
          const cardBacksContainer = document.querySelector(`.seat-cards[data-seat-index="${seatIndex}"]`);
          if (cardBacksContainer) {
            const cardBacks = cardBacksContainer.querySelectorAll('.seat-card-back');
            cardBacks.forEach(back => {
              back.classList.add('folded'); // Grey them out
            });
            
            debug(`âœ… @${nickname} mucked cards`);
          }
          
          // Update winner banner if winner mucked
          updateWinnerBannerIfNeeded();
        }
      });
      
      // NOTE: Private hole cards are sent via HTTP response in startHand()
      // We'll add WebSocket private emit in Phase 2b
      
      socket.on('game_started', (data) => {
        debug('ðŸŽ® Game started event', data);
        if (data.gameId) {
          gameId = data.gameId;
        }
        setTimeout(loadRoom, 1000);
      });
      
      // Host control events
      socket.on('blinds_updated', (data) => {
        debug('ðŸ’° Blinds updated immediately', data);
      });
      
      socket.on('blinds_queued', (data) => {
        debug('â³ Blinds queued for next hand', data);
        // Show non-blocking notification to all players
      });
      
      socket.on('chips_adjusted', (data) => {
        debug('ðŸ’µ Chips adjusted by host', data);
        loadRoom(); // Refresh to show new chip amounts
        if (isHost) loadHostControls(); // Update host dropdown
      });
      
      socket.on('chips_queued', (data) => {
        debug('â³ Chips queued for next hand', data);
        if (isHost) {
          showToast('â³ Chips will update at end of hand', 'info');
        }
        if (isHost) loadHostControls(); // Update host dropdown to show new values
      });
      
      socket.on('player_kicked', (data) => {
        if (data.userId === userId) {
          alert('âŒ You have been removed from the game by the host.');
          window.location.href = '/';
        }
      });
      
      // Seat request events
      socket.on('seat_request_pending', (data) => {
        debug('ðŸª‘ Seat request received:', data);
        if (isHost) {
          showSeatRequestNotification(data);
          loadPendingSeatRequests(); // Refresh list
        }
      });
      
      socket.on('seat_request_resolved', (data) => {
        debug('âœ… Seat request resolved:', data);
        if (isHost) {
          loadPendingSeatRequests(); // Refresh list
          closeHostNotification(); // Close popup if open
        }
      });
      
      socket.on('seat_request_approved', (data) => {
        debug('âœ… Seat request approved:', data);
        showNotification('Your seat request was approved!', 'success');
        setTimeout(() => loadRoom(), 1000); // Reload to show seat
      });
      
      socket.on('seat_request_rejected', (data) => {
        debug('âŒ Seat request rejected:', data);
        showNotification('Your seat request was rejected by the host', 'error');
      });
      
      socket.on('seat_request_sent', (data) => {
        debug('ðŸ“¤ Seat request sent:', data);
        // Already handled in claimSeat, but good to confirm
      });
      
      socket.on('you_busted', (data) => {
        debug('ðŸ’€ You busted:', data);
        showNotification('You went all-in and lost. You can request a seat again.', 'info');
      });
      
      socket.on('player_busted', (data) => {
        debug('ðŸ’€ Player busted:', data);
        if (isHost) {
          showNotification(`Player busted and was removed from seat ${data.seatIndex}`, 'info');
        }
        loadRoom(); // Refresh seats
      });
    }
    
    // ============================================
    // STEP 3: LOAD ROOM STATE
    // ============================================
    async function loadRoom() {
      debug('ðŸŒŠ Fetching room state...');
      
      try {
        // Get room info
        const roomResponse = await fetch(`/api/engine/room/${roomId}`);
        if (!roomResponse.ok) {
          throw new Error(`Failed to get room: ${roomResponse.status}`);
        }
        const roomData = await roomResponse.json();
        debug('âœ… Room data received', roomData);
        
        // Get seats
        const seatsResponse = await fetch(`/api/engine/seats/${roomId}`);
        if (!seatsResponse.ok) {
          throw new Error(`Failed to get seats: ${seatsResponse.status}`);
        }
        const seatsData = await seatsResponse.json();
        debug('âœ… Seats data received', seatsData);
        
        // Update room code
        document.getElementById('roomCode').textContent = roomData.room?.code || 'N/A';
        
        // Store game ID if exists
        if (roomData.room?.gameId) {
          gameId = roomData.room.gameId;
        }
        
        // Render seats
        renderSeats(seatsData.seats, roomData.room);
        
        // Detect if user is a spectator (not seated, game active)
        const mySeat = seatsData.seats?.find(s => s && s.userId === userId);
        isHost = roomData.room?.hostId === userId; // Update global isHost
        const roomIsActive = !!(roomData.room?.gameId || roomData.room?.game_id); // Game active if gameId exists
        isSpectator = !mySeat && roomIsActive && !isHost; // Spectator = not seated, game active, not host
        mySeatIndex = mySeat ? mySeat.seatIndex : null;
        
        debug('ðŸ‘ï¸ Spectator check:', { 
          isSpectator, 
          mySeat: !!mySeat, 
          roomIsActive, 
          isHost,
          mySeatIndex 
        });
        
        // Show START button ONLY if:
        // 1. Room status is NOT ACTIVE (no game in progress)
        // 2. 2+ players seated
        // 3. User is host (or show "waiting" if not host)
        const seatedCount = seatsData.occupiedCount || 0;
        
        // CRITICAL: If room is ACTIVE, NEVER show START button (game is in progress)
        if (roomIsActive) {
          document.getElementById('startBtn').style.display = 'none';
          debug('ðŸŽ® Game active - START button hidden');
        } else if (isHost && seatedCount >= 2) {
          document.getElementById('startBtn').style.display = 'inline-block';
          document.getElementById('startBtn').disabled = false;
          document.getElementById('startBtn').textContent = 'ðŸŽ® START HAND';
          debug('ðŸŽ® START HAND button enabled (HOST)', { seatedCount });
        } else if (!isHost && seatedCount >= 2) {
          document.getElementById('startBtn').style.display = 'inline-block';
          document.getElementById('startBtn').disabled = true;
          document.getElementById('startBtn').textContent = 'â³ WAITING FOR HOST';
          debug('â³ Waiting for host to start', { hostId: roomData.room?.hostId });
        } else {
          document.getElementById('startBtn').style.display = 'none';
        }
        
        // Load host controls if user is host
        if (isHost) {
          loadHostControls();
        }
        
      } catch (error) {
        debug('âŒ Load room error', { error: error.message });
        console.error('Load room error:', error);
      }
    }
    
    // ============================================
    // STEP 4: RENDER SEATS
    // ============================================
    function renderSeats(seats, room) {
      debug('ðŸŽ¨ Rendering seats...', { seatCount: seats ? seats.length : 0 });
      
      const seatsDiv = document.getElementById('seats');
      seatsDiv.innerHTML = '';
      
      // Check if game is active (hide empty seats during game)
      const isGameActive = currentGameState && (currentGameState.status === 'IN_PROGRESS' || currentGameState.status === 'COMPLETED');
      
      // Create 10 seats (0-9)
      for (let i = 0; i < 10; i++) {
        const seat = seats ? seats[i] : null;
        const isEmpty = !seat || !seat.userId;
        
        // Skip empty seats if game is active
        if (isEmpty && isGameActive) {
          debug(`â© Skipping empty seat ${i} (game active)`);
          continue;
        }
        
        const div = document.createElement('div');
        const isMe = seat && seat.userId === userId;
        
        div.className = 'seat';
        div.dataset.seatIndex = i; // Add data attribute for positioning
        if (isEmpty) {
          div.className += ' empty';
        } else if (isMe) {
          div.className += ' taken me';
        } else {
          div.className += ' taken';
        }
        
        const label = document.createElement('div');
        label.className = 'seat-label';
        label.textContent = `Seat ${i}`;
        // Hide seat label during games to save space for player name
        if (isGameActive && !isEmpty) {
          label.style.display = 'none';
        }
        
        const player = document.createElement('div');
        player.className = 'seat-player';
        
        const chips = document.createElement('div');
        chips.className = 'seat-chips';
        
        // Card backings container
        const cardBacksContainer = document.createElement('div');
        cardBacksContainer.className = 'seat-cards';
        cardBacksContainer.dataset.seatIndex = i;
        
        // Position badges container (dealer, SB, BB)
        const positionBadges = document.createElement('div');
        positionBadges.className = 'position-badges';
        positionBadges.dataset.seatIndex = i;
        
        if (isEmpty) {
          // Empty seat - allow claiming (even for spectators during active game)
          player.textContent = 'ðŸª‘ EMPTY';
          const roomIsActive = !!(room?.gameId || room?.game_id); // Game active if gameId exists
          if (roomIsActive && !isHost) {
            chips.textContent = 'Request seat';
          } else {
            chips.textContent = 'Click to claim';
          }
          div.onclick = () => claimSeat(i);
        } else {
          // Display nickname with rank color and badge (async)
          const displayName = seat.nickname || `Guest_${seat.userId.substring(0, 6)}`;
          player.textContent = `@${displayName}`;
          if (isMe) player.textContent += ' (YOU)';
          chips.textContent = `$${(seat.chips || 1000).toLocaleString()}`;
          
          // Apply rank styling and badge (async, non-blocking)
          if (window.UsernameStyling && seat.userId) {
            (async () => {
              try {
                const rankColor = await window.UsernameStyling.getRankColor(seat.userId);
                const badge = await window.UsernameStyling.getTopBadge(seat.userId);
                const usernameText = displayName + (isMe ? ' (YOU)' : '');
                player.innerHTML = window.UsernameStyling.formatUsernameWithRankAndBadge(
                  usernameText, 
                  rankColor, 
                  badge
                );
              } catch (error) {
                console.error('Error applying rank styling:', error);
                // Fallback to default display
                player.textContent = `@${displayName}` + (isMe ? ' (YOU)' : '');
              }
            })();
          }
        }
        
        div.appendChild(label);
        div.appendChild(player);
        div.appendChild(chips);
        div.appendChild(cardBacksContainer); // Add card backs container
        div.appendChild(positionBadges); // Add position badges
        
        seatsDiv.appendChild(div);
      }
      
      // Apply circular positions
      applySeatPositions();
      
      // Update card backings if game is active (pass myHoleCards to show on my seat)
      if (currentGameState) {
        updateSeatCardBackings(currentGameState, myHoleCards);
      }
      
      debug('âœ… Seats rendered');
    }
    
    // ============================================
    // STEP 4B: UPDATE SEAT CHIPS IN REAL-TIME
    // ============================================
    function updateSeatChips(players) {
      if (!players) return;
      
      debug('ðŸ’° Updating seat chips', { playerCount: players.length });
      
      players.forEach(player => {
        // Find the seat element
        const seatsDiv = document.getElementById('seats');
        const seatDivs = seatsDiv.querySelectorAll('.seat');
        
        seatDivs.forEach(seatDiv => {
          const label = seatDiv.querySelector('.seat-label');
          if (label && label.textContent === `Seat ${player.seatIndex}`) {
            // Update chips display
            const chipsDiv = seatDiv.querySelector('.seat-chips');
            if (chipsDiv && !chipsDiv.textContent.includes('Click to claim')) {
              chipsDiv.textContent = `$${(player.chips || 0).toLocaleString()}`;
            }
          }
        });
      });
    }
    
    // ============================================
    // STEP 4B2: UPDATE POSITION BADGES (DEALER, SB, BB)
    // ============================================
    function updatePositionBadges(gameState) {
      if (!gameState) return;
      
      debug('ðŸŽ° Updating position badges', { 
        dealer: gameState.dealerPosition, 
        sb: gameState.sbPosition, 
        bb: gameState.bbPosition 
      });
      
      // Clear all existing badges first
      document.querySelectorAll('.position-badges').forEach(container => {
        container.innerHTML = '';
      });
      
      // Show badges during active game or showdown
      if (gameState.status !== 'IN_PROGRESS' && gameState.status !== 'COMPLETED') return;
      
      // Add dealer badge
      if (gameState.dealerPosition !== undefined) {
        const dealerContainer = document.querySelector(`.position-badges[data-seat-index="${gameState.dealerPosition}"]`);
        if (dealerContainer) {
          const badge = document.createElement('span');
          badge.className = 'position-badge dealer';
          badge.textContent = 'D';
          badge.title = 'Dealer';
          dealerContainer.appendChild(badge);
        }
      }
      
      // Add small blind badge
      if (gameState.sbPosition !== undefined) {
        const sbContainer = document.querySelector(`.position-badges[data-seat-index="${gameState.sbPosition}"]`);
        if (sbContainer) {
          const badge = document.createElement('span');
          badge.className = 'position-badge sb';
          badge.textContent = 'SB';
          badge.title = 'Small Blind';
          sbContainer.appendChild(badge);
        }
      }
      
      // Add big blind badge
      if (gameState.bbPosition !== undefined) {
        const bbContainer = document.querySelector(`.position-badges[data-seat-index="${gameState.bbPosition}"]`);
        if (bbContainer) {
          const badge = document.createElement('span');
          badge.className = 'position-badge bb';
          badge.textContent = 'BB';
          badge.title = 'Big Blind';
          bbContainer.appendChild(badge);
        }
      }
    }
    
    // ============================================
    // STEP 4C: UPDATE CARD BACKINGS ON SEATS
    // ============================================
    function updateSeatCardBackings(gameState, myHoleCards = null) {
      if (!gameState || !gameState.players) {
        debug('âš ï¸ No gameState or players for card backings');
        return;
      }
      
      debug('ðŸƒ Updating seat card backings', { 
        players: gameState.players.length, 
        status: gameState.status,
        playerSeats: gameState.players.map(p => p.seatIndex),
        myHoleCards: myHoleCards
      });
      
      // Loop through all seats
      for (let i = 0; i < 9; i++) {
        const cardBacksContainer = document.querySelector(`.seat-cards[data-seat-index="${i}"]`);
        if (!cardBacksContainer) {
          debug(`âš ï¸ No card backs container found for seat ${i}`);
          continue;
        }
        
        // Find player in this seat
        const player = gameState.players.find(p => p.seatIndex === i);
        
        // Clear existing card backs
        cardBacksContainer.innerHTML = '';
        
        // Show card backs for IN_PROGRESS or COMPLETED (showdown)
        const shouldShowCards = player && (gameState.status === 'IN_PROGRESS' || gameState.status === 'COMPLETED');
        
        if (shouldShowCards) {
          const isMe = player.userId === userId;
          
          // SPECTATOR LOGIC: Spectators NEVER see hole cards (only card backs)
          // UNLESS cards are shown at showdown (handled by showdown_action event)
          if (isSpectator) {
            // Spectators always see card backs (never hole cards)
            debug(`ðŸ‘ï¸ Spectator view: Showing card backs for seat ${i} (folded: ${player.folded})`);
            for (let j = 0; j < 2; j++) {
              const cardBack = document.createElement('img');
              cardBack.className = 'seat-card-back';
              cardBack.src = '/cards/back.png';
              cardBack.alt = 'Card';
              
              // Grey out if folded
              if (player.folded) {
                cardBack.classList.add('folded');
              }
              
              cardBacksContainer.appendChild(cardBack);
            }
          } else if (isMe && myHoleCards && myHoleCards.length === 2) {
            // MY seat - show actual cards (only if I'm seated, not spectator)
            debug(`âœ… Adding MY actual cards for seat ${i}`, { cards: myHoleCards });
            myHoleCards.forEach(card => {
              const cardImg = document.createElement('img');
              cardImg.className = 'seat-card-front';
              cardImg.src = getCardImagePath(card);
              cardImg.alt = card;
              cardImg.onerror = function() {
                this.src = '/cards/back.png';
              };
              cardBacksContainer.appendChild(cardImg);
            });
          } else {
            // Other players - show card backs
            debug(`âœ… Adding card backs for seat ${i} (folded: ${player.folded}, status: ${gameState.status})`);
            for (let j = 0; j < 2; j++) {
              const cardBack = document.createElement('img');
              cardBack.className = 'seat-card-back';
              cardBack.src = '/cards/back.png';
              cardBack.alt = 'Card';
              
              // Grey out if folded
              if (player.folded) {
                cardBack.classList.add('folded');
              }
              
              cardBacksContainer.appendChild(cardBack);
            }
          }
        } else {
          debug(`âŒ Not showing cards for seat ${i} (hasPlayer: ${!!player}, status: ${gameState.status})`);
        }
      }
    }
    
    // ============================================
    // STEP 5: CLAIM SEAT
    // ============================================
    async function claimSeat(seatIndex) {
      // Prevent duplicate calls
      if (isClaimingSeat) {
        debug('â¸ï¸  Already claiming a seat, ignoring duplicate call');
        return;
      }
      
      isClaimingSeat = true;
      debug(`ðŸª‘ Attempting to claim seat ${seatIndex}...`);
      
      // Check if game is active (requires approval)
      // Game is active if: currentGameState exists OR startBtn is hidden OR gameId exists
      const startBtn = document.getElementById('startBtn');
      const roomIsActive = currentGameState?.status === 'IN_PROGRESS' || 
                           (startBtn && startBtn.style.display === 'none') ||
                           !!gameId;
      
      // Prompt for nickname (only if not already set and pre-game)
      let nickname = null;
      if (!roomIsActive) {
        nickname = prompt(
          'ðŸŽ® Choose your nickname (3-15 characters):\n\n' +
          'Letters, numbers, and underscores only.\n' +
          'Leave blank for auto-generated name.',
          ''
        );
        
        // User cancelled
        if (nickname === null) {
          isClaimingSeat = false;
          return;
        }
        
        // Validate nickname if provided
        if (nickname && (nickname.length < 3 || nickname.length > 15)) {
          console.error('Nickname must be 3-15 characters');
          isClaimingSeat = false;
          return;
        }
        
        if (nickname && !/^[a-zA-Z0-9_]+$/.test(nickname)) {
          console.error('Nickname can only contain letters, numbers, and underscores');
          isClaimingSeat = false;
          return;
        }
      }
      
      try {
        const response = await fetch(`/api/engine/claim-seat`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            roomId: roomId,
            userId: userId,
            seatIndex: seatIndex,
            nickname: nickname || undefined,
            requestedChips: 1000 // Default buy-in
          })
        });
        
        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || 'Failed to claim seat');
        }
        
        const data = await response.json();
        
        // If requires approval, show notification
        if (data.requiresApproval) {
          debug('â³ Seat request sent, waiting for host approval', { requestId: data.requestId });
          showNotification('Seat request sent to host. Waiting for approval...', 'info');
          isClaimingSeat = false;
          return;
        }
        
        // Direct claim successful
        const displayName = data.seat?.nickname || `Guest_${userId.substring(0, 6)}`;
        debug('âœ… Seat claimed successfully', { displayName, seatIndex });
        
        // Reload room state
        setTimeout(() => {
          loadRoom();
          isClaimingSeat = false; // Reset flag after reload
        }, 500);
        
      } catch (error) {
        debug('âŒ Claim seat error', { error: error.message });
        console.error('Failed to claim seat:', error.message);
        showNotification(error.message || 'Failed to claim seat', 'error');
        isClaimingSeat = false; // Reset flag on error
      }
    }
    
    // ============================================
    // STEP 6: START HAND / NEXT HAND
    // ============================================
    async function startHand() {
      const btn = document.getElementById('startBtn');
      const isNextHand = btn.textContent.includes('NEXT');
      
      debug(isNextHand ? 'ðŸŽ¬ Starting NEXT hand...' : 'ðŸŽ® Starting FIRST hand...');
      
      try {
        // Clear UI before starting new hand
        myHoleCards = null; // Clear stored hole cards
        document.getElementById('communityCards').innerHTML = '';
        document.getElementById('myCards').innerHTML = '';
        document.getElementById('potAmount').textContent = '0';
        document.getElementById('currentBet').textContent = '0';
        document.getElementById('actionButtons').style.display = 'none';
        // Keep hand strength visible - it shows current hand throughout the game
        document.getElementById('myCardsSection').style.display = 'none';
        
        // Use correct endpoint
        const endpoint = isNextHand ? '/api/engine/next-hand' : '/api/engine/deal-cards';
        
        const response = await fetch(endpoint, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            roomId: roomId,
            userId: userId
          })
        });
        
        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || 'Failed to start hand');
        }
        
        const data = await response.json();
        debug('âœ… Hand started', data);
        
        // Store game state ID
        if (data.gameStateId) {
          gameId = data.gameStateId;
        }
        
        // Show game state immediately
        if (data.gameState) {
          const gs = data.gameState;
          
          document.getElementById('communitySection').style.display = 'block';
          document.getElementById('potAmount').textContent = gs.pot || 0;
          document.getElementById('currentBet').textContent = gs.currentBet || 0;
          
          const actorText = document.getElementById('currentActor');
          if (gs.currentActorSeat !== undefined) {
            actorText.textContent = `(Seat ${gs.currentActorSeat}'s turn)`;
            actorText.style.display = 'inline';
          }
          
          // Show hand number
          if (gs.handNumber) {
            debug(`ðŸ“Š Hand #${gs.handNumber}`);
          }
          
          debug('âœ… Game state displayed', { pot: gs.pot, currentBet: gs.currentBet, handNumber: gs.handNumber });
        }
        
        // Show cards
        if (data.cards && data.cards.length === 2) {
          myHoleCards = data.cards; // Store globally
          renderMyCards(data.cards);
        }
        
        // Reset button text
        btn.textContent = 'ðŸŽ® START HAND';
        btn.style.display = 'none';
        
        // Reload seats to show updated chips
        setTimeout(loadRoom, 500);
        
      } catch (error) {
        debug('âŒ Start hand error', { error: error.message });
        alert('âŒ Failed to start hand: ' + error.message);
      }
    }
    
    // ============================================
    // STEP 7: RENDER MY CARDS
    // ============================================
    async function renderMyCards(cards) {
      debug('ðŸƒ Rendering hole cards', { cards });
      
      const section = document.getElementById('myCardsSection');
      const cardsDiv = document.getElementById('myCards');
      
      section.style.display = 'block';
      cardsDiv.innerHTML = '';
      
      cards.forEach(card => {
        const cardImg = document.createElement('img');
        cardImg.className = 'card card-img';
        cardImg.src = getCardImagePath(card);
        cardImg.alt = card;
        cardImg.onerror = function() {
          // Fallback if image doesn't exist
          this.src = '/cards/back.png';
        };
        cardsDiv.appendChild(cardImg);
      });
      
      // Show action buttons
      document.getElementById('actionButtons').style.display = 'flex';
      
      // Fetch game state and let updateActionButtons handle everything
      try {
        const gameStateResponse = await fetch(`/api/engine/game/${roomId}`);
        if (gameStateResponse.ok) {
          const gameData = await gameStateResponse.json();
          updateActionButtons(gameData);
          evaluateHandStrength(cards, gameData.communityCards || []);
        }
      } catch (error) {
        debug('âš ï¸ Could not fetch game state', error);
      }
      
      debug('âœ… Cards rendered');
    }
    
    // ============================================
    // STEP 7B: FETCH MY HOLE CARDS
    // ============================================
    async function fetchMyCards() {
      debug('ðŸ”’ Fetching my hole cards...');
      
      try {
        const response = await fetch(`/api/engine/my-cards/${roomId}/${userId}`);
        
        if (!response.ok) {
          const error = await response.json();
          console.log('âš ï¸ Could not fetch cards:', error.error);
          return; // Not an error - might not be in this hand
        }
        
        const data = await response.json();
        debug('âœ… My cards fetched', data);
        
        if (data.cards && data.cards.length === 2) {
          myHoleCards = data.cards; // Store globally
          renderMyCards(data.cards);
        }
        
      } catch (error) {
        debug('âš ï¸ Fetch my cards error', { error: error.message });
      }
    }
    
    // ============================================
    // STEP 8: PERFORM ACTION (with debounce)
    // ============================================
    let actionInProgress = false;
    
    async function performAction(action, amount) {
      if (actionInProgress) {
        debug('âš ï¸ Action in progress, blocking double-click');
        return;
      }
      
      actionInProgress = true;
      debug(`ðŸŽ® Performing action: ${action} $${amount}`);
      
      try {
        const response = await fetch('/api/engine/action', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            roomId: roomId,
            userId: userId,
            action: action,
            amount: amount
          })
        });
        
        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || 'Failed to perform action');
        }
        
        const data = await response.json();
        debug('âœ… Action performed', data);
        
        // UI will update via WebSocket broadcast automatically
        
      } catch (error) {
        debug('âŒ Action error', { error: error.message });
        // Silently ignore "Hand is complete" errors - this is expected at showdown
        if (error.message.includes('Hand is complete')) {
          debug('â„¹ï¸ Hand already complete - ignoring action');
          return;
        }
        // For other errors, just log them (no blocking alert)
        console.error('Action failed:', error.message);
      } finally {
        // Reset after 500ms
        setTimeout(() => {
          actionInProgress = false;
          debug('ðŸ”“ Action debounce released');
        }, 500);
      }
    }
    
    // ============================================
    // STEP 8A: UPDATE ACTION BUTTONS (Single source of truth)
    // ============================================
    function updateActionButtons(gameState) {
      // Find my player
      const myPlayer = gameState.players?.find(p => p.userId === userId);
      if (!myPlayer) return;
      
      const currentBet = gameState.currentBet || 0;
      const myBet = myPlayer.bet || 0;
      const callAmount = currentBet - myBet;
      const isMyTurn = gameState.currentActorSeat === myPlayer.seatIndex;
      
      debug('ðŸ”„ Updating buttons', { currentBet, myBet, callAmount, isMyTurn });
      
      const foldBtn = document.getElementById('foldBtn');
      const callBtn = document.getElementById('callBtn');
      const raiseBtn = document.getElementById('raiseBtn');
      const callBtnText = document.getElementById('callBtnText');
      const callAmountSpan = document.getElementById('callAmount');
      
      // SET ONCLICK HANDLERS ONCE
      if (callAmount === 0) {
        callBtnText.textContent = 'CHECK';
        callAmountSpan.style.display = 'none';
        callBtn.onclick = () => performAction('CHECK', 0);
      } else {
        callBtnText.textContent = 'CALL';
        callAmountSpan.style.display = 'inline';
        callAmountSpan.textContent = callAmount;
        callBtn.onclick = () => performAction('CALL', callAmount);
      }
      
      foldBtn.onclick = () => performAction('FOLD', 0);
      raiseBtn.onclick = () => openRaiseModal(currentBet, myPlayer.chips, myPlayer.bet || 0);
      
      // APPLY VISUAL STATE
      if (isMyTurn) {
        // YOUR TURN - active pulse
        foldBtn.classList.add('active');
        callBtn.classList.add('active');
        raiseBtn.classList.add('active');
        foldBtn.classList.remove('not-your-turn');
        callBtn.classList.remove('not-your-turn');
        raiseBtn.classList.remove('not-your-turn');
        foldBtn.disabled = false;
        callBtn.disabled = false;
        raiseBtn.disabled = false;
        debug('âœ… Your turn - buttons active with pulse');
      } else {
        // NOT YOUR TURN - blur
        foldBtn.classList.remove('active');
        callBtn.classList.remove('active');
        raiseBtn.classList.remove('active');
        foldBtn.classList.add('not-your-turn');
        callBtn.classList.add('not-your-turn');
        raiseBtn.classList.add('not-your-turn');
        foldBtn.disabled = true;
        callBtn.disabled = true;
        raiseBtn.disabled = true;
        debug('â¸ï¸ Not your turn - buttons blurred');
      }
      
      // HIGHLIGHT CURRENT PLAYER SEAT
      document.querySelectorAll('.seat').forEach(seat => {
        seat.classList.remove('current-turn');
      });
      
      const currentSeat = document.querySelector(`.seat[data-seat-index="${gameState.currentActorSeat}"]`);
      if (currentSeat) {
        currentSeat.classList.add('current-turn');
        debug(`ðŸ’¡ Highlighted seat ${gameState.currentActorSeat}`);
      }
    }
    
    // ============================================
    // STEP 8B: HANDLE HAND COMPLETE
    // ============================================
    function handleHandComplete(gameState) {
      debug('ðŸ† Hand complete', gameState);
      
      // Hide action buttons (keep hand strength visible)
      document.getElementById('actionButtons').style.display = 'none';
      
      if (gameState.winners && gameState.winners.length > 0) {
        const winner = gameState.winners[0];
        const potAmount = winner.amount;
        
        debug(`ðŸ† Winner: Seat ${winner.seatIndex} wins $${potAmount}`);
        
        // 1. KEEP POT VISIBLE (don't zero it yet)
        document.getElementById('potAmount').textContent = potAmount;
        
        // 2. HIGHLIGHT WINNER'S SEAT
        highlightWinnerSeat(winner.seatIndex);
        
        // 3. SHOW WINNER BANNER (delay if all-in runout is still animating)
        // NOTE: Hand description will only show if winner shows cards (handled in updateWinnerBannerIfNeeded)
        const banner = document.getElementById('winnerBanner');
        const winnerPlayer = gameState.players.find(p => p.seatIndex === winner.seatIndex);
        const winnerNickname = winnerPlayer ? `@${winnerPlayer.nickname || 'Player'}` : `Seat ${winner.seatIndex}`;
        
        // Initially show without hand description (will update when winner shows)
        banner.innerHTML = `<span class="winner-name">ðŸ† ${winnerNickname}</span> WINS <span class="winner-amount">$${potAmount.toLocaleString()}</span>`;
        banner.dataset.winnerUserId = winner.userId || winnerPlayer?.userId;
        banner.dataset.winnerHandDescription = winner.handDescription || '';
        banner.dataset.winnerNickname = winnerNickname;
        banner.dataset.potAmount = potAmount.toLocaleString();
        
        // Delay showing banner if all-in runout cards are still being dealt
        if (isAllInRunout) {
          // Calculate delay: wait for all cards to be dealt + animation time
          // Each card takes 800ms delay + 500ms animation = 1300ms per card
          // Add extra buffer for the last card's animation to complete
          const cardsToDeal = (gameState.communityCards?.length || 0) - previousCommunityCards.length;
          const delayPerCard = 800; // Delay between cards
          const animationTime = 500; // Time for card flip animation
          const delayMs = Math.max(0, (cardsToDeal * delayPerCard) + animationTime + 300); // Extra 300ms buffer
          
          debug('â±ï¸ Delaying winner banner', { cardsToDeal, delayMs, isAllInRunout });
          
          setTimeout(() => {
            updateWinnerBannerIfNeeded();
            banner.classList.add('show');
            debug('âœ… Winner banner shown after delay');
          }, delayMs);
        } else {
          updateWinnerBannerIfNeeded();
          banner.classList.add('show');
        }
        
        // 4. SHOW/MUCK CONTROLS - PRINCIPLE: ALL players who reached showdown get controls
        // This means: anyone who didn't fold gets show/muck options, regardless of win/loss
        // Winners can choose to muck if they want privacy, losers can show if they want
        const myPlayer = gameState.players?.find(p => p.userId === userId);
        const didIFold = myPlayer && myPlayer.folded;
        
        debug('ðŸƒ Show/muck check:', {
          hasMyPlayer: !!myPlayer,
          myUserId: userId,
          mySeatIndex: myPlayer?.seatIndex,
          didIFold,
          principle: 'All non-folded players get show/muck controls'
        });
        
        // PRINCIPLE: Show controls to ALL players who didn't fold (reached showdown)
        // This includes winners (they can muck for privacy) and losers (they can show)
        if (myPlayer && !didIFold) {
          debug('ðŸƒ Showing show/muck controls (you reached showdown)', {
            myUserId: myPlayer.userId,
            mySeatIndex: myPlayer.seatIndex,
            didIFold
          });
          document.getElementById('showdownControls').classList.add('show');
        } else {
          debug('ðŸƒ NOT showing controls', { 
            myPlayer: !!myPlayer, 
            didIFold,
            reason: didIFold ? 'You folded' : 'Player not found'
          });
        }
        
        // 5. AFTER 3 SECONDS: Hide banner, transfer chips, START COUNTDOWN
        setTimeout(() => {
          // Hide banner only (keep show/muck controls visible)
          banner.classList.remove('show');
          
          // Clear winner highlight
          clearWinnerHighlight();
          
          // Update all seat chips (show final amounts)
          updateSeatChips(gameState.players);
          
          // Zero the pot (chips now in winner's stack)
          document.getElementById('potAmount').textContent = '0';
          
          // START COUNTDOWN FOR NEXT HAND
          const startBtn = document.getElementById('startBtn');
          startBtn.style.display = 'inline-block';
          startBtn.disabled = true;
          
          let countdown = 5;
          startBtn.textContent = `â° NEXT HAND (${countdown}s)`;
          
          const countdownInterval = setInterval(() => {
            countdown--;
            if (countdown > 0) {
              startBtn.textContent = `â° NEXT HAND (${countdown}s)`;
            } else {
              clearInterval(countdownInterval);
              
              // Hide show/muck controls when countdown finishes
              document.getElementById('showdownControls').classList.remove('show');
              
              if (isHost) {
                startBtn.textContent = 'â–¶ï¸ STARTING...';
                debug('ðŸŽ¬ Auto-starting next hand (HOST)...');
                startHand();
              } else {
                startBtn.textContent = 'â³ STARTING...';
                debug('â³ Waiting for host to start next hand (GUEST)');
              }
            }
          }, 1000);
          
        }, 3000); // 3 second delay to show winner
      }
    }
    
    // ============================================
    // RAISE MODAL FUNCTIONS
    // ============================================
    let raiseModalData = {
      currentBet: 0,
      pot: 0,
      stack: 0,
      minRaise: 0,
      maxRaise: 0
    };
    
    function openRaiseModal(currentBet, playerStack, currentPlayerBet = 0) {
      const pot = parseInt(document.getElementById('potAmount').textContent.replace(/\$/g, '')) || 0;
      const minRaise = currentBet * 2 || 20;
      // maxRaise = total stack (chips + current bet) - this is the maximum total bet possible
      const maxRaise = playerStack + currentPlayerBet; // Total stack for ALL-IN
      
      raiseModalData = {
        currentBet,
        pot,
        stack: playerStack,
        minRaise,
        maxRaise
      };
      
      // Update panel info
      document.getElementById('raiseModalPot').textContent = '$' + pot;
      document.getElementById('raiseModalStack').textContent = '$' + playerStack;
      document.getElementById('raiseModalMin').textContent = '$' + minRaise;
      
      // Setup slider
      const slider = document.getElementById('raiseSlider');
      slider.min = minRaise;
      slider.max = maxRaise;
      slider.value = minRaise;
      
      // Setup input
      const input = document.getElementById('raiseAmount');
      input.min = minRaise;
      input.max = maxRaise;
      input.value = minRaise;
      
      // Update display
      document.getElementById('raiseSliderValue').textContent = '$' + minRaise;
      
      // Show panel
      document.getElementById('raisePanel').style.display = 'block';
      
      // Wire up slider/input sync
      slider.oninput = function() {
        const value = parseInt(this.value);
        input.value = value;
        document.getElementById('raiseSliderValue').textContent = '$' + value;
      };
      
      input.oninput = function() {
        const value = parseInt(this.value) || minRaise;
        const clamped = Math.max(minRaise, Math.min(maxRaise, value));
        slider.value = clamped;
        document.getElementById('raiseSliderValue').textContent = '$' + clamped;
      };
    }
    
    function closeRaisePanel() {
      document.getElementById('raisePanel').style.display = 'none';
    }
    
    function setRaisePreset(preset) {
      const { pot, minRaise, maxRaise } = raiseModalData;
      let amount;
      
      switch(preset) {
        case 'quarter':
          amount = Math.floor(pot * 0.25);
          break;
        case 'half':
          amount = Math.floor(pot * 0.5);
          break;
        case 'threequarter':
          amount = Math.floor(pot * 0.75);
          break;
        case 'pot':
          amount = pot;
          break;
        case 'double':
          amount = pot * 2;
          break;
        case 'allin':
          // ALL-IN: Show custom confirmation modal
          showAllInConfirmation(maxRaise, () => {
            closeRaisePanel();
            performAction('ALL_IN', 0);
          });
          return; // Exit early, don't update slider
        default:
          amount = minRaise;
      }
      
      // Clamp to valid range
      amount = Math.max(minRaise, Math.min(maxRaise, amount));
      
      // Update UI
      document.getElementById('raiseAmount').value = amount;
      document.getElementById('raiseSlider').value = amount;
      document.getElementById('raiseSliderValue').textContent = '$' + amount;
    }
    
    function submitRaise() {
      const amount = parseInt(document.getElementById('raiseAmount').value);
      const { minRaise, maxRaise, stack } = raiseModalData;
      
      if (amount < minRaise) {
        alert(`Minimum raise is $${minRaise}`);
        return;
      }
      
      if (amount > maxRaise) {
        alert(`Maximum raise is $${maxRaise} (your total stack)`);
        return;
      }
      
      // If amount equals total stack (ALL-IN), show custom confirmation
      if (amount === maxRaise) {
        showAllInConfirmation(maxRaise, () => {
          closeRaisePanel();
          performAction('ALL_IN', 0); // ALL_IN doesn't need amount parameter
        });
      } else {
        closeRaisePanel();
        performAction('RAISE', amount);
      }
    }
    
    // Helper: Highlight winner's seat
    function highlightWinnerSeat(seatIndex) {
      const seatsDiv = document.getElementById('seats');
      const seatDivs = seatsDiv.querySelectorAll('.seat');
      
      seatDivs.forEach(seatDiv => {
        const label = seatDiv.querySelector('.seat-label');
        if (label && label.textContent === `Seat ${seatIndex}`) {
          seatDiv.classList.add('winner');
        }
      });
    }
    
    // Helper: Clear winner highlight
    function clearWinnerHighlight() {
      const seatsDiv = document.getElementById('seats');
      const seatDivs = seatsDiv.querySelectorAll('.seat.winner');
      seatDivs.forEach(seatDiv => {
        seatDiv.classList.remove('winner');
      });
    }
    
    // Helper: Update winner banner based on whether winner showed cards
    function updateWinnerBannerIfNeeded() {
      const banner = document.getElementById('winnerBanner');
      if (!banner || !banner.dataset.winnerUserId) return;
      
      const winnerUserId = banner.dataset.winnerUserId;
      const winnerHandDescription = banner.dataset.winnerHandDescription;
      const winnerNickname = banner.dataset.winnerNickname || 'Player';
      const potAmount = banner.dataset.potAmount || '0';
      const winnerAction = showdownActions[winnerUserId];
      
      // Only show hand description if winner showed their cards
      if (winnerAction === 'SHOW' && winnerHandDescription) {
        banner.innerHTML = `<span class="winner-name">ðŸ† ${winnerNickname}</span> WINS <span class="winner-amount">$${potAmount}</span><small style="color: #00d4aa; text-shadow: 0 0 10px rgba(0, 212, 170, 0.3);">${winnerHandDescription}</small>`;
      } else if (winnerAction === 'MUCK') {
        banner.innerHTML = `<span class="winner-name">ðŸ† ${winnerNickname}</span> WINS <span class="winner-amount">$${potAmount}</span><small style="color: #9aa3b2; font-style: italic;">(Cards mucked)</small>`;
      } else {
        // Winner hasn't shown/mucked yet - just show win without hand description
        banner.innerHTML = `<span class="winner-name">ðŸ† ${winnerNickname}</span> WINS <span class="winner-amount">$${potAmount}</span>`;
      }
    }
    
    // ============================================
    // SHOW/MUCK FUNCTIONALITY
    // ============================================
    async function showCards() {
      debug('ðŸƒ Player chose to SHOW cards');
      
      try {
        const response = await fetch('/api/engine/showdown-action', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            roomId: roomId,
            userId: userId,
            action: 'SHOW'
          })
        });
        
        if (!response.ok) {
          const error = await response.json();
          console.error('âŒ Show cards error:', error);
          debug('âŒ Show cards failed', error);
          return;
        }
        
        const result = await response.json();
        debug('âœ… Cards shown to table', result);
        
        // Track that we showed
        showdownActions[userId] = 'SHOW';
        
        // Hide controls
        document.getElementById('showdownControls').classList.remove('show');
        
        // Update winner banner if we're the winner
        updateWinnerBannerIfNeeded();
        
        // NO NEED to manually display - WebSocket will handle it for all players
        
      } catch (error) {
        console.error('âŒ Show cards network error:', error);
        debug('âŒ Show cards network error', { error: error.message });
      }
    }
    
    async function muckCards() {
      debug('ðŸ—‘ï¸ Player chose to MUCK cards');
      
      try {
        const response = await fetch('/api/engine/showdown-action', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            roomId: roomId,
            userId: userId,
            action: 'MUCK'
          })
        });
        
        if (!response.ok) {
          const error = await response.json();
          console.error('âŒ Muck cards error:', error);
          debug('âŒ Muck cards failed', error);
          return;
        }
        
        const result = await response.json();
        debug('âœ… Cards mucked', result);
        
        // Track that we mucked
        showdownActions[userId] = 'MUCK';
        
        // Hide controls
        document.getElementById('showdownControls').classList.remove('show');
        
        // Update winner banner if we're the winner
        updateWinnerBannerIfNeeded();
        
      } catch (error) {
        console.error('âŒ Muck cards network error:', error);
        debug('âŒ Muck cards network error', { error: error.message });
      }
    }
    
    // ============================================
    // ALL-IN CONFIRMATION MODAL FUNCTIONS
    // ============================================
    function showAllInConfirmation(amount, onConfirm) {
      // If user checked "don't ask again", skip confirmation
      if (allInDontAskAgain) {
        onConfirm();
        return;
      }
      
      // Store the callback
      pendingAllInAction = onConfirm;
      
      // Update modal content
      document.getElementById('allinConfirmAmount').textContent = `$${amount.toLocaleString()}`;
      document.getElementById('allinDontAskAgain').checked = false;
      
      // Show modal
      document.getElementById('allinConfirmOverlay').classList.add('show');
    }
    
    function confirmAllIn() {
      const dontAskAgain = document.getElementById('allinDontAskAgain').checked;
      if (dontAskAgain) {
        allInDontAskAgain = true; // Remember for this game session
      }
      
      // Hide modal
      document.getElementById('allinConfirmOverlay').classList.remove('show');
      
      // Execute pending action
      if (pendingAllInAction) {
        pendingAllInAction();
        pendingAllInAction = null;
      }
    }
    
    function cancelAllIn() {
      // Hide modal
      document.getElementById('allinConfirmOverlay').classList.remove('show');
      
      // Clear pending action
      pendingAllInAction = null;
    }
    
    // ============================================
    // STEP 8C: RENDER COMMUNITY CARDS
    // ============================================
    // Track previous community cards to avoid re-animating
    let previousCommunityCards = [];
    let isAllInRunout = false; // Track if we're in an all-in runout animation

    function renderCommunityCards(cards) {
      debug('ðŸƒ Rendering community cards', { cards });
      
      const communityDiv = document.getElementById('communityCards');
      
      // Determine which cards are NEW (not in previous render)
      const newCards = cards.filter(card => !previousCommunityCards.includes(card));
      
      // Detect all-in runout: if all players are all-in AND cards increased by more than 1
      const allPlayersAllIn = currentGameState?.players?.every(p => 
        p.folded || p.status === 'ALL_IN'
      ) || false;
      const isRunout = newCards.length > 1 && allPlayersAllIn && !isAllInRunout;
      
      // Only clear and re-render if cards actually changed
      if (newCards.length > 0 || cards.length < previousCommunityCards.length) {
        // If all-in runout, animate cards one by one
        if (isRunout) {
          isAllInRunout = true;
          communityDiv.innerHTML = '';
          
          // Show existing cards first
          previousCommunityCards.forEach(card => {
            const cardImg = document.createElement('img');
            cardImg.className = 'card-img';
            cardImg.src = getCardImagePath(card);
            cardImg.alt = card;
            cardImg.onerror = function() {
              this.src = '/cards/back.png';
            };
            communityDiv.appendChild(cardImg);
          });
          
          // Deal new cards one by one with dramatic delay
          newCards.forEach((card, index) => {
            setTimeout(() => {
              const cardImg = document.createElement('img');
              cardImg.className = 'card-img new-card';
              cardImg.style.opacity = '0';
              cardImg.style.transform = 'scale(0.5) rotateY(180deg)';
              cardImg.src = getCardImagePath(card);
              cardImg.alt = card;
              cardImg.onerror = function() {
                this.src = '/cards/back.png';
              };
              communityDiv.appendChild(cardImg);
              
              // Animate card flip-in
              setTimeout(() => {
                cardImg.style.transition = 'all 0.5s ease-out';
                cardImg.style.opacity = '1';
                cardImg.style.transform = 'scale(1) rotateY(0deg)';
              }, 50);
              
              // If this is the last card, reset flag
              if (index === newCards.length - 1) {
                setTimeout(() => {
                  isAllInRunout = false;
                }, 600);
              }
            }, index * 800); // 800ms delay between each card for dramatic effect
          });
          
          // Update tracking immediately (for hand strength evaluation)
          previousCommunityCards = [...cards];
        } else {
          // Normal card rendering (no animation)
          communityDiv.innerHTML = '';
          
          cards.forEach(card => {
            const cardImg = document.createElement('img');
            cardImg.className = 'card-img';
            
            // Only add 'new-card' class if this card wasn't in previous render
            if (newCards.includes(card)) {
              cardImg.classList.add('new-card');
            }
            
            cardImg.src = getCardImagePath(card);
            cardImg.alt = card;
            cardImg.onerror = function() {
              this.src = '/cards/back.png';
            };
            communityDiv.appendChild(cardImg);
          });
          
          // Update tracking
          previousCommunityCards = [...cards];
        }
      }
      
      document.getElementById('communitySection').style.display = 'block';
      
      // Re-evaluate hand strength when community cards change
      const myCardsDiv = document.getElementById('myCards');
      if (myCardsDiv && myCardsDiv.dataset.cards) {
        const myCards = JSON.parse(myCardsDiv.dataset.cards);
        evaluateHandStrength(myCards, cards);
      }
    }
    
    // ============================================
    // STEP 8D: EVALUATE AND DISPLAY HAND STRENGTH
    // ============================================
    function evaluateHandStrength(holeCards, communityCards) {
      // Store cards for re-evaluation
      const myCardsDiv = document.getElementById('myCards');
      myCardsDiv.dataset.cards = JSON.stringify(holeCards);
      
      if (!holeCards || holeCards.length !== 2) return;
      if (!communityCards) communityCards = [];
      
      const allCards = [...holeCards, ...communityCards];
      
      // Simple hand evaluation (client-side approximation)
      const handDescription = getSimpleHandDescription(allCards);
      
      // Display hand strength (always show when player has cards)
      const strengthDiv = document.getElementById('handStrength');
      const textDiv = document.getElementById('handStrengthText');
      
      if (handDescription) {
        textDiv.textContent = handDescription;
        strengthDiv.style.display = 'block';
        debug('ðŸŽ´ Hand strength:', handDescription);
      } else {
        // Hide if no description (no cards yet)
        strengthDiv.style.display = 'none';
      }
    }
    
    /**
     * Simple client-side hand evaluation
     * Returns description like "Pair of AA", "Two Pair - QQ33"
     */
    function getSimpleHandDescription(cards) {
      if (cards.length < 2) return 'Incomplete Hand';
      
      // Parse ranks
      const rankMap = { '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, 'T': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14 };
      const rankCharMap = { 2: '2', 3: '3', 4: '4', 5: '5', 6: '6', 7: '7', 8: '8', 9: '9', 10: 'T', 11: 'J', 12: 'Q', 13: 'K', 14: 'A' };
      
      const ranks = cards.map(card => rankMap[card[0]]);
      const suits = cards.map(card => card[1]);
      
      // Count frequencies
      const rankCounts = {};
      ranks.forEach(r => rankCounts[r] = (rankCounts[r] || 0) + 1);
      
      const pairs = [];
      const trips = [];
      const quads = [];
      
      for (const [rank, count] of Object.entries(rankCounts)) {
        if (count === 4) quads.push(parseInt(rank));
        if (count === 3) trips.push(parseInt(rank));
        if (count === 2) pairs.push(parseInt(rank));
      }
      
      // Sort descending
      pairs.sort((a, b) => b - a);
      trips.sort((a, b) => b - a);
      quads.sort((a, b) => b - a);
      
      // Check flush
      const suitCounts = {};
      suits.forEach(s => suitCounts[s] = (suitCounts[s] || 0) + 1);
      const isFlush = Object.values(suitCounts).some(c => c >= 5);
      
      // Check straight (simplified)
      const uniqueRanks = [...new Set(ranks)].sort((a, b) => b - a);
      let isStraight = false;
      if (uniqueRanks.length >= 5) {
        for (let i = 0; i <= uniqueRanks.length - 5; i++) {
          if (uniqueRanks[i] - uniqueRanks[i + 4] === 4) {
            isStraight = true;
            break;
          }
        }
      }
      
      // Determine hand
      if (quads.length > 0) {
        return `Four of a Kind (${rankCharMap[quads[0]]}s)`;
      }
      if (trips.length > 0 && pairs.length > 0) {
        return `Full House (${rankCharMap[trips[0]]}${rankCharMap[trips[0]]}${rankCharMap[trips[0]]} over ${rankCharMap[pairs[0]]}${rankCharMap[pairs[0]]})`;
      }
      if (isFlush) {
        return 'Flush';
      }
      if (isStraight) {
        return 'Straight';
      }
      if (trips.length > 0) {
        return `Three of a Kind (${rankCharMap[trips[0]]}s)`;
      }
      if (pairs.length >= 2) {
        return `Two Pair (${rankCharMap[pairs[0]]}${rankCharMap[pairs[0]]} ${rankCharMap[pairs[1]]}${rankCharMap[pairs[1]]})`;
      }
      if (pairs.length === 1) {
        return `Pair (${rankCharMap[pairs[0]]}${rankCharMap[pairs[0]]})`;
      }
      
      // High card
      const highCard = Math.max(...ranks);
      return `High Card (${rankCharMap[highCard]})`;
    }
    
    // ============================================
    // STEP 9: RENDER COMMUNITY CARDS + POT
    // ============================================
    function renderCommunity(communityCards, pot, currentBet) {
      if (!communityCards || communityCards.length === 0) {
        document.getElementById('communitySection').style.display = 'none';
        return;
      }
      
      debug('ðŸŽ´ Rendering community cards', { communityCards, pot, currentBet });
      
      const section = document.getElementById('communitySection');
      const cardsDiv = document.getElementById('communityCards');
      
      section.style.display = 'block';
      cardsDiv.innerHTML = '';
      
      communityCards.forEach(card => {
        const cardDiv = document.createElement('div');
        cardDiv.className = 'card';
        cardDiv.style.backgroundImage = `url('/cards/${card}.png')`;
        cardsDiv.appendChild(cardDiv);
      });
      
      document.getElementById('potAmount').textContent = pot || 0;
      document.getElementById('currentBet').textContent = currentBet || 0;
      
      debug('âœ… Community cards rendered');
    }
    
    // ============================================
    // STEP 10: UPDATE TURN INDICATOR
    // ============================================
    function updateTurnIndicator(currentActorSeat) {
      const indicator = document.getElementById('turnIndicator');
      const actorText = document.getElementById('currentActor');
      
      if (currentActorSeat === null || currentActorSeat === undefined) {
        indicator.style.display = 'none';
        actorText.textContent = '';
        return;
      }
      
      // Check if it's our turn
      // (This is simplified - need to map userId to seat)
      actorText.textContent = `(Waiting for Seat ${currentActorSeat})`;
      
      // TODO: Properly detect if current actor is us
      // indicator.style.display = 'inline';
    }
    
    // ============================================
    // ðŸŽ›ï¸ HOST CONTROLS FUNCTIONS
    // ============================================
    function toggleHostControls() {
      const content = document.getElementById('hostControlsContent');
      const icon = document.getElementById('hostToggleIcon');
      content.classList.toggle('expanded');
      icon.classList.toggle('expanded');
    }
    
    function togglePlayerSettings() {
      const content = document.getElementById('playerSettingsContent');
      const icon = document.getElementById('playerSettingsToggle');
      content.classList.toggle('expanded');
      icon.classList.toggle('expanded');
    }
    
    async function loadHostControls() {
      if (!isHost) {
        // Non-hosts: hide host controls, show player settings
        document.getElementById('hostControlsPanel').style.display = 'none';
        document.getElementById('playerSettingsPanel').style.display = 'block';
        return;
      }
      
      // Hosts: show BOTH host controls AND player settings
      debug('ðŸŽ›ï¸ Loading host controls...');
      document.getElementById('hostControlsPanel').style.display = 'block';
      document.getElementById('playerSettingsPanel').style.display = 'block';
      
      try {
        const response = await fetch(`/api/engine/host-controls/${roomId}/${userId}`);
        if (!response.ok) {
          console.error('Failed to load host controls');
          return;
        }
        
        const data = await response.json();
        debug('âœ… Host controls loaded', data);
        
        // Update blinds inputs
        document.getElementById('hostSmallBlindInput').value = data.room.smallBlind;
        document.getElementById('hostBigBlindInput').value = data.room.bigBlind;
        
        // Render players
        renderHostPlayerList(data.players);
        
        // Update chip adjustment dropdown
        updateChipAdjustmentDropdown(data.players);
        
        // Load pending seat requests
        loadPendingSeatRequests();
        
      } catch (error) {
        console.error('Error loading host controls:', error);
      }
    }
    
    // ============================================
    // SEAT REQUEST FUNCTIONS
    // ============================================
    let currentSeatRequest = null; // Store current request for popup
    
    async function loadPendingSeatRequests() {
      if (!isHost) return;
      
      try {
        const response = await fetch(`/api/rooms/${roomId}/seat-requests?hostId=${userId}`);
        if (!response.ok) {
          console.error('Failed to load seat requests');
          return;
        }
        
        const data = await response.json();
        const container = document.getElementById('pendingSeatRequests');
        
        if (!data.requests || data.requests.length === 0) {
          container.innerHTML = '<div class="empty-state">No pending requests</div>';
          return;
        }
        
        container.innerHTML = data.requests.map(req => `
          <div class="seat-request-item">
            <div class="seat-request-info">
              <div class="seat-request-name">@${req.username}</div>
              <div class="seat-request-details">
                Seat ${req.seatIndex} â€¢ $${req.requestedChips.toLocaleString()} chips
              </div>
            </div>
            <div class="seat-request-actions">
              <button class="seat-request-btn reject" onclick="rejectSeatRequestFromList(${req.id})">âŒ</button>
              <button class="seat-request-btn approve" onclick="approveSeatRequestFromList(${req.id})">âœ…</button>
            </div>
          </div>
        `).join('');
      } catch (error) {
        console.error('Error loading seat requests:', error);
      }
    }
    
    function showSeatRequestNotification(data) {
      currentSeatRequest = data;
      const overlay = document.getElementById('hostNotificationOverlay');
      document.getElementById('requestUsername').textContent = `@${data.username}`;
      document.getElementById('requestSeatIndex').textContent = data.seatIndex;
      document.getElementById('requestChipAmount').value = data.requestedChips || 1000;
      overlay.style.display = 'flex';
    }
    
    function closeHostNotification() {
      const overlay = document.getElementById('hostNotificationOverlay');
      overlay.style.display = 'none';
      currentSeatRequest = null;
    }
    
    async function approveSeatRequest() {
      if (!currentSeatRequest) return;
      
      const approvedChips = parseInt(document.getElementById('requestChipAmount').value) || currentSeatRequest.requestedChips;
      
      try {
        const response = await fetch(`/api/rooms/${roomId}/approve-seat-request`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            hostId: userId,
            requestId: currentSeatRequest.requestId,
            approvedChips: approvedChips
          })
        });
        
        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || 'Failed to approve request');
        }
        
        showNotification(`Seat request approved! Player joins with $${approvedChips.toLocaleString()} chips`, 'success');
        closeHostNotification();
        loadRoom(); // Refresh seats
      } catch (error) {
        console.error('Error approving seat request:', error);
        showNotification(error.message || 'Failed to approve request', 'error');
      }
    }
    
    async function rejectSeatRequest() {
      if (!currentSeatRequest) return;
      
      try {
        const response = await fetch(`/api/rooms/${roomId}/reject-seat-request`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            hostId: userId,
            requestId: currentSeatRequest.requestId
          })
        });
        
        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || 'Failed to reject request');
        }
        
        showNotification('Seat request rejected', 'info');
        closeHostNotification();
      } catch (error) {
        console.error('Error rejecting seat request:', error);
        showNotification(error.message || 'Failed to reject request', 'error');
      }
    }
    
    async function approveSeatRequestFromList(requestId) {
      const request = await getSeatRequestById(requestId);
      if (!request) return;
      
      currentSeatRequest = { ...request, requestId: request.id };
      showSeatRequestNotification(currentSeatRequest);
    }
    
    async function rejectSeatRequestFromList(requestId) {
      try {
        const response = await fetch(`/api/rooms/${roomId}/reject-seat-request`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            hostId: userId,
            requestId: requestId
          })
        });
        
        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || 'Failed to reject request');
        }
        
        showNotification('Seat request rejected', 'info');
        loadPendingSeatRequests(); // Refresh list
      } catch (error) {
        console.error('Error rejecting seat request:', error);
        showNotification(error.message || 'Failed to reject request', 'error');
      }
    }
    
    async function getSeatRequestById(requestId) {
      try {
        const response = await fetch(`/api/rooms/${roomId}/seat-requests?hostId=${userId}`);
        if (!response.ok) return null;
        
        const data = await response.json();
        return data.requests?.find(r => r.id === requestId) || null;
      } catch (error) {
        console.error('Error getting seat request:', error);
        return null;
      }
    }
    
    // Simple notification function (fallback if showToast doesn't exist)
    function showNotification(message, type = 'info') {
      // Try showToast first (if it exists)
      if (typeof showToast === 'function') {
        showToast(message, type);
        return;
      }
      
      // Fallback: simple alert or console
      console.log(`[${type.toUpperCase()}] ${message}`);
      // Could also create a toast element here if needed
    }
    
    function renderHostPlayerList(players) {
      const container = document.getElementById('hostPlayerList');
      const countEl = document.getElementById('hostPlayerCount');
      
      countEl.textContent = players.length;
      
      if (players.length === 0) {
        container.innerHTML = '<div class="empty-state">No players seated</div>';
        return;
      }
      
      container.innerHTML = players.map(player => `
        <div class="player-item">
          <div class="player-item-info">
            <div class="player-item-name">
              @${player.nickname}
              ${player.userId === userId ? ' (YOU)' : ''}
            </div>
            <div class="player-item-details">
              <span>Seat ${player.seatIndex}</span>
              <span class="player-item-chips">$${player.chips}</span>
            </div>
          </div>
          ${player.userId !== userId ? `
            <button class="host-btn kick" onclick="kickPlayer('${player.userId}')">
              ðŸš« KICK
            </button>
          ` : ''}
        </div>
      `).join('');
    }
    
    async function kickPlayer(targetUserId) {
      if (!confirm('Are you sure you want to kick this player? They will be removed from their seat.')) {
        return;
      }
      
      debug('ðŸš« Kicking player:', targetUserId);
      
      try {
        const response = await fetch('/api/engine/host-controls/kick-player', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            roomId,
            hostId: userId,
            targetUserId
          })
        });
        
        if (!response.ok) {
          const error = await response.json();
          alert(`Failed to kick player: ${error.error}`);
          return;
        }
        
        debug('âœ… Player kicked');
        loadHostControls(); // Refresh panel
        loadRoom(); // Refresh seats
        
      } catch (error) {
        console.error('Error kicking player:', error);
        alert('Failed to kick player');
      }
    }
    
    async function updateBlinds() {
      const smallBlind = parseInt(document.getElementById('hostSmallBlindInput').value);
      const bigBlind = parseInt(document.getElementById('hostBigBlindInput').value);
      
      if (bigBlind <= smallBlind) {
        alert('Big blind must be greater than small blind!');
        return;
      }
      
      if (smallBlind < 1 || bigBlind < 2) {
        alert('Blinds must be positive integers!');
        return;
      }
      
      debug('ðŸ’° Updating blinds:', { smallBlind, bigBlind });
      
      try {
        const response = await fetch('/api/engine/host-controls/update-blinds', {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            roomId,
            hostId: userId,
            smallBlind,
            bigBlind
          })
        });
        
        if (!response.ok) {
          const error = await response.json();
          alert(`Failed to update blinds: ${error.error}`);
          return;
        }
        
        const result = await response.json();
        debug('âœ… Blinds updated', result);
        
        if (result.applied === 'queued') {
          alert(`â³ Blinds queued: $${smallBlind}/$${bigBlind}\n\nWill apply after current hand ends.`);
        } else {
          alert(`âœ… Blinds updated to $${smallBlind}/$${bigBlind}`);
        }
        
      } catch (error) {
        console.error('Error updating blinds:', error);
        alert('Failed to update blinds');
      }
    }
    
    // ============================================
    // HOST: CHIP ADJUSTMENT
    // ============================================
    function updateChipAdjustmentDropdown(players) {
      const chipAdjustSeat = document.getElementById('chipAdjustSeat');
      if (!chipAdjustSeat) return;
      
      if (players.length === 0) {
        chipAdjustSeat.innerHTML = '<option value="">No players seated</option>';
        return;
      }
      
      chipAdjustSeat.innerHTML = '<option value="">Select a player...</option>' + 
        players.map(player => `
          <option value="${player.seatIndex}">
            Seat ${player.seatIndex}: @${player.nickname} ($${player.chips.toLocaleString()})
          </option>
        `).join('');
    }
    
    async function adjustPlayerChips() {
      const seatSelect = document.getElementById('chipAdjustSeat');
      const amountInput = document.getElementById('chipAdjustAmount');
      
      const seatIndex = parseInt(seatSelect.value);
      const newAmount = parseInt(amountInput.value);
      
      // Validation
      if (isNaN(seatIndex) || seatIndex === '') {
        alert('âŒ Please select a player!');
        return;
      }
      
      if (isNaN(newAmount) || newAmount < 0) {
        alert('âŒ Please enter a valid amount (minimum $0)!');
        return;
      }
      
      const playerName = seatSelect.options[seatSelect.selectedIndex].text;
      const confirmed = confirm(`ðŸ’° Adjust ${playerName}'s chips to $${newAmount.toLocaleString()}?`);
      
      if (!confirmed) return;
      
      debug('ðŸ’µ Adjusting chips:', { seatIndex, newAmount });
      
      try {
        const response = await fetch('/api/engine/host-controls/adjust-chips', {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            roomId,
            hostId: userId,
            seatIndex,
            newAmount
          })
        });
        
        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || 'Failed to adjust chips');
        }
        
        const result = await response.json();
        
        if (result.queued) {
          debug('â³ Chips queued for next hand');
          alert(`â³ ${playerName}'s chips will update to $${newAmount.toLocaleString()} at the end of this hand`);
        } else {
          debug('âœ… Chips adjusted');
          alert(`âœ… ${playerName}'s chips updated to $${newAmount.toLocaleString()}`);
        }
        
        // Refresh to show updated chips
        loadRoom();
        loadHostControls();
        
      } catch (error) {
        console.error('Error adjusting chips:', error);
        alert(`âŒ Failed: ${error.message}`);
      }
    }
    
    // ============================================
    // HOST CONTROL ENHANCEMENTS
    // ============================================
    
    let gamePaused = false;
    let actionTimerSeconds = 0;
    let roomLocked = false;
    
    // Toggle Room Lock
    async function toggleRoomLock() {
      roomLocked = !roomLocked;
      const btn = document.getElementById('lockBtnText');
      
      try {
        const response = await fetch('/api/engine/host-controls/room-lock', {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            roomId, 
            hostId: userId, 
            locked: roomLocked 
          })
        });
        
        if (!response.ok) throw new Error('Failed to toggle room lock');
        
        if (roomLocked) {
          btn.textContent = 'UNLOCK ROOM';
          alert('ðŸ”’ Room locked. No new players can join.');
        } else {
          btn.textContent = 'LOCK ROOM';
          alert('ðŸ”“ Room unlocked. Players can join again.');
        }
        
        debug('ðŸ”’ Room lock toggled:', roomLocked);
        
      } catch (error) {
        console.error('Error toggling room lock:', error);
        alert('âŒ Failed to toggle room lock.');
        roomLocked = !roomLocked; // Revert
      }
    }
    
    // Open Kick Player Modal (simplified - just shows list in existing UI)
    function openKickPlayerModal() {
      alert('ðŸ’¡ Use the KICK buttons next to each player in the Current Players section below');
      // Scroll to player list
      document.getElementById('hostPlayerList')?.scrollIntoView({ behavior: 'smooth' });
    }
    
    // Toggle Pause Game
    async function togglePauseGame() {
      const btn = document.getElementById('pauseGameBtn');
      gamePaused = !gamePaused;
      
      if (gamePaused) {
        btn.querySelector('.btn-text').textContent = 'RESUME GAME';
        btn.classList.add('paused');
        alert('â¸ï¸ Game paused. Players cannot take actions.');
      } else {
        btn.querySelector('.btn-text').textContent = 'PAUSE GAME';
        btn.classList.remove('paused');
        alert('â–¶ï¸ Game resumed. Players can continue.');
      }
      
      // TODO: Implement backend pause/resume logic
      // Will need to broadcast pause state to all players via socket
      debug('â¸ï¸ Game pause toggled:', gamePaused);
    }
    
    // Force Next Hand
    async function forceNextHand() {
      const confirmed = confirm('â­ï¸ Skip to next hand?\n\nThis will end the current hand immediately and move to the next one.\n\nContinue?');
      if (!confirmed) return;
      
      try {
        const response = await fetch('/api/engine/host-controls/force-next-hand', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ roomId, hostId: userId })
        });
        
        if (!response.ok) throw new Error('Failed to force next hand');
        
        alert('â­ï¸ Moving to next hand...');
        loadRoom();
        
      } catch (error) {
        console.error('Error forcing next hand:', error);
        alert('âŒ Failed to skip hand. Ensure game is in progress.');
      }
    }
    
    // Set Action Timer
    function setActionTimer(seconds) {
      actionTimerSeconds = seconds;
      
      // Update display
      const display = document.getElementById('actionTimerDisplay');
      display.textContent = seconds === 0 ? 'OFF' : `${seconds}s`;
      
      // Update button states
      document.querySelectorAll('.timer-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      event.target.classList.add('active');
      
      // Save to localStorage
      localStorage.setItem('pokergeek_action_timer', seconds);
      
      debug('â±ï¸ Action timer set to:', seconds === 0 ? 'OFF' : `${seconds}s`);
      
      // TODO: Implement backend timer logic
      // Will need to track time per player action and auto-fold on timeout
    }
    
    // Toggle Auto-Start
    function toggleAutoStart() {
      const checkbox = document.getElementById('autoStartToggle');
      const autoStart = checkbox.checked;
      
      localStorage.setItem('pokergeek_auto_start', autoStart);
      
      if (autoStart) {
        debug('ðŸ”„ Auto-start enabled');
      } else {
        debug('â¹ï¸ Auto-start disabled');
      }
    }
    
    // Toggle Spectator Mode
    function toggleSpectatorMode() {
      const checkbox = document.getElementById('spectatorToggle');
      const enabled = checkbox.checked;
      
      localStorage.setItem('pokergeek_spectator_mode', enabled);
      
      if (enabled) {
        debug('ðŸ‘ï¸ Spectator mode enabled');
      } else {
        debug('ðŸš« Spectator mode disabled');
      }
    }
    
    // Reset All Stacks
    async function resetAllStacks() {
      const confirmed = confirm('ðŸ”„ RESET ALL STACKS?\n\nThis will:\n- Set all players back to starting chips\n- Keep players seated\n- Not affect current hand\n\nContinue?');
      if (!confirmed) return;
      
      try {
        const response = await fetch('/api/engine/host-controls/reset-stacks', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ roomId, hostId: userId })
        });
        
        if (!response.ok) throw new Error('Failed to reset stacks');
        
        alert('ðŸ”„ All player stacks reset to starting amount!');
        loadRoom();
        loadHostControls();
        
      } catch (error) {
        console.error('Error resetting stacks:', error);
        alert('âŒ Failed to reset stacks.');
      }
    }
    
    // End Game
    async function endGame() {
      const confirmed = confirm('ðŸ›‘ END GAME?\n\nThis will:\n- End current game immediately\n- Clear all player seats\n- Return to lobby\n\nThis CANNOT be undone.\n\nContinue?');
      if (!confirmed) return;
      
      const doubleCheck = confirm('âš ï¸ Are you ABSOLUTELY sure?\n\nAll game progress will be lost.');
      if (!doubleCheck) return;
      
      try {
        const response = await fetch('/api/engine/host-controls/end-game', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ roomId, hostId: userId })
        });
        
        if (!response.ok) throw new Error('Failed to end game');
        
        alert('ðŸ›‘ Game ended. Returning to lobby...');
        window.location.href = '/';
        
      } catch (error) {
        console.error('Error ending game:', error);
        alert('âŒ Failed to end game.');
      }
    }
    
    // ============================================
    // TABLE COLOR (All Players)
    // ============================================
    function changeFeltColor(color) {
      document.body.setAttribute('data-felt', color);
      localStorage.setItem('pokergeek_felt_color', color);
      
      // Update active button
      document.querySelectorAll('.color-btn').forEach(btn => {
        btn.classList.remove('active');
        if (btn.dataset.color === color) {
          btn.classList.add('active');
        }
      });
      
      debug('ðŸŽ¨ Felt color changed:', color);
    }
    
    // 4-Color Deck Toggle
    function toggleFourColorDeck(enabled) {
      localStorage.setItem('pokergeek_four_color', enabled);
      debug('ðŸƒ 4-Color Deck:', enabled);
      // Implementation will be added when designs are ready
    }
    
    // Card Back Design
    function changeCardBack(design) {
      localStorage.setItem('pokergeek_card_back', design);
      debug('ðŸŽ´ Card back changed:', design);
      // Implementation will be added when designs are ready
    }
    
    // Animation Speed
    function changeAnimSpeed(speed) {
      const speeds = { fast: 200, normal: 400, slow: 600 };
      document.documentElement.style.setProperty('--anim-speed', speeds[speed] + 'ms');
      localStorage.setItem('pokergeek_anim_speed', speed);
      debug('âš¡ Animation speed:', speed);
    }
    
    // Auto-Muck Toggle
    function toggleAutoMuck(enabled) {
      localStorage.setItem('pokergeek_auto_muck', enabled);
      debug('ðŸ™ˆ Auto-muck:', enabled);
    }
    
    // Chip Display Format
    function changeChipFormat(format) {
      localStorage.setItem('pokergeek_chip_format', format);
      debug('ðŸ’° Chip format:', format);
      // Refresh chip displays on seats
      const gameState = currentGameState;
      if (gameState && gameState.players) {
        updateSeatChips(gameState.players);
      }
    }
    
    // Action Confirmation Toggle
    function toggleActionConfirm(enabled) {
      localStorage.setItem('pokergeek_action_confirm', enabled);
      debug('âš ï¸ Action confirmation:', enabled);
    }
    
    // Hotkeys Toggle
    let hotkeysEnabled = false;
    function toggleHotkeys(enabled) {
      hotkeysEnabled = enabled;
      localStorage.setItem('pokergeek_hotkeys', enabled);
      debug('âŒ¨ï¸ Hotkeys:', enabled);
      
      if (enabled) {
        document.addEventListener('keydown', handleHotkey);
      } else {
        document.removeEventListener('keydown', handleHotkey);
      }
    }
    
    // Hotkey Handler
    function handleHotkey(e) {
      if (!hotkeysEnabled) return;
      
      // Don't trigger if typing in input
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
      
      const key = e.key.toLowerCase();
      const foldBtn = document.getElementById('foldBtn');
      const callBtn = document.getElementById('callBtn');
      const raiseBtn = document.getElementById('raiseBtn');
      
      if (key === 'f' && foldBtn && !foldBtn.disabled) {
        e.preventDefault();
        foldBtn.click();
      } else if (key === 'c' && callBtn && !callBtn.disabled) {
        e.preventDefault();
        callBtn.click();
      } else if (key === 'r' && raiseBtn && !raiseBtn.disabled) {
        e.preventDefault();
        raiseBtn.click();
      }
    }
    
    // Load all saved settings on page load
    (function loadSavedFeltColor() {
      const savedColor = localStorage.getItem('pokergeek_felt_color') || 'green';
      document.body.setAttribute('data-felt', savedColor);
      
      // Set active button (wait for DOM to be ready)
      setTimeout(() => {
        const activeBtn = document.querySelector(`.color-btn[data-color="${savedColor}"]`);
        if (activeBtn) activeBtn.classList.add('active');
      }, 100);
      
      debug('ðŸŽ¨ Loaded saved felt color:', savedColor);
    })();
    
    // ============================================
    // CIRCULAR SEAT POSITIONING (Proper Ellipse)
    // ============================================
    function calculateSeatPositions() {
      // ðŸ”’ LOCKED POSITIONS - Final layout optimized for 1600Ã—1200 table
      // Uniform 200Ã—200px seats, perfectly balanced ellipse
      return [
        { index: 0, x: 805, y: 160, width: 200, height: 200 },   // Bottom center (YOU)
        { index: 1, x: 1115, y: 230, width: 200, height: 200 },  // Bottom right
        { index: 2, x: 1355, y: 410, width: 200, height: 200 },  // Right mid-upper
        { index: 3, x: 1355, y: 730, width: 200, height: 200 },  // Right mid-lower
        { index: 4, x: 1115, y: 970, width: 200, height: 200 },  // Bottom right lower
        { index: 5, x: 805, y: 1040, width: 200, height: 200 },  // Bottom center-lower
        { index: 6, x: 495, y: 970, width: 200, height: 200 },   // Bottom left lower
        { index: 7, x: 255, y: 730, width: 200, height: 200 },   // Left mid-lower
        { index: 8, x: 255, y: 410, width: 200, height: 200 },   // Left mid-upper
        { index: 9, x: 495, y: 230, width: 200, height: 200 }    // Bottom left
      ];
    }
    
    const SEAT_POSITIONS = calculateSeatPositions();

    function applySeatPositions() {
      SEAT_POSITIONS.forEach(pos => {
        const seat = document.querySelector(`.seat[data-seat-index="${pos.index}"]`);
        if (seat) {
          seat.style.left = `${pos.x}px`;
          seat.style.top = `${pos.y}px`;
          if (pos.width) seat.style.width = `${pos.width}px`;
          if (pos.height) seat.style.height = `${pos.height}px`;
        }
      });
      debug('ðŸ“ Applied custom seat positions with sizes');
    }
    
    // ============================================
    // ZOOM LOCK SYSTEM
    // ============================================
    function setupZoomLock() {
      const wrapper = document.getElementById('tableWrapper');
      const table = document.getElementById('pokerTable');
      
      if (!wrapper || !table) {
        console.warn('âš ï¸ Zoom lock elements not found');
        return;
      }

      const updateScale = () => {
        const containerWidth = wrapper.clientWidth;
        const containerHeight = wrapper.clientHeight;
        const stageWidth = 1600;
        const stageHeight = 1200;

        const scaleX = containerWidth / stageWidth;
        const scaleY = containerHeight / stageHeight;
        const scale = Math.min(scaleX, scaleY);

        const scaledWidth = stageWidth * scale;
        const scaledHeight = stageHeight * scale;
        const offsetX = (containerWidth - scaledWidth) / 2;
        const offsetY = (containerHeight - scaledHeight) / 2;

        table.style.left = `${offsetX}px`;
        table.style.top = `${offsetY}px`;
        table.style.transform = `scale(${scale})`;
        
        debug('ðŸ” Zoom lock updated', { scale, offsetX, offsetY });
      };

      updateScale();
      window.addEventListener('resize', updateScale);
      new ResizeObserver(updateScale).observe(wrapper);
      
      debug('âœ… Zoom lock initialized');
    }
    
    // ============================================
    // INITIALIZE ON LOAD
    // ============================================
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        init();
        setupZoomLock();
      });
    } else {
      init();
      setupZoomLock();
    }
  </script>
  
  <!-- Liquid Glass SVG Filter - Required for glass distortion effect -->
  <svg xmlns="http://www.w3.org/2000/svg" width="0" height="0" style="position:absolute; overflow:hidden">
    <defs>
      <filter id="glass-distortion" x="0%" y="0%" width="100%" height="100%">
        <feTurbulence type="fractalNoise" baseFrequency="0.008 0.008" numOctaves="2" seed="92" result="noise" />
        <feGaussianBlur in="noise" stdDeviation="2" result="blurred" />
        <feDisplacementMap in="SourceGraphic" in2="blurred" scale="39" xChannelSelector="R" yChannelSelector="G" />
      </filter>
    </defs>
  </svg>
</body>
</html>

