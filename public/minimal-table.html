<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PokerGeek - Minimal Table</title>
  
  <!-- Global Navbar Styles -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;800&family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/css/pokergeek.css">
  
  <!-- Supabase SDK -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  
  <style>
    /* Design Tokens */
    :root {
      --bg: #0b0b12;
      --text: #e9eef7;
      --muted: #9aa3b2;
      --accent: #ff5100;
      --teal: #00d4aa;
      --error: #ff3b3b;
      --felt-current: #197a45;
      --font-main: "Inter", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      --font-mono: "JetBrains Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --shadow-md: 0 8px 18px rgba(0,0,0,.35);
      --shadow-lg: 0 12px 28px rgba(0,0,0,.45);
      --shadow-xl: 0 18px 44px rgba(0,0,0,.55);
    }

    /* Felt color presets */
    body[data-felt="green"] { --felt-current: #197a45; }
    body[data-felt="red"] { --felt-current: #6b1414; }
    body[data-felt="black"] { --felt-current: #1a1a1a; }
    body[data-felt="blue"] { --felt-current: #0f2942; }
    body[data-felt="grey"] { --felt-current: #2a2a2a; }
    body[data-felt="tan"] { --felt-current: #6b5642; }
    body[data-felt="purple"] { --felt-current: #3a1450; }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      background: #0b0b12;
      color: #e9eef7;
      font-family: 'Inter', system-ui, -apple-system, Arial, sans-serif;
      padding: 20px;
      padding-top: 100px; /* Space for fixed navbar */
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
    }
    
    /* ============================================ */
    /* ZOOM LOCK TABLE WRAPPER */
    /* ============================================ */
    .table-wrapper {
      width: 100%;
      min-height: 1000px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--bg);
      position: relative;
      overflow: visible;
      margin-bottom: 30px;
    }

    .poker-table {
      position: absolute;
      width: 1600px;
      height: 1200px;
      transform-origin: top left;
      pointer-events: auto;
      z-index: 1;
    }

    /* Oval Felt Background */
    .table-felt {
      position: absolute;
      inset: 24px;
      border-radius: 360px;
      border: 2px solid #0d1117;
      background: var(--felt-current);
      box-shadow: 
        inset 0 0 0 16px rgba(0,0,0,.35), 
        inset 0 0 80px rgba(0,0,0,.45);
      z-index: 0;
    }

    .table-felt::after {
      content: "";
      position: absolute;
      inset: -24px;
      border-radius: inherit;
      box-shadow: 0 16px 56px rgba(0,0,0,.55);
      pointer-events: none;
    }

    /* Board Center (Community Cards + Pot) */
    .board-center {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 16px;
      z-index: 5;
      pointer-events: none;
    }

    .community-cards-center {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      justify-content: center;
    }
    
    /* Community card styling */
    .community-cards-center .card-img {
      width: 110px;
      aspect-ratio: 5/7;
      border-radius: 10px;
      box-shadow: 
        0 0 30px rgba(255, 255, 255, 0.15),
        0 12px 40px rgba(0, 0, 0, 0.8);
      object-fit: cover;
      border: 2px solid rgba(255,255,255,0.3);
      transition: all 0.3s ease;
    }
    
    .community-cards-center .card-img:hover {
      transform: translateY(-4px);
      box-shadow: 
        0 0 40px rgba(255, 255, 255, 0.25),
        0 16px 50px rgba(0, 0, 0, 0.9);
    }
    
    /* Card entrance animation */
    @keyframes cardFlip {
      0% {
        transform: rotateY(90deg) scale(0.8);
        opacity: 0;
      }
      50% {
        transform: rotateY(45deg) scale(1.05);
      }
      100% {
        transform: rotateY(0deg) scale(1);
        opacity: 1;
      }
    }
    
    .community-cards-center .card-img.new-card {
      animation: cardFlip 0.5s ease-out forwards;
    }

    .pot-display-center {
      padding: 28px 56px;
      border-radius: 24px;
      background: linear-gradient(135deg, rgba(0,0,0,.98) 0%, rgba(20,20,30,.98) 100%);
      border: 3px solid rgba(255,215,0,.6);
      text-align: center;
      box-shadow: 
        inset 0 0 40px -10px rgba(255, 215, 0, 0.3),
        0 0 0 1px rgba(255,215,0,.3),
        0 0 60px rgba(255,215,0,.4),
        var(--shadow-xl);
      pointer-events: auto;
      backdrop-filter: blur(10px);
    }

    .pot-label {
      font-size: 14px;
      color: var(--muted);
      letter-spacing: .2em;
      font-weight: 800;
      margin-bottom: 8px;
      text-transform: uppercase;
      text-shadow: 0 2px 4px rgba(0,0,0,0.6);
    }

    .pot-amount {
      font-family: var(--font-mono);
      font-size: 52px;
      color: #ffd700;
      font-weight: 900;
      text-shadow: 
        0 0 20px rgba(255, 215, 0, 0.8),
        0 4px 12px rgba(0, 0, 0, 0.8);
      letter-spacing: 0.05em;
    }

    /* Seats Layer */
    .seats-layer {
      position: absolute;
      inset: 0;
      z-index: 10;
    }
    
    h1 {
      color: #ff5100;
      margin-bottom: 10px;
    }
    
    /* Clean Table Header */
    .table-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 24px;
      background: rgba(255,255,255,0.03);
      border-radius: 12px;
      margin-bottom: 20px;
      border: 1px solid rgba(255,255,255,0.08);
    }
    
    .room-code-display {
      display: flex;
      align-items: baseline;
      gap: 12px;
    }
    
    .room-code-label {
      color: rgba(255,255,255,0.5);
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 1px;
      font-weight: 600;
    }
    
    .room-code {
      color: #00d4aa;
      font-size: 1.8rem;
      font-weight: 700;
      letter-spacing: 2px;
      font-family: 'Courier New', monospace;
    }
    
    .connection-indicator {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .connection-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #ff3b3b;
      box-shadow: 0 0 12px rgba(255, 59, 59, 0.6);
      transition: all 0.3s ease;
    }
    
    .connection-indicator.connected .connection-dot {
      background: #00d4aa;
      box-shadow: 0 0 12px rgba(0, 212, 170, 0.6);
    }
    
    .seats-grid {
      position: relative;
      width: 100%;
      height: 100%;
    }
    
    .seat {
      position: absolute;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, rgba(20,20,40,0.95) 0%, rgba(30,30,50,0.95) 100%);
      border: 2px solid rgba(255,255,255,0.2);
      border-radius: 16px;
      padding: 16px 14px;
      width: 220px;
      aspect-ratio: 1 / 1;
      backdrop-filter: blur(20px) saturate(120%);
      box-shadow: 
        inset 0 0 20px -5px rgba(255, 255, 255, 0.1),
        0 10px 30px rgba(0, 0, 0, 0.6);
      display: flex;
      flex-direction: column;
      justify-content: space-evenly;
      align-items: center;
      gap: 4px;
    }
    
    /* YOUR seat - same aspect ratio, just bigger */
    .seat.me {
      width: 260px;
      aspect-ratio: 1 / 1;
      padding: 18px 16px;
      border: 3px solid var(--teal);
      background: linear-gradient(135deg, rgba(0, 212, 170, 0.15) 0%, rgba(0, 180, 140, 0.15) 100%);
      box-shadow: 
        inset 0 0 30px -6px rgba(0, 212, 170, 0.3), 
        0 0 0 3px rgba(0,212,170,.5),
        0 0 50px rgba(0,212,170,.6),
        0 12px 40px rgba(0, 0, 0, 0.8);
      gap: 8px;
    }
    
    .seat.empty {
      border: 2px dashed rgba(0, 212, 170, 0.5);
      background: linear-gradient(135deg, rgba(0, 212, 170, 0.03) 0%, rgba(0, 180, 140, 0.03) 100%);
      cursor: pointer;
      transition: background 0.3s ease, border 0.3s ease, box-shadow 0.3s ease;
    }
    
    .seat.empty:hover {
      background: linear-gradient(135deg, rgba(0, 212, 170, 0.15) 0%, rgba(0, 180, 140, 0.15) 100%);
      border: 2px solid var(--teal);
      box-shadow: 
        inset 0 0 30px -6px rgba(0, 212, 170, 0.25),
        0 0 0 2px rgba(0,212,170,.4),
        0 0 40px rgba(0, 212, 170, 0.5),
        0 12px 35px rgba(0, 0, 0, 0.7);
      transform: translate(-50%, -50%) scale(1.02);
    }
    
    .seat.taken {
      border: 2px solid rgba(255,215,0,0.6);
      background: linear-gradient(135deg, rgba(255,215,0,0.08) 0%, rgba(255,195,0,0.08) 100%);
      box-shadow: 
        inset 0 0 20px -5px rgba(255, 215, 0, 0.15),
        0 10px 30px rgba(0, 0, 0, 0.6);
    }
    
    .seat.winner {
      border-color: gold;
      background: rgba(255,215,0,0.2);
      box-shadow: 0 0 20px rgba(255,215,0,0.5);
      animation: winnerPulse 1.5s ease-in-out infinite;
    }
    
    @keyframes winnerPulse {
      0%, 100% {
        box-shadow: 0 0 20px rgba(255,215,0,0.5);
      }
      50% {
        box-shadow: 0 0 30px rgba(255,215,0,0.8);
      }
    }
    
    /* Current turn indicator - glowing border */
    @keyframes seatTurnGlow {
      0%, 100% {
        box-shadow: 0 0 0 3px #ffd700, 0 0 30px rgba(255, 215, 0, 0.6);
      }
      50% {
        box-shadow: 0 0 0 5px #ffd700, 0 0 50px rgba(255, 215, 0, 1);
      }
    }
    
    .seat.current-turn {
      border: 3px solid #ffd700;
      animation: seatTurnGlow 1.5s ease-in-out infinite;
    }
    
    .seat-label {
      font-size: clamp(0.7rem, 1.8vw, 0.9rem);
      color: #9aa3b2;
      margin-bottom: 0.5em;
      letter-spacing: 0.3px;
      width: 100%;
      text-align: center;
    }
    
    .seat-player {
      font-size: clamp(1.1rem, 2.5vw, 1.5rem);
      font-weight: 800;
      margin-bottom: 0.4em;
      color: var(--teal);
      text-shadow: 0 2px 10px rgba(0, 212, 170, 0.6);
      letter-spacing: 0.5px;
      width: 100%;
      text-align: center;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      flex-shrink: 0;
    }
    
    .seat-chips {
      color: #ffd700;
      font-weight: 600;
      font-size: clamp(0.85rem, 1.8vw, 1.1rem);
      text-shadow: 0 2px 6px rgba(255, 215, 0, 0.5);
      letter-spacing: 0.5px;
      width: 100%;
      text-align: center;
      flex-shrink: 0;
    }
    
    /* üÉè SEAT CARD BACKINGS */
    .seat-cards {
      display: flex;
      gap: 8px;
      margin-top: 8px;
      justify-content: center;
      min-height: 70px;
      flex-shrink: 1;
    }
    
    .seat-card-back, .seat-card-front {
      width: 60px;
      height: 84px;
      border-radius: 6px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.6);
      transition: transform 0.3s ease, opacity 0.3s ease, filter 0.3s ease;
      object-fit: cover;
    }
    
    .seat-card-back:hover, .seat-card-front:hover {
      transform: translateY(-4px);
    }
    
    .seat-card-back.folded, .seat-card-front.folded {
      opacity: 0.3;
      filter: grayscale(100%);
    }
    
    .seat-card-back.hidden {
      display: none;
    }
    
    /* üé∞ DEALER & BLIND BADGES */
    .position-badges {
      display: flex;
      gap: 4px;
      margin-top: 4px;
      justify-content: center;
    }
    
    .position-badge {
      font-size: 0.7rem;
      padding: 2px 6px;
      border-radius: 4px;
      font-weight: 600;
      border: 1px solid;
    }
    
    .position-badge.dealer {
      background: linear-gradient(135deg, #ffaa00, #ff8800);
      color: #0b0b12;
      border-color: #ffcc44;
    }
    
    .position-badge.sb {
      background: linear-gradient(135deg, #00aaff, #0088ff);
      color: white;
      border-color: #44ccff;
    }
    
    .position-badge.bb {
      background: linear-gradient(135deg, #ff3b3b, #ff0000);
      color: white;
      border-color: #ff6666;
    }
    
    /* üèÜ WINNER BANNER */
    .winner-banner {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, rgba(255,215,0,0.95), rgba(255,165,0,0.95));
      border: 3px solid gold;
      border-radius: 16px;
      padding: 30px 50px;
      font-size: 2rem;
      font-weight: 700;
      color: #0b0b12;
      box-shadow: 0 10px 40px rgba(255,215,0,0.6);
      z-index: 1000;
      animation: winnerBannerPop 0.5s ease-out;
      display: none;
    }
    
    @keyframes winnerBannerPop {
      0% {
        transform: translate(-50%, -50%) scale(0.5);
        opacity: 0;
      }
      100% {
        transform: translate(-50%, -50%) scale(1);
        opacity: 1;
      }
    }
    
    .winner-banner.show {
      display: block;
    }
    
    /* üÉè SHOW/MUCK CONTROLS */
    .showdown-controls {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, rgba(15,15,25,0.95), rgba(20,20,30,0.95));
      border: 2px solid #ff5100;
      border-radius: 12px;
      padding: 20px;
      display: none;
      z-index: 999;
      box-shadow: 0 8px 24px rgba(0,0,0,0.5);
    }
    
    .showdown-controls.show {
      display: block;
    }
    
    .showdown-controls h3 {
      margin: 0 0 12px 0;
      color: #ff5100;
      font-size: 1rem;
      text-align: center;
    }
    
    .showdown-controls .button-group {
      display: flex;
      gap: 12px;
    }
    
    .showdown-controls button {
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 0.9rem;
    }
    
    .showdown-controls button.show-btn {
      background: linear-gradient(135deg, #00dd88, #00aa66);
      color: white;
    }
    
    .showdown-controls button.show-btn:hover {
      background: linear-gradient(135deg, #00ff99, #00cc77);
      transform: scale(1.05);
    }
    
    .showdown-controls button.muck-btn {
      background: linear-gradient(135deg, #666, #444);
      color: white;
    }
    
    .showdown-controls button.muck-btn:hover {
      background: linear-gradient(135deg, #777, #555);
      transform: scale(1.05);
    }
    
    /* üéõÔ∏è HOST CONTROLS PANEL */
    .host-controls-panel {
      background: linear-gradient(135deg, rgba(255,81,0,0.1), rgba(255,81,0,0.05));
      border: 2px solid #ff5100;
      border-radius: 12px;
      padding: 0;
      margin-bottom: 20px;
      display: none; /* Hidden by default, shown for host only */
      overflow: hidden;
    }
    
    .host-controls-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px 20px;
      background: rgba(255,81,0,0.15);
      cursor: pointer;
      user-select: none;
      transition: background 0.2s;
    }
    
    .host-controls-header:hover {
      background: rgba(255,81,0,0.2);
    }
    
    .host-controls-header h3 {
      color: #ff5100;
      font-size: 1.1rem;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .host-badge {
      background: #ff5100;
      color: white;
      padding: 4px 10px;
      border-radius: 6px;
      font-size: 0.75rem;
      font-weight: 700;
    }
    
    .host-controls-content {
      max-height: 0;
      opacity: 0;
      transition: all 0.3s ease;
      pointer-events: none;
    }
    
    .host-controls-content.expanded {
      max-height: 600px;
      opacity: 1;
      pointer-events: auto;
      padding: 20px;
    }
    
    .host-section {
      background: rgba(255,255,255,0.05);
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 15px;
    }
    
    .host-section:last-child {
      margin-bottom: 0;
    }
    
    .host-section h4 {
      color: #00d4aa;
      font-size: 0.95rem;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .player-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .player-item {
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      padding: 12px 15px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border: 1px solid rgba(255,255,255,0.1);
    }
    
    .player-item-info {
      flex: 1;
    }
    
    .player-item-name {
      color: #e9eef7;
      font-weight: 600;
      font-size: 1rem;
      margin-bottom: 4px;
    }
    
    .player-item-details {
      color: #999;
      font-size: 0.85rem;
      display: flex;
      gap: 15px;
    }
    
    .player-item-chips {
      color: gold;
    }
    
    .host-btn {
      padding: 8px 16px;
      border-radius: 6px;
      border: none;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      white-space: nowrap;
    }
    
    .host-btn.kick {
      background: #ff3b3b;
      color: white;
    }
    
    .host-btn.kick:hover {
      background: #ff5555;
      transform: scale(1.05);
    }
    
    .blinds-controls {
      display: flex;
      gap: 15px;
      align-items: center;
      flex-wrap: wrap;
    }
    
    .blind-input-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .blind-input-group label {
      color: #9aa3b2;
      font-weight: 600;
      font-size: 0.9rem;
    }
    
    .blind-input-group input {
      width: 90px;
      padding: 10px;
      border-radius: 6px;
      border: 2px solid #333;
      background: rgba(0,0,0,0.4);
      color: #e9eef7;
      font-size: 1rem;
      font-weight: 600;
    }
    
    .blind-input-group input:focus {
      outline: none;
      border-color: #00d4aa;
    }
    
    .host-btn.update {
      background: #00d4aa;
      color: #0b0b12;
      padding: 10px 20px;
      font-size: 0.95rem;
    }
    
    .host-btn.update:hover {
      background: #00ffcc;
      transform: translateY(-2px);
    }
    
    .empty-state {
      color: #666;
      font-style: italic;
      text-align: center;
      padding: 15px;
    }
    
    .toggle-icon {
      color: #ff5100;
      font-size: 1.2rem;
      transition: transform 0.3s;
    }
    
    .toggle-icon.expanded {
      transform: rotate(180deg);
    }
    
    /* Section hints */
    .section-hint {
      font-size: 0.85rem;
      color: rgba(255,255,255,0.6);
      margin: -8px 0 12px 0;
      font-style: italic;
    }
    
    /* Form elements */
    .form-select, .form-input {
      width: 100%;
      padding: 10px;
      border-radius: 8px;
      background: rgba(255,255,255,0.08);
      color: white;
      border: 1px solid rgba(255,255,255,0.2);
      font-family: "Courier New", monospace;
      font-size: 0.95rem;
      transition: all 0.3s ease;
    }
    
    .form-select:focus, .form-input:focus {
      outline: none;
      border-color: var(--teal);
      background: rgba(255,255,255,0.12);
      box-shadow: 0 0 0 2px rgba(0, 212, 170, 0.2);
    }
    
    .chip-adjustment-controls {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    
    /* Player Settings Panel (Non-Hosts) */
    #playerSettingsPanel {
      background: rgba(255,255,255,0.05);
      border: 2px solid rgba(255,255,255,0.1);
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 24px;
      max-width: 1200px;
      margin-left: auto;
      margin-right: auto;
    }
    
    #playerSettingsPanel .panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: pointer;
      user-select: none;
      padding-bottom: 16px;
      border-bottom: 2px solid rgba(255,255,255,0.1);
      margin-bottom: 20px;
    }
    
    #playerSettingsPanel .panel-header h2 {
      color: var(--teal);
      font-size: 1.3rem;
      font-weight: 700;
      margin: 0;
    }
    
    #playerSettingsPanel .collapse-btn {
      background: transparent;
      border: none;
      cursor: pointer;
      padding: 8px;
    }
    
    #playerSettingsPanel .panel-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease;
    }
    
    #playerSettingsPanel .panel-content.expanded {
      max-height: 1000px;
    }
    
    .color-picker-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
      gap: 12px;
      margin-top: 16px;
    }
    
    .color-btn {
      background: rgba(255,255,255,0.05);
      border: 2px solid rgba(255,255,255,0.2);
      border-radius: 12px;
      padding: 12px;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }
    
    .color-btn:hover {
      background: rgba(255,255,255,0.1);
      border-color: var(--teal);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 212, 170, 0.3);
    }
    
    .color-btn.active {
      border-color: var(--accent);
      background: rgba(255, 81, 0, 0.1);
      box-shadow: 0 0 20px rgba(255, 81, 0, 0.4);
    }
    
    /* Toggle Switch */
    .toggle-switch {
      display: flex;
      align-items: center;
      gap: 12px;
      cursor: pointer;
    }
    
    .toggle-switch input[type="checkbox"] {
      position: absolute;
      opacity: 0;
      width: 0;
      height: 0;
    }
    
    .toggle-slider {
      position: relative;
      display: inline-block;
      width: 50px;
      height: 26px;
      background: rgba(255,255,255,0.1);
      border-radius: 13px;
      transition: all 0.3s;
      border: 2px solid rgba(255,255,255,0.2);
    }
    
    .toggle-slider::after {
      content: '';
      position: absolute;
      width: 18px;
      height: 18px;
      left: 2px;
      top: 2px;
      background: #e9eef7;
      border-radius: 50%;
      transition: all 0.3s;
    }
    
    .toggle-switch input:checked + .toggle-slider {
      background: #00d4aa;
      border-color: #00d4aa;
    }
    
    .toggle-switch input:checked + .toggle-slider::after {
      transform: translateX(24px);
    }
    
    .toggle-label {
      color: #e9eef7;
      font-size: 0.9rem;
    }
    
    /* Settings Select */
    .settings-select {
      width: 100%;
      padding: 10px 14px;
      background: rgba(255,255,255,0.05);
      border: 2px solid rgba(255,255,255,0.2);
      border-radius: 8px;
      color: #e9eef7;
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.3s;
    }
    
    .settings-select:hover {
      border-color: #00d4aa;
      background: rgba(255,255,255,0.08);
    }
    
    .settings-select:focus {
      outline: none;
      border-color: #00d4aa;
      box-shadow: 0 0 0 3px rgba(0, 212, 170, 0.2);
    }
    
    /* Setting Note */
    .setting-note {
      margin-top: 8px;
      font-size: 0.8rem;
      color: #9aa3b2;
      font-style: italic;
    }
    
    /* ============================================ */
    /* HOST CONTROLS PANEL - MATCHES PLAYER SETTINGS */
    /* ============================================ */
    
    #hostControlsPanel {
      max-width: 900px;
      margin: 20px auto;
      background: rgba(20, 20, 40, 0.8);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 16px;
      padding: 24px;
      backdrop-filter: blur(10px);
    }
    
    #hostControlsPanel .panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: pointer;
      user-select: none;
      padding-bottom: 16px;
      border-bottom: 2px solid rgba(255,255,255,0.1);
      margin-bottom: 20px;
    }
    
    #hostControlsPanel .panel-header h2 {
      color: var(--accent);
      font-size: 1.3rem;
      font-weight: 700;
      margin: 0;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    .host-badge {
      font-size: 0.7rem;
      background: rgba(255, 81, 0, 0.2);
      color: var(--accent);
      padding: 4px 10px;
      border-radius: 20px;
      border: 1px solid var(--accent);
      font-weight: 600;
      letter-spacing: 0.5px;
    }
    
    #hostControlsPanel .collapse-btn {
      background: transparent;
      border: none;
      cursor: pointer;
      padding: 8px;
    }
    
    #hostControlsPanel .panel-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease;
    }
    
    #hostControlsPanel .panel-content.expanded {
      max-height: 2000px;
    }
    
    .host-actions-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 12px;
      margin-top: 16px;
    }
    
    .host-control-btn {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      padding: 16px 12px;
      border-radius: 10px;
      font-family: "Courier New", monospace;
      font-weight: 600;
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.3s ease;
      border: 2px solid;
      background: rgba(255,255,255,0.03);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .host-control-btn .btn-icon {
      font-size: 1.5rem;
    }
    
    .host-control-btn .btn-text {
      font-size: 0.8rem;
      line-height: 1.2;
      text-align: center;
    }
    
    .host-control-btn.action {
      color: #00d4aa;
      border-color: #00d4aa;
    }
    
    .host-control-btn.action:hover {
      background: rgba(0, 212, 170, 0.2);
      border-color: #00ffcc;
      transform: translateY(-3px);
      box-shadow: 0 6px 20px rgba(0, 212, 170, 0.4);
    }
    
    .host-control-btn.update {
      color: #00d4aa;
      border-color: #00d4aa;
      width: 100%;
      margin-top: 12px;
    }
    
    .host-control-btn.update:hover {
      background: rgba(0, 212, 170, 0.2);
      border-color: #00ffcc;
      transform: translateY(-2px);
    }
    
    .host-control-btn.danger {
      color: #ff5151;
      border-color: #ff5151;
    }
    
    .host-control-btn.danger:hover {
      background: rgba(255, 81, 81, 0.2);
      border-color: #ff6666;
      transform: translateY(-3px);
      box-shadow: 0 6px 20px rgba(255, 81, 81, 0.4);
    }
    
    .host-control-btn.paused {
      background: rgba(249, 115, 22, 0.2);
      color: #f97316;
      border-color: #f97316;
    }
    
    .setting-group {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-bottom: 20px;
    }
    
    .setting-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 14px 16px;
      background: rgba(255,255,255,0.03);
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.1);
      margin-bottom: 12px;
    }
    
    .setting-label {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    
    .setting-label span {
      color: #e9eef7;
      font-size: 0.95rem;
      font-weight: 500;
    }
    
    .setting-label small {
      color: #9aa3b2;
      font-size: 0.8rem;
    }
    
    .timer-buttons {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 8px;
    }
    
    .timer-btn {
      flex: 1;
      min-width: 60px;
      padding: 10px 15px;
      background: rgba(255,255,255,0.05);
      color: #e9eef7;
      border: 2px solid rgba(255,255,255,0.2);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-family: "Courier New", monospace;
      font-size: 0.9rem;
      font-weight: 600;
    }
    
    .timer-btn:hover {
      background: rgba(0, 212, 170, 0.15);
      border-color: #00d4aa;
      color: #00d4aa;
      transform: translateY(-2px);
    }
    
    .timer-btn.active {
      background: #00d4aa;
      color: #0b0b12;
      border-color: #00d4aa;
      font-weight: 700;
      box-shadow: 0 0 15px rgba(0, 212, 170, 0.5);
    }
    
    .timer-status {
      text-align: center;
      padding: 12px;
      background: rgba(255,255,255,0.03);
      border-radius: 8px;
      font-family: "Courier New", monospace;
      color: #9aa3b2;
      margin-top: 8px;
      font-size: 0.9rem;
    }
    
    .timer-status span {
      color: #00d4aa;
      font-weight: 700;
      font-size: 1rem;
    }
    
    .blinds-controls {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-top: 16px;
    }
    
    .blind-input-group {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    
    .blind-input-group label {
      color: #e9eef7;
      font-size: 0.9rem;
      font-weight: 500;
      min-width: 100px;
    }
    
    .blind-input-group input,
    .blind-input-group select {
      flex: 1;
      padding: 10px 14px;
      background: rgba(255,255,255,0.05);
      border: 2px solid rgba(255,255,255,0.2);
      border-radius: 8px;
      color: #e9eef7;
      font-size: 0.9rem;
      font-family: "Courier New", monospace;
      font-weight: 600;
      transition: all 0.3s;
    }
    
    .blind-input-group input:focus,
    .blind-input-group select:focus {
      outline: none;
      border-color: #00d4aa;
      box-shadow: 0 0 0 3px rgba(0, 212, 170, 0.2);
      background: rgba(255,255,255,0.08);
    }
    
    .form-input {
      padding: 10px 14px;
      background: rgba(255,255,255,0.05);
      border: 2px solid rgba(255,255,255,0.2);
      border-radius: 8px;
      color: #e9eef7;
      font-size: 0.9rem;
      font-family: "Courier New", monospace;
      font-weight: 600;
      transition: all 0.3s;
    }
    
    .form-input:focus {
      outline: none;
      border-color: #00d4aa;
      box-shadow: 0 0 0 3px rgba(0, 212, 170, 0.2);
      background: rgba(255,255,255,0.08);
    }
    
    .danger-zone {
      border: 2px solid rgba(255, 81, 81, 0.3);
      border-radius: 12px;
      padding: 20px;
      background: rgba(255, 81, 81, 0.05);
      margin-top: 24px;
    }
    
    .danger-zone h4 {
      color: #ff5151;
      margin-bottom: 8px;
    }
    
    .danger-zone .section-hint {
      color: #ff8888;
    }
    
    /* Hotkey List */
    .hotkey-list div {
      padding: 6px 0;
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }
    
    .hotkey-list div:last-child {
      border-bottom: none;
    }
    
    kbd {
      display: inline-block;
      padding: 3px 8px;
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 4px;
      font-family: "Courier New", monospace;
      font-size: 0.85rem;
      color: #00d4aa;
      margin-right: 8px;
    }
    
    .color-preview {
      width: 60px;
      height: 60px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.4), inset 0 2px 8px rgba(255,255,255,0.1);
      transition: all 0.3s ease;
    }
    
    .color-btn:hover .color-preview {
      transform: scale(1.1);
    }
    
    .color-btn span {
      color: white;
      font-size: 0.85rem;
      font-weight: 600;
      font-family: "Courier New", monospace;
    }
    
    .controls {
      background: rgba(255,255,255,0.05);
      padding: 20px;
      border-radius: 12px;
      margin-bottom: 30px;
    }
    
    /* Subtle blink animation for active buttons */
    @keyframes subtlePulse {
      0%, 100% {
        opacity: 1;
        box-shadow: 0 0 0 rgba(255, 255, 255, 0);
      }
      50% {
        opacity: 0.85;
        box-shadow: 0 0 20px rgba(255, 255, 255, 0.15);
      }
    }
    
    .btn {
      padding: 18px 40px;
      background: #0b0b12;
      color: #e9eef7;
      border: 3px solid;
      border-radius: 8px;
      font-family: "Courier New", monospace;
      font-weight: 600;
      font-size: 20px;
      cursor: pointer;
      transition: all 0.2s ease;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    /* YOUR TURN - Pulse animation */
    .btn.active {
      animation: subtlePulse 2s ease-in-out infinite;
    }
    
    /* NOT YOUR TURN - Blurred */
    .btn.not-your-turn {
      filter: blur(2px);
      opacity: 0.3;
      pointer-events: none;
      cursor: not-allowed;
    }
    
    .btn:hover:not(:disabled):not(.not-your-turn) {
      transform: translateY(-1px);
      animation: none;
    }
    
    .btn:active:not(:disabled):not(.not-your-turn) {
      transform: translateY(0);
    }
    
    /* Force white text on start button */
    #startBtn, #refreshBtn {
      color: #ffffff !important;
    }
    
    /* ============================================ */
    /* RAISE PANEL (Below Buttons - No Box) */
    /* ============================================ */
    .raise-panel {
      margin: 30px auto 0;
      max-width: 800px;
      padding: 20px 0;
      animation: panelSlideDown 0.3s ease-out;
    }
    
    @keyframes panelSlideDown {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    .raise-slider-section {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-bottom: 24px;
    }
    
    .raise-info {
      display: flex;
      justify-content: center;
      gap: 40px;
      margin-bottom: 20px;
      margin-top: 20px;
    }
    
    .raise-info-item {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    
    .raise-info-label {
      font-size: 13px;
      color: #9aa3b2;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .raise-info-value {
      font-size: 20px;
      font-weight: 700;
      color: #00d4aa;
      font-family: "Courier New", monospace;
    }
    
    .raise-presets {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 12px;
      margin-bottom: 20px;
    }
    
    .raise-preset-btn {
      padding: 12px;
      background: #0b0b12;
      color: #e9eef7;
      border: 2px solid #00d4aa;
      border-radius: 6px;
      font-family: "Courier New", monospace;
      font-weight: 600;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s ease;
      text-transform: uppercase;
    }
    
    .raise-preset-btn:hover {
      background: #00d4aa;
      color: #0b0b12;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 212, 170, 0.4);
    }
    
    
    .raise-input {
      padding: 12px 16px;
      background: #0b0b12;
      border: 2px solid rgba(0, 212, 170, 0.5);
      border-radius: 8px;
      color: #e9eef7;
      font-size: 18px;
      font-family: "Courier New", monospace;
      font-weight: 600;
      text-align: center;
      width: 200px;
      margin: 0 auto;
    }
    
    .raise-input:focus {
      outline: none;
      border-color: #00d4aa;
      box-shadow: 0 0 0 3px rgba(0, 212, 170, 0.2);
    }
    
    .raise-slider {
      width: 100%;
      height: 8px;
      background: rgba(0, 212, 170, 0.2);
      border-radius: 4px;
      outline: none;
      -webkit-appearance: none;
      appearance: none;
    }
    
    .raise-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      background: #00d4aa;
      cursor: pointer;
      border-radius: 50%;
      box-shadow: 0 2px 8px rgba(0, 212, 170, 0.5);
    }
    
    .raise-slider::-moz-range-thumb {
      width: 20px;
      height: 20px;
      background: #00d4aa;
      cursor: pointer;
      border-radius: 50%;
      border: none;
      box-shadow: 0 2px 8px rgba(0, 212, 170, 0.5);
    }
    
    .raise-slider-value {
      text-align: center;
      font-size: 32px;
      font-weight: 700;
      color: #00d4aa;
      font-family: "Courier New", monospace;
      margin-bottom: 8px;
    }
    
    .raise-actions {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-top: 20px;
    }
    
    .raise-actions .btn {
      min-width: 140px;
    }
    
    #raiseSubmitBtn {
      color: #00d4aa;
      border-color: #00d4aa;
    }
    
    #raiseSubmitBtn:hover {
      background: #00d4aa;
      color: #0b0b12;
    }
    
    /* ============================================ */
    
    /* FOLD - Red outline */
    #foldBtn {
      color: #dc2626;
      border-color: #dc2626;
    }
    
    #foldBtn:hover:not(:disabled) {
      background: #dc2626;
      color: #0b0b12;
      box-shadow: 0 4px 12px rgba(220, 38, 38, 0.4);
    }
    
    /* CALL - Teal outline */
    #callBtn {
      color: #00d4aa;
      border-color: #00d4aa;
    }
    
    #callBtn:hover:not(:disabled) {
      background: #00d4aa;
      color: #0b0b12;
      box-shadow: 0 4px 12px rgba(0, 212, 170, 0.4);
    }
    
    /* RAISE - Orange outline */
    #raiseBtn {
      color: #f97316;
      border-color: #f97316;
    }
    
    #raiseBtn:hover:not(:disabled) {
      background: #f97316;
      color: #0b0b12;
      box-shadow: 0 4px 12px rgba(249, 115, 22, 0.4);
    }
    
    
    .my-cards {
      background: rgba(0,212,170,0.1);
      border: 2px solid #00d4aa;
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 30px;
    }
    
    .my-cards h3 {
      color: #00d4aa;
      margin-bottom: 15px;
    }
    
    .cards-display {
      display: flex;
      gap: 10px;
    }
    
    .card {
      width: 80px;
      height: 112px;
      background-size: cover;
      background-position: center;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }
    
    .debug {
      background: rgba(255,255,255,0.03);
      padding: 15px;
      border-radius: 8px;
      font-family: 'Courier New', monospace;
      font-size: 0.85rem;
      color: #9aa3b2;
      max-height: 300px;
      overflow-y: auto;
    }
    
    .debug h4 {
      color: #ff5100;
      margin-bottom: 10px;
    }
    
    /* Calming UI Adjustments */
    .container {
      max-width: 1400px;
      margin: 0 auto;
    }
    
    h2 {
      color: rgba(255,255,255,0.9);
      font-weight: 600;
      font-size: 1.1rem;
      margin-bottom: 16px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    #currentActor {
      color: var(--accent);
      font-weight: 700;
    }
  </style>
</head>
<body>
  <!-- UNIFIED NAVBAR -->
  <nav class="navbar">
    <a href="/" class="navbar-brand">PokerGeek.ai</a>
    <ul class="navbar-links">
      <li><a href="/">Home</a></li>
      <li><a href="/play">Play Now</a></li>
      <li><a href="/friends">Friends</a></li>
      <li><a href="/ai-solver">AI Solver</a></li>
      <li><a href="/analysis">Analysis</a></li>
      <li><a href="/learning">Learning</a></li>
      <li><a href="/poker-today">Poker Today</a></li>
    </ul>
    <div class="navbar-auth" id="navbarAuth">
      <a href="#" class="navbar-btn navbar-btn-login" onclick="openLoginModal()">Log In</a>
      <a href="#" class="navbar-btn navbar-btn-signup" onclick="openLoginModal()">Sign Up</a>
    </div>
    
    <!-- User Profile Tile (shown when logged in) -->
    <div class="navbar-user" id="navbarUser" style="display: none;">
      <div class="user-profile-tile" onclick="toggleUserDropdown()">
        <div class="user-avatar" id="userNavAvatar">üë§</div>
        <div class="user-info">
          <div class="user-name" id="userNavName">Username</div>
          <div class="user-status">Online</div>
        </div>
        <div class="user-menu-icon">‚öôÔ∏è</div>
      </div>
      
      <!-- User Dropdown Menu -->
      <div id="userDropdown" class="user-dropdown" style="display: none;">
        <a href="#" class="dropdown-item" onclick="openProfileModal()">üë§ My Profile</a>
        <a href="/friends" class="dropdown-item">üë• Friends</a>
        <a href="#" class="dropdown-item" onclick="openSettingsModal()">‚öôÔ∏è Settings</a>
        <div class="dropdown-divider"></div>
        <a href="#" class="dropdown-item" onclick="handleLogout()">üö™ Logout</a>
      </div>
    </div>
  </nav>

  <!-- üèÜ WINNER BANNER (hidden by default) -->
  <div class="winner-banner" id="winnerBanner"></div>
  
  <!-- üÉè SHOW/MUCK CONTROLS (showdown only) -->
  <div class="showdown-controls" id="showdownControls">
    <h3>üÉè Show your cards or muck?</h3>
    <div class="button-group">
      <button class="show-btn" onclick="showCards()">SHOW CARDS</button>
      <button class="muck-btn" onclick="muckCards()">MUCK</button>
    </div>
  </div>
  
  <div class="container">
    <!-- CLEAN HEADER -->
    <div class="table-header">
      <div class="room-code-display">
        <span class="room-code-label">Room</span>
        <span class="room-code" id="roomCode">---</span>
      </div>
      <div class="connection-indicator" id="socketStatus">
        <span class="connection-dot"></span>
      </div>
    </div>
    
    <!-- üéõÔ∏è HOST CONTROLS PANEL -->
    <div id="hostControlsPanel">
      <div class="panel-header">
        <h2>üéõÔ∏è HOST CONTROLS <span class="host-badge">ONLY YOU</span></h2>
        <button class="collapse-btn" onclick="toggleHostControls()">
          <span class="toggle-icon" id="hostToggleIcon">‚ñº</span>
        </button>
      </div>
      
      <div class="panel-content" id="hostControlsContent">
        <!-- ESSENTIAL ACTIONS -->
        <div class="host-section">
          <h4>‚ö° Essential Actions</h4>
          <p class="section-hint">Quick controls for managing your game</p>
          <div class="host-actions-grid">
            <button class="host-control-btn action" onclick="toggleRoomLock()">
              <span class="btn-icon">üîí</span>
              <span class="btn-text" id="lockBtnText">LOCK ROOM</span>
            </button>
            <button class="host-control-btn action" onclick="openKickPlayerModal()">
              <span class="btn-icon">üë¢</span>
              <span class="btn-text">KICK PLAYER</span>
            </button>
            <button class="host-control-btn action" onclick="togglePauseGame()" id="pauseGameBtn">
              <span class="btn-icon">‚è∏Ô∏è</span>
              <span class="btn-text">PAUSE GAME</span>
            </button>
            <button class="host-control-btn action" onclick="forceNextHand()">
              <span class="btn-icon">‚è≠Ô∏è</span>
              <span class="btn-text">NEXT HAND</span>
            </button>
          </div>
        </div>
        
        <!-- GAME SETTINGS -->
        <div class="host-section">
          <h4>‚öôÔ∏è Game Settings</h4>
          
          <!-- Action Timer -->
          <div class="setting-group">
            <div class="setting-label">
              <span>‚è±Ô∏è Action Timer</span>
              <small>Set time limit per decision (0 = unlimited)</small>
            </div>
            <div class="timer-buttons">
              <button class="timer-btn" onclick="setActionTimer(0)">OFF</button>
              <button class="timer-btn" onclick="setActionTimer(15)">15s</button>
              <button class="timer-btn" onclick="setActionTimer(30)">30s</button>
              <button class="timer-btn" onclick="setActionTimer(45)">45s</button>
              <button class="timer-btn" onclick="setActionTimer(60)">60s</button>
            </div>
            <div class="timer-status">
              Current: <span id="actionTimerDisplay">OFF</span>
            </div>
          </div>
          
          <!-- Auto-Start Toggle -->
          <div class="setting-row">
            <div class="setting-label">
              <span>üîÑ Auto-Start Hands</span>
              <small>Automatically begin next hand when ready</small>
            </div>
            <label class="toggle-switch">
              <input type="checkbox" id="autoStartToggle" onchange="toggleAutoStart()" checked>
              <span class="toggle-slider"></span>
            </label>
          </div>
          
          <!-- Spectator Mode Toggle -->
          <div class="setting-row">
            <div class="setting-label">
              <span>üëÅÔ∏è Spectator Mode</span>
              <small>Allow kicked players to watch game</small>
            </div>
            <label class="toggle-switch">
              <input type="checkbox" id="spectatorToggle" onchange="toggleSpectatorMode()" checked>
              <span class="toggle-slider"></span>
            </label>
          </div>
        </div>
        
        <!-- BLIND CONTROLS -->
        <div class="host-section">
          <h4>üí∞ Blind Controls</h4>
          <p class="section-hint">Adjust blinds between hands</p>
          <div class="blinds-controls">
            <div class="blind-input-group">
              <label>Small Blind:</label>
              <input type="number" id="hostSmallBlindInput" value="10" min="1" class="form-input">
            </div>
            <div class="blind-input-group">
              <label>Big Blind:</label>
              <input type="number" id="hostBigBlindInput" value="20" min="2" class="form-input">
            </div>
            <button class="host-control-btn update" onclick="updateBlinds()">UPDATE BLINDS</button>
          </div>
        </div>
        
        <!-- DANGER ZONE -->
        <div class="host-section danger-zone">
          <h4>‚ö†Ô∏è Danger Zone</h4>
          <p class="section-hint">Destructive actions - use with caution</p>
          <div class="host-actions-grid">
            <button class="host-control-btn danger" onclick="resetAllStacks()">
              <span class="btn-icon">üîÑ</span>
              <span class="btn-text">RESET STACKS</span>
            </button>
            <button class="host-control-btn danger" onclick="endGame()">
              <span class="btn-icon">üõë</span>
              <span class="btn-text">END GAME</span>
            </button>
          </div>
        </div>
      </div>
    </div>
    
    <!-- ‚öôÔ∏è PLAYER SETTINGS (Non-Host Players) -->
    <div id="playerSettingsPanel">
      <div class="panel-header">
        <h2>‚öôÔ∏è Player Settings</h2>
        <button class="collapse-btn" onclick="togglePlayerSettings()">
          <span class="toggle-icon" id="playerSettingsToggle">‚ñº</span>
        </button>
      </div>
      
      <div class="panel-content" id="playerSettingsContent">
        <!-- TABLE COLOR -->
        <div class="host-section">
          <h4>üé® Table Color</h4>
          <p class="section-hint">Choose your preferred felt color (saved locally)</p>
          <div class="color-picker-grid">
            <button class="color-btn" data-color="green" onclick="changeFeltColor('green')" title="Classic Green">
              <div class="color-preview" style="background: #197a45;"></div>
              <span>Green</span>
            </button>
            <button class="color-btn" data-color="red" onclick="changeFeltColor('red')" title="Ruby Red">
              <div class="color-preview" style="background: #6b1414;"></div>
              <span>Red</span>
            </button>
            <button class="color-btn" data-color="blue" onclick="changeFeltColor('blue')" title="Ocean Blue">
              <div class="color-preview" style="background: #0f2942;"></div>
              <span>Blue</span>
            </button>
            <button class="color-btn" data-color="black" onclick="changeFeltColor('black')" title="Midnight Black">
              <div class="color-preview" style="background: #1a1a1a;"></div>
              <span>Black</span>
            </button>
            <button class="color-btn" data-color="grey" onclick="changeFeltColor('grey')" title="Steel Grey">
              <div class="color-preview" style="background: #2a2a2a;"></div>
              <span>Grey</span>
            </button>
            <button class="color-btn" data-color="tan" onclick="changeFeltColor('tan')" title="Desert Tan">
              <div class="color-preview" style="background: #6b5642;"></div>
              <span>Tan</span>
            </button>
            <button class="color-btn" data-color="purple" onclick="changeFeltColor('purple')" title="Royal Purple">
              <div class="color-preview" style="background: #3a1450;"></div>
              <span>Purple</span>
            </button>
          </div>
        </div>
        
        <!-- 4-COLOR DECK -->
        <div class="host-section">
          <h4>üÉè 4-Color Deck</h4>
          <p class="section-hint">Easier suit distinction (accessibility)</p>
          <label class="toggle-switch">
            <input type="checkbox" id="fourColorDeck" onchange="toggleFourColorDeck(this.checked)">
            <span class="toggle-slider"></span>
            <span class="toggle-label">Enable 4-Color Deck</span>
          </label>
          <p class="setting-note">Coming soon - will use distinct colors for each suit</p>
        </div>
        
        <!-- CARD BACK DESIGN -->
        <div class="host-section">
          <h4>üé¥ Card Back Design</h4>
          <p class="section-hint">Choose your card back style</p>
          <select id="cardBackSelect" onchange="changeCardBack(this.value)" class="settings-select">
            <option value="default">Classic</option>
            <option value="modern">Modern (Coming Soon)</option>
            <option value="minimal">Minimal (Coming Soon)</option>
            <option value="geometric">Geometric (Coming Soon)</option>
          </select>
        </div>
        
        <!-- ANIMATION SPEED -->
        <div class="host-section">
          <h4>‚ö° Animation Speed</h4>
          <p class="section-hint">Card dealing and chip animations</p>
          <select id="animSpeedSelect" onchange="changeAnimSpeed(this.value)" class="settings-select">
            <option value="fast">Fast (200ms)</option>
            <option value="normal" selected>Normal (400ms)</option>
            <option value="slow">Slow (600ms)</option>
          </select>
        </div>
        
        <!-- AUTO-MUCK -->
        <div class="host-section">
          <h4>üôà Auto-Muck</h4>
          <p class="section-hint">Automatically hide losing hands at showdown</p>
          <label class="toggle-switch">
            <input type="checkbox" id="autoMuck" onchange="toggleAutoMuck(this.checked)">
            <span class="toggle-slider"></span>
            <span class="toggle-label">Enable Auto-Muck</span>
          </label>
        </div>
        
        <!-- CHIP DISPLAY FORMAT -->
        <div class="host-section">
          <h4>üí∞ Chip Display</h4>
          <p class="section-hint">How chips are shown</p>
          <select id="chipFormatSelect" onchange="changeChipFormat(this.value)" class="settings-select">
            <option value="full" selected>Full ($1,500)</option>
            <option value="compact">Compact ($1.5K)</option>
          </select>
        </div>
        
        <!-- ACTION CONFIRMATION -->
        <div class="host-section">
          <h4>‚ö†Ô∏è Action Confirmation</h4>
          <p class="section-hint">Confirm before big actions</p>
          <label class="toggle-switch">
            <input type="checkbox" id="actionConfirm" onchange="toggleActionConfirm(this.checked)">
            <span class="toggle-slider"></span>
            <span class="toggle-label">Confirm Big Bets/Folds</span>
          </label>
        </div>
        
        <!-- HOTKEYS -->
        <div class="host-section">
          <h4>‚å®Ô∏è Keyboard Shortcuts</h4>
          <p class="section-hint">Quick actions with keyboard</p>
          <label class="toggle-switch">
            <input type="checkbox" id="hotkeysEnabled" onchange="toggleHotkeys(this.checked)">
            <span class="toggle-slider"></span>
            <span class="toggle-label">Enable Hotkeys</span>
          </label>
          <div class="hotkey-list" style="margin-top: 12px; font-size: 0.85rem; color: #9aa3b2;">
            <div><kbd>F</kbd> = Fold</div>
            <div><kbd>C</kbd> = Check/Call</div>
            <div><kbd>R</kbd> = Raise</div>
            <div><kbd>Space</kbd> = Confirm Action</div>
          </div>
        </div>
      </div>
    </div>
    
    <div class="controls">
      <button class="btn" id="startBtn" style="display:none">üéÆ START HAND</button>
      <button class="btn" id="refreshBtn">üîÑ REFRESH</button>
    </div>
    
    <!-- HIDDEN: Old top sections (deprecated - info now on table) -->
    <div style="display: none !important;">
      <div class="my-cards" id="communitySection">
        <div class="cards-display"></div>
        <span id="currentBet">0</span>
        <span id="currentBetDisplay">0</span>
      </div>
      
      <div class="my-cards" id="myCardsSection">
        <span id="turnIndicator"></span>
        <div class="cards-display" id="myCards"></div>
        <div id="handStrength">
          <div id="handStrengthText"></div>
        </div>
      </div>
    </div>
    
    <h2 style="margin-bottom: 15px;">Seats <span id="currentActor" style="font-size: 0.9rem; color: #ff5100; font-weight: normal;"></span></h2>
    
    <!-- üé∞ POKER TABLE (Zoom-Locked) -->
    <div class="table-wrapper" id="tableWrapper">
      <div class="poker-table" id="pokerTable">
        <!-- Oval Felt Background -->
        <div class="table-felt"></div>
        
        <!-- Board Center (Community Cards + Pot) -->
        <div class="board-center">
          <div class="community-cards-center" id="communityCards"></div>
          <div class="pot-display-center">
            <div class="pot-label">POT</div>
            <div class="pot-amount" id="potAmount">$0</div>
          </div>
        </div>
        
        <!-- Seats Layer -->
        <div class="seats-layer">
          <div class="seats-grid" id="seats"></div>
        </div>
      </div>
    </div>
    
    <!-- ACTION BUTTONS (Below Table) -->
    <div id="actionButtons" style="display:none; margin-top: 30px; display: flex; justify-content: center; gap: 30px; max-width: 800px; margin-left: auto; margin-right: auto;">
      <button class="btn" id="foldBtn">FOLD</button>
      <button class="btn" id="callBtn"><span id="callBtnText">CALL</span> $<span id="callAmount">0</span></button>
      <button class="btn" id="raiseBtn">RAISE</button>
    </div>
    
    <!-- RAISE PANEL (Below Buttons) -->
    <div id="raisePanel" class="raise-panel" style="display: none;">
      <!-- Slider + Display Value (Top) -->
      <div class="raise-slider-section">
        <input type="range" id="raiseSlider" class="raise-slider" min="0" max="1000" step="1" />
        <div class="raise-slider-value" id="raiseSliderValue">$0</div>
        <input type="number" id="raiseAmount" class="raise-input" placeholder="Enter amount" />
      </div>
      
      <!-- Preset Buttons (Middle) -->
      <div class="raise-presets">
        <button class="raise-preset-btn" onclick="setRaisePreset('quarter')">1/4 Pot</button>
        <button class="raise-preset-btn" onclick="setRaisePreset('half')">1/2 Pot</button>
        <button class="raise-preset-btn" onclick="setRaisePreset('threequarter')">3/4 Pot</button>
        <button class="raise-preset-btn" onclick="setRaisePreset('pot')">Pot</button>
        <button class="raise-preset-btn" onclick="setRaisePreset('double')">2x Pot</button>
        <button class="raise-preset-btn" onclick="setRaisePreset('allin')">All-In</button>
      </div>
      
      <!-- Pot Info (Bottom) -->
      <div class="raise-info">
        <div class="raise-info-item">
          <span class="raise-info-label">Pot:</span>
          <span class="raise-info-value" id="raiseModalPot">$0</span>
        </div>
        <div class="raise-info-item">
          <span class="raise-info-label">Your Stack:</span>
          <span class="raise-info-value" id="raiseModalStack">$0</span>
        </div>
        <div class="raise-info-item">
          <span class="raise-info-label">Min Raise:</span>
          <span class="raise-info-value" id="raiseModalMin">$0</span>
        </div>
      </div>
      
      <!-- Submit Actions -->
      <div class="raise-actions">
        <button class="btn" style="background: #666; color: #fff; border-color: #666;" onclick="closeRaisePanel()">Cancel</button>
        <button class="btn" id="raiseSubmitBtn" onclick="submitRaise()">Raise</button>
      </div>
    </div>
    
    <div class="debug">
      <h4>Debug Console</h4>
      <div id="debugLog"></div>
    </div>
  </div>
  
  <script src="/socket.io/socket.io.js"></script>
  <script>
    // ============================================
    // GLOBAL STATE
    // ============================================
    let roomId = null;
    let userId = null;
    let gameId = null;
    let socket = null;
    let isHost = false; // Track if current user is host
    let isClaimingSeat = false; // Prevent duplicate seat claims
    let currentGameState = null; // Track current game state for UI logic
    let myHoleCards = null; // Track user's hole cards to show on their seat tile
    
    // ============================================
    // UTILITY: DEBUG LOGGING
    // ============================================
    function debug(message, data = null) {
      console.log(message, data);
      const log = document.getElementById('debugLog');
      const time = new Date().toLocaleTimeString();
      const entry = document.createElement('div');
      entry.textContent = `[${time}] ${message}`;
      if (data) {
        entry.textContent += ' ' + JSON.stringify(data, null, 2);
      }
      log.appendChild(entry);
      log.scrollTop = log.scrollHeight;
    }
    
    // ============================================
    // UTILITY: CARD IMAGE PATH CONVERTER
    // ============================================
    function getCardImagePath(card) {
      // Convert "Ah" ‚Üí "hearts_A.png", "Ks" ‚Üí "spades_K.png", "Td" ‚Üí "diamonds_10.png"
      if (!card || card.length < 2) return '/cards/back.png';
      
      const rank = card.slice(0, -1); // "A", "K", "T", "2", etc.
      const suitChar = card.slice(-1); // "h", "s", "d", "c"
      
      const suitMap = {
        'h': 'hearts',
        's': 'spades',
        'd': 'diamonds',
        'c': 'clubs'
      };
      
      const rankMap = {
        'T': '10'
      };
      
      const suit = suitMap[suitChar] || 'hearts';
      const finalRank = rankMap[rank] || rank;
      
      return `/cards/${suit}_${finalRank}.png`;
    }
    
    // ============================================
    // NAVBAR FUNCTIONS
    // ============================================
    
    function toggleUserDropdown() {
      const dropdown = document.getElementById('userDropdown');
      dropdown.style.display = dropdown.style.display === 'none' ? 'block' : 'none';
    }
    
    // Close dropdown when clicking outside
    document.addEventListener('click', function(event) {
      const dropdown = document.getElementById('userDropdown');
      const profileTile = document.querySelector('.user-profile-tile');
      
      if (dropdown && profileTile && 
          !dropdown.contains(event.target) && 
          !profileTile.contains(event.target)) {
        dropdown.style.display = 'none';
      }
    });
    
    function openLoginModal() {
      alert('üîí Login Modal - Coming Soon!\n\nThis will open the authentication modal.');
      // TODO: Implement login modal
    }
    
    function openProfileModal() {
      alert('üë§ Profile Modal - Coming Soon!\n\nThis will show your stats:\n- Best Hand\n- Hands Played\n- Games Played\n- Win Rate');
      // TODO: Implement profile modal
    }
    
    function openSettingsModal() {
      alert('‚öôÔ∏è Settings Modal - Coming Soon!\n\nThis will allow you to:\n- Change username\n- Update email\n- Manage notifications');
      // TODO: Implement settings modal
    }
    
    async function handleLogout() {
      const confirmed = confirm('üö™ Are you sure you want to logout?');
      if (!confirmed) return;
      
      try {
        // Clear Supabase session
        const supabaseAuth = localStorage.getItem('sb-ztqcpuktihltfepnexcx-auth-token');
        if (supabaseAuth) {
          localStorage.removeItem('sb-ztqcpuktihltfepnexcx-auth-token');
        }
        
        // Clear session storage
        sessionStorage.clear();
        
        alert('‚úÖ Logged out successfully!');
        window.location.href = '/';
        
      } catch (error) {
        console.error('Logout error:', error);
        alert('‚ùå Logout failed. Please try again.');
      }
    }
    
    // Update navbar based on auth state
    function updateNavbar() {
      const navbarAuth = document.getElementById('navbarAuth');
      const navbarUser = document.getElementById('navbarUser');
      
      // Check if user is authenticated
      const supabaseAuth = localStorage.getItem('sb-ztqcpuktihltfepnexcx-auth-token');
      
      if (supabaseAuth) {
        try {
          const authData = JSON.parse(supabaseAuth);
          if (authData && authData.user) {
            // Show user profile, hide auth buttons
            navbarAuth.style.display = 'none';
            navbarUser.style.display = 'block';
            
            // Update user info
            const userName = authData.user.email?.split('@')[0] || 'Player';
            document.getElementById('userNavName').textContent = userName;
            
            // Generate avatar emoji based on user ID
            const avatarEmojis = ['üòé', 'üéÆ', 'üéØ', 'üöÄ', '‚≠ê', 'üíé', 'üî•', '‚ö°'];
            const avatarIndex = authData.user.id?.charCodeAt(0) % avatarEmojis.length || 0;
            document.getElementById('userNavAvatar').textContent = avatarEmojis[avatarIndex];
            
            debug('‚úÖ Navbar updated for authenticated user');
          }
        } catch (error) {
          console.error('Error parsing auth data:', error);
        }
      } else {
        // Show auth buttons, hide user profile
        navbarAuth.style.display = 'flex';
        navbarUser.style.display = 'none';
      }
    }
    
    // ============================================
    // STEP 1: INITIALIZE
    // ============================================
    function init() {
      debug('üé¨ Initializing minimal table...');
      
      // Get room ID from URL
      const urlParams = new URLSearchParams(window.location.search);
      roomId = urlParams.get('room');
      
      // PRIORITY 1: Check if user is authenticated via Supabase
      let isAuthenticated = false;
      
      try {
        // Check localStorage for Supabase session (standard location)
        const supabaseAuth = localStorage.getItem('sb-ztqcpuktihltfepnexcx-auth-token');
        if (supabaseAuth) {
          const authData = JSON.parse(supabaseAuth);
          if (authData && authData.user && authData.user.id) {
            userId = authData.user.id;
            isAuthenticated = true;
            sessionStorage.setItem('userId', userId);
            sessionStorage.setItem('userEmail', authData.user.email || 'Unknown');
            debug('‚úÖ Authenticated user detected:', { userId, email: authData.user.email });
          }
        }
      } catch (e) {
        debug('‚ö†Ô∏è Could not read Supabase auth:', e.message);
      }
      
      // PRIORITY 2: Try window.currentUser (if available)
      if (!userId && window.currentUser && window.currentUser.id) {
        userId = window.currentUser.id;
        isAuthenticated = true;
        sessionStorage.setItem('userId', userId);
        debug('‚úÖ Found window.currentUser:', userId);
      }
      
      // PRIORITY 3: Check sessionStorage
      if (!userId) {
        userId = sessionStorage.getItem('userId');
        
        // Validate UUID format (check if it's actually a UUID)
        const isValidUUID = userId && /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(userId);
        
        if (!isValidUUID) {
          // Clear invalid ID
          if (userId) {
            debug('‚ö†Ô∏è Invalid UUID detected, clearing:', userId);
            sessionStorage.removeItem('userId');
            userId = null;
          }
        }
      }
      
      // LAST RESORT: Generate guest UUID
      if (!userId) {
        userId = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
          const r = Math.random() * 16 | 0;
          const v = c === 'x' ? r : (r & 0x3 | 0x8);
          return v.toString(16);
        });
        sessionStorage.setItem('userId', userId);
        sessionStorage.setItem('isGuest', 'true');
        debug('‚ö†Ô∏è No auth found, generated guest UUID:', userId);
      }
      
      // Validate
      if (!roomId) {
        alert('‚ùå No room ID in URL. Redirecting to lobby...');
        window.location.href = '/play';
        return;
      }
      
      debug('‚úÖ Initialized', { roomId, userId, isAuthenticated });
      
      // Wire up buttons
      document.getElementById('startBtn').onclick = startHand;
      document.getElementById('refreshBtn').onclick = loadRoom;
      
      // Initialize navbar state
      updateNavbar();
      
      // Initialize host controls settings from localStorage
      initializeHostSettings();
      
      // Connect WebSocket
      connectWebSocket();
      
      // CRITICAL: Hydrate game state before loading room
      hydrateGameState();
    }
    
    // Initialize host settings from localStorage
    function initializeHostSettings() {
      // Restore action timer
      const savedTimer = localStorage.getItem('pokergeek_action_timer');
      if (savedTimer) {
        actionTimerSeconds = parseInt(savedTimer);
        const display = document.getElementById('actionTimerDisplay');
        if (display) {
          display.textContent = actionTimerSeconds === 0 ? 'OFF' : `${actionTimerSeconds}s`;
          // Mark active button
          document.querySelectorAll('.timer-btn').forEach(btn => {
            const btnValue = btn.textContent.trim();
            if ((actionTimerSeconds === 0 && btnValue === 'OFF') ||
                (btnValue === `${actionTimerSeconds}s`)) {
              btn.classList.add('active');
            }
          });
        }
      }
      
      // Restore auto-start setting
      const autoStart = localStorage.getItem('pokergeek_auto_start');
      if (autoStart === 'false') {
        const checkbox = document.getElementById('autoStartToggle');
        if (checkbox) checkbox.checked = false;
      }
      
      // Restore spectator mode setting
      const spectatorMode = localStorage.getItem('pokergeek_spectator_mode');
      if (spectatorMode === 'false') {
        const checkbox = document.getElementById('spectatorToggle');
        if (checkbox) checkbox.checked = false;
      }
      
      // Expand both panels by default
      setTimeout(() => {
        const hostContent = document.getElementById('hostControlsContent');
        const playerContent = document.getElementById('playerSettingsContent');
        if (hostContent) hostContent.classList.add('expanded');
        if (playerContent) playerContent.classList.add('expanded');
      }, 100);
      
      debug('‚öôÔ∏è Host settings initialized from localStorage');
    }
    
    // ============================================
    // CRITICAL: HYDRATE GAME STATE ON REFRESH
    // ============================================
    async function hydrateGameState() {
      debug('üíß Hydrating game state...');
      
      try {
        const response = await fetch(`/api/engine/hydrate/${roomId}/${userId}`);
        
        if (!response.ok) {
          debug('‚ö†Ô∏è Hydration failed, loading lobby state');
          loadRoom();
          return;
        }
        
        const data = await response.json();
        
        if (!data.hasActiveGame) {
          debug('‚è∏Ô∏è  No active game - loading lobby');
          loadRoom();
          return;
        }
        
        // ACTIVE GAME FOUND - RESTORE STATE
        debug('üéÆ ACTIVE GAME FOUND - RESTORING STATE', {
          handNumber: data.gameState.handNumber,
          street: data.gameState.street,
          pot: data.gameState.pot
        });
        
        gameId = data.gameId;
        currentGameState = data.gameState; // Store for UI logic
        
        // Show community section
        document.getElementById('communitySection').style.display = 'block';
        
        // Render community cards
        if (data.gameState.communityCards && data.gameState.communityCards.length > 0) {
          renderCommunityCards(data.gameState.communityCards);
        }
        
        // Update pot and bet
        document.getElementById('potAmount').textContent = data.gameState.pot || 0;
        document.getElementById('currentBet').textContent = data.gameState.currentBet || 0;
        
        // Show current actor
        const actorText = document.getElementById('currentActor');
        if (data.gameState.currentActorSeat !== undefined) {
          actorText.textContent = `(Seat ${data.gameState.currentActorSeat}'s turn)`;
          actorText.style.display = 'inline';
        }
        
        // Render my hole cards
        if (data.myHoleCards && data.myHoleCards.length === 2) {
          myHoleCards = data.myHoleCards; // Store globally
          renderMyCards(data.myHoleCards);
        }
        
        // Show/hide action buttons based on turn
        const actionButtons = document.getElementById('actionButtons');
        if (data.isMyTurn && data.gameState.status === 'IN_PROGRESS') {
          actionButtons.style.display = 'flex';
          updateActionButtons(data.gameState);
        } else {
          actionButtons.style.display = 'none';
        }
        
        // Hide START button (game is active)
        document.getElementById('startBtn').style.display = 'none';
        
        // Update seat card backings (pass myHoleCards to show on my seat)
        updateSeatCardBackings(data.gameState, myHoleCards);
        
        // Update position badges (dealer, SB, BB)
        updatePositionBadges(data.gameState);
        
        debug('‚úÖ Game state restored successfully');
        
        // Still load room to get seat info
        loadRoom();
        
      } catch (error) {
        debug('‚ùå Hydration error', { error: error.message });
        console.error('Hydration error:', error);
        loadRoom(); // Fallback to normal flow
      }
    }
    
    // ============================================
    // STEP 2: WEBSOCKET CONNECTION
    // ============================================
    function connectWebSocket() {
      debug('üîå Connecting WebSocket...');
      
      socket = io();
      
      socket.on('connect', () => {
        debug('‚úÖ Socket connected', { socketId: socket.id });
        document.getElementById('socketStatus').classList.add('connected');
        
        // Join room
        socket.emit('join_room', { roomId, userId });
        debug('üì° Sent join_room event', { roomId, userId });
      });
      
      socket.on('disconnect', (reason) => {
        debug('üî¥ Socket disconnected', { reason });
        document.getElementById('socketStatus').classList.remove('connected');
      });
      
      socket.on('seat_update', (data) => {
        debug('ü™ë Seat update received', data);
        loadRoom();
      });
      
      socket.on('hand_started', (data) => {
        debug('üÉè Hand started event', data);
        
        // CRITICAL: Clear UI from previous hand (especially for guests)
        document.getElementById('communityCards').innerHTML = '';
        document.getElementById('myCards').innerHTML = '';
        document.getElementById('actionButtons').style.display = 'none';
        document.getElementById('handStrength').style.display = 'none';
        document.getElementById('myCardsSection').style.display = 'none';
        document.getElementById('startBtn').style.display = 'none';
        
        // Store game state ID
        if (data.gameStateId) {
          gameId = data.gameStateId;
        }
        
        // Display public game state
        if (data.gameState) {
          const gs = data.gameState;
          currentGameState = gs; // Store for UI logic
          
          // Show community section
          document.getElementById('communitySection').style.display = 'block';
          document.getElementById('potAmount').textContent = gs.pot || 0;
          document.getElementById('currentBet').textContent = gs.currentBet || 0;
          
          // Show current actor
          const actorText = document.getElementById('currentActor');
          if (gs.currentActorSeat !== undefined) {
            actorText.textContent = `(Seat ${gs.currentActorSeat}'s turn)`;
            actorText.style.display = 'inline';
          }
          
          debug('‚úÖ Game state updated', { pot: gs.pot, currentBet: gs.currentBet, street: gs.street });
          
          // Update seat card backings (pass myHoleCards to show on my seat)
          updateSeatCardBackings(gs, myHoleCards);
          
          // Update position badges (dealer, SB, BB)
          updatePositionBadges(gs);
        }
        
        // Fetch my hole cards (for guests who didn't initiate the hand)
        fetchMyCards();
        
        // Reload to show updated seats/chips
        setTimeout(loadRoom, 500);
      });
      
      // Listen for action processed events
      socket.on('action_processed', (data) => {
        debug('üéÆ Action processed', data);
        
        // Update game state display
        if (data.gameState) {
          const gs = data.gameState;
          currentGameState = gs; // Store for UI logic
          
          document.getElementById('potAmount').textContent = gs.pot || 0;
          document.getElementById('currentBet').textContent = gs.currentBet || 0;
          
          // Update current actor
          const actorText = document.getElementById('currentActor');
          if (gs.currentActorSeat !== undefined) {
            actorText.textContent = `(Seat ${gs.currentActorSeat}'s turn)`;
          }
          
          // Show community cards if any
          if (gs.communityCards && gs.communityCards.length > 0) {
            renderCommunityCards(gs.communityCards);
          }
          
          // CRITICAL: Show/update action buttons based on game state
          const actionButtons = document.getElementById('actionButtons');
          
          if (gs.status === 'IN_PROGRESS') {
            actionButtons.style.display = 'flex';
            updateActionButtons(gs);
          } else {
            actionButtons.style.display = 'none';
          }
          
          // Check if hand is over
          if (gs.status === 'COMPLETED') {
            handleHandComplete(gs);
          }
          
          // Update seat card backings (show folds, etc) (pass myHoleCards to show on my seat)
          updateSeatCardBackings(gs, myHoleCards);
          
          // Update position badges (dealer, SB, BB)
          updatePositionBadges(gs);
          
          // Update chips in real-time (CRITICAL: show chip stacks decreasing as players bet)
          updateSeatChips(gs.players);
        }
      });
      
      // Listen for showdown actions (show/muck)
      socket.on('showdown_action', (data) => {
        debug('üÉè Showdown action received:', data);
        
        const { action, seatIndex, nickname, holeCards } = data;
        
        if (action === 'SHOW' && holeCards) {
          // REPLACE card backs with actual card images
          const cardBacksContainer = document.querySelector(`.seat-cards[data-seat-index="${seatIndex}"]`);
          if (cardBacksContainer) {
            cardBacksContainer.innerHTML = ''; // Clear card backs
            
            // Display actual cards using images
            holeCards.forEach(card => {
              const cardImg = document.createElement('img');
              cardImg.className = 'seat-card-front';
              cardImg.src = getCardImagePath(card);
              cardImg.alt = card;
              cardImg.onerror = function() {
                // Fallback if image doesn't exist
                this.src = '/cards/back.png';
              };
              cardBacksContainer.appendChild(cardImg);
            });
            
            debug(`‚úÖ @${nickname} showed cards: ${holeCards.join(' ')}`);
          }
        } else if (action === 'MUCK') {
          // Grey out card backs (already folded styling)
          const cardBacksContainer = document.querySelector(`.seat-cards[data-seat-index="${seatIndex}"]`);
          if (cardBacksContainer) {
            const cardBacks = cardBacksContainer.querySelectorAll('.seat-card-back');
            cardBacks.forEach(back => {
              back.classList.add('folded'); // Grey them out
            });
            
            debug(`‚úÖ @${nickname} mucked cards`);
          }
        }
      });
      
      // NOTE: Private hole cards are sent via HTTP response in startHand()
      // We'll add WebSocket private emit in Phase 2b
      
      socket.on('game_started', (data) => {
        debug('üéÆ Game started event', data);
        if (data.gameId) {
          gameId = data.gameId;
        }
        setTimeout(loadRoom, 1000);
      });
      
      // Host control events
      socket.on('blinds_updated', (data) => {
        debug('üí∞ Blinds updated immediately', data);
      });
      
      socket.on('blinds_queued', (data) => {
        debug('‚è≥ Blinds queued for next hand', data);
        // Show non-blocking notification to all players
      });
      
      socket.on('chips_adjusted', (data) => {
        debug('üíµ Chips adjusted by host', data);
        loadRoom(); // Refresh to show new chip amounts
        if (isHost) loadHostControls(); // Update host dropdown
      });
      
      socket.on('chips_queued', (data) => {
        debug('‚è≥ Chips queued for next hand', data);
        if (isHost) {
          showToast('‚è≥ Chips will update at end of hand', 'info');
        }
        if (isHost) loadHostControls(); // Update host dropdown to show new values
      });
      
      socket.on('player_kicked', (data) => {
        if (data.userId === userId) {
          alert('‚ùå You have been removed from the game by the host.');
          window.location.href = '/';
        }
      });
    }
    
    // ============================================
    // STEP 3: LOAD ROOM STATE
    // ============================================
    async function loadRoom() {
      debug('üåä Fetching room state...');
      
      try {
        // Get room info
        const roomResponse = await fetch(`/api/engine/room/${roomId}`);
        if (!roomResponse.ok) {
          throw new Error(`Failed to get room: ${roomResponse.status}`);
        }
        const roomData = await roomResponse.json();
        debug('‚úÖ Room data received', roomData);
        
        // Get seats
        const seatsResponse = await fetch(`/api/engine/seats/${roomId}`);
        if (!seatsResponse.ok) {
          throw new Error(`Failed to get seats: ${seatsResponse.status}`);
        }
        const seatsData = await seatsResponse.json();
        debug('‚úÖ Seats data received', seatsData);
        
        // Update room code
        document.getElementById('roomCode').textContent = roomData.room?.code || 'N/A';
        
        // Store game ID if exists
        if (roomData.room?.gameId) {
          gameId = roomData.room.gameId;
        }
        
        // Render seats
        renderSeats(seatsData.seats, roomData.room);
        
        // Show START button ONLY if:
        // 1. Room status is NOT ACTIVE (no game in progress)
        // 2. 2+ players seated
        // 3. User is host (or show "waiting" if not host)
        const seatedCount = seatsData.occupiedCount || 0;
        isHost = roomData.room?.hostId === userId; // Update global isHost
        const roomIsActive = roomData.room?.status === 'ACTIVE';
        
        // CRITICAL: If room is ACTIVE, NEVER show START button (game is in progress)
        if (roomIsActive) {
          document.getElementById('startBtn').style.display = 'none';
          debug('üéÆ Game active - START button hidden');
        } else if (isHost && seatedCount >= 2) {
          document.getElementById('startBtn').style.display = 'inline-block';
          document.getElementById('startBtn').disabled = false;
          document.getElementById('startBtn').textContent = 'üéÆ START HAND';
          debug('üéÆ START HAND button enabled (HOST)', { seatedCount });
        } else if (!isHost && seatedCount >= 2) {
          document.getElementById('startBtn').style.display = 'inline-block';
          document.getElementById('startBtn').disabled = true;
          document.getElementById('startBtn').textContent = '‚è≥ WAITING FOR HOST';
          debug('‚è≥ Waiting for host to start', { hostId: roomData.room?.hostId });
        } else {
          document.getElementById('startBtn').style.display = 'none';
        }
        
        // Load host controls if user is host
        if (isHost) {
          loadHostControls();
        }
        
      } catch (error) {
        debug('‚ùå Load room error', { error: error.message });
        console.error('Load room error:', error);
      }
    }
    
    // ============================================
    // STEP 4: RENDER SEATS
    // ============================================
    function renderSeats(seats, room) {
      debug('üé® Rendering seats...', { seatCount: seats ? seats.length : 0 });
      
      const seatsDiv = document.getElementById('seats');
      seatsDiv.innerHTML = '';
      
      // Check if game is active (hide empty seats during game)
      const isGameActive = currentGameState && (currentGameState.status === 'IN_PROGRESS' || currentGameState.status === 'COMPLETED');
      
      // Create 10 seats (0-9)
      for (let i = 0; i < 10; i++) {
        const seat = seats ? seats[i] : null;
        const isEmpty = !seat || !seat.userId;
        
        // Skip empty seats if game is active
        if (isEmpty && isGameActive) {
          debug(`‚è© Skipping empty seat ${i} (game active)`);
          continue;
        }
        
        const div = document.createElement('div');
        const isMe = seat && seat.userId === userId;
        
        div.className = 'seat';
        div.dataset.seatIndex = i; // Add data attribute for positioning
        if (isEmpty) {
          div.className += ' empty';
        } else if (isMe) {
          div.className += ' taken me';
        } else {
          div.className += ' taken';
        }
        
        const label = document.createElement('div');
        label.className = 'seat-label';
        label.textContent = `Seat ${i}`;
        // Hide seat label during games to save space for player name
        if (isGameActive && !isEmpty) {
          label.style.display = 'none';
        }
        
        const player = document.createElement('div');
        player.className = 'seat-player';
        
        const chips = document.createElement('div');
        chips.className = 'seat-chips';
        
        // Card backings container
        const cardBacksContainer = document.createElement('div');
        cardBacksContainer.className = 'seat-cards';
        cardBacksContainer.dataset.seatIndex = i;
        
        // Position badges container (dealer, SB, BB)
        const positionBadges = document.createElement('div');
        positionBadges.className = 'position-badges';
        positionBadges.dataset.seatIndex = i;
        
        if (isEmpty) {
          player.textContent = 'ü™ë EMPTY';
          chips.textContent = 'Click to claim';
          div.onclick = () => claimSeat(i);
        } else {
          // Display nickname with @ symbol
          const displayName = seat.nickname || `Guest_${seat.userId.substring(0, 6)}`;
          player.textContent = `@${displayName}`;
          if (isMe) player.textContent += ' (YOU)';
          chips.textContent = `$${(seat.chips || 1000).toLocaleString()}`;
        }
        
        div.appendChild(label);
        div.appendChild(player);
        div.appendChild(chips);
        div.appendChild(cardBacksContainer); // Add card backs container
        div.appendChild(positionBadges); // Add position badges
        
        seatsDiv.appendChild(div);
      }
      
      // Apply circular positions
      applySeatPositions();
      
      // Update card backings if game is active (pass myHoleCards to show on my seat)
      if (currentGameState) {
        updateSeatCardBackings(currentGameState, myHoleCards);
      }
      
      debug('‚úÖ Seats rendered');
    }
    
    // ============================================
    // STEP 4B: UPDATE SEAT CHIPS IN REAL-TIME
    // ============================================
    function updateSeatChips(players) {
      if (!players) return;
      
      debug('üí∞ Updating seat chips', { playerCount: players.length });
      
      players.forEach(player => {
        // Find the seat element
        const seatsDiv = document.getElementById('seats');
        const seatDivs = seatsDiv.querySelectorAll('.seat');
        
        seatDivs.forEach(seatDiv => {
          const label = seatDiv.querySelector('.seat-label');
          if (label && label.textContent === `Seat ${player.seatIndex}`) {
            // Update chips display
            const chipsDiv = seatDiv.querySelector('.seat-chips');
            if (chipsDiv && !chipsDiv.textContent.includes('Click to claim')) {
              chipsDiv.textContent = `$${(player.chips || 0).toLocaleString()}`;
            }
          }
        });
      });
    }
    
    // ============================================
    // STEP 4B2: UPDATE POSITION BADGES (DEALER, SB, BB)
    // ============================================
    function updatePositionBadges(gameState) {
      if (!gameState) return;
      
      debug('üé∞ Updating position badges', { 
        dealer: gameState.dealerPosition, 
        sb: gameState.sbPosition, 
        bb: gameState.bbPosition 
      });
      
      // Clear all existing badges first
      document.querySelectorAll('.position-badges').forEach(container => {
        container.innerHTML = '';
      });
      
      // Show badges during active game or showdown
      if (gameState.status !== 'IN_PROGRESS' && gameState.status !== 'COMPLETED') return;
      
      // Add dealer badge
      if (gameState.dealerPosition !== undefined) {
        const dealerContainer = document.querySelector(`.position-badges[data-seat-index="${gameState.dealerPosition}"]`);
        if (dealerContainer) {
          const badge = document.createElement('span');
          badge.className = 'position-badge dealer';
          badge.textContent = 'D';
          badge.title = 'Dealer';
          dealerContainer.appendChild(badge);
        }
      }
      
      // Add small blind badge
      if (gameState.sbPosition !== undefined) {
        const sbContainer = document.querySelector(`.position-badges[data-seat-index="${gameState.sbPosition}"]`);
        if (sbContainer) {
          const badge = document.createElement('span');
          badge.className = 'position-badge sb';
          badge.textContent = 'SB';
          badge.title = 'Small Blind';
          sbContainer.appendChild(badge);
        }
      }
      
      // Add big blind badge
      if (gameState.bbPosition !== undefined) {
        const bbContainer = document.querySelector(`.position-badges[data-seat-index="${gameState.bbPosition}"]`);
        if (bbContainer) {
          const badge = document.createElement('span');
          badge.className = 'position-badge bb';
          badge.textContent = 'BB';
          badge.title = 'Big Blind';
          bbContainer.appendChild(badge);
        }
      }
    }
    
    // ============================================
    // STEP 4C: UPDATE CARD BACKINGS ON SEATS
    // ============================================
    function updateSeatCardBackings(gameState, myHoleCards = null) {
      if (!gameState || !gameState.players) {
        debug('‚ö†Ô∏è No gameState or players for card backings');
        return;
      }
      
      debug('üÉè Updating seat card backings', { 
        players: gameState.players.length, 
        status: gameState.status,
        playerSeats: gameState.players.map(p => p.seatIndex),
        myHoleCards: myHoleCards
      });
      
      // Loop through all seats
      for (let i = 0; i < 9; i++) {
        const cardBacksContainer = document.querySelector(`.seat-cards[data-seat-index="${i}"]`);
        if (!cardBacksContainer) {
          debug(`‚ö†Ô∏è No card backs container found for seat ${i}`);
          continue;
        }
        
        // Find player in this seat
        const player = gameState.players.find(p => p.seatIndex === i);
        
        // Clear existing card backs
        cardBacksContainer.innerHTML = '';
        
        // Show card backs for IN_PROGRESS or COMPLETED (showdown)
        const shouldShowCards = player && (gameState.status === 'IN_PROGRESS' || gameState.status === 'COMPLETED');
        
        if (shouldShowCards) {
          const isMe = player.userId === userId;
          
          // If it's MY seat and I have hole cards, show actual cards
          if (isMe && myHoleCards && myHoleCards.length === 2) {
            debug(`‚úÖ Adding MY actual cards for seat ${i}`, { cards: myHoleCards });
            myHoleCards.forEach(card => {
              const cardImg = document.createElement('img');
              cardImg.className = 'seat-card-front';
              cardImg.src = getCardImagePath(card);
              cardImg.alt = card;
              cardImg.onerror = function() {
                this.src = '/cards/back.png';
              };
              cardBacksContainer.appendChild(cardImg);
            });
          } else {
            // Other players - show card backs
            debug(`‚úÖ Adding card backs for seat ${i} (folded: ${player.folded}, status: ${gameState.status})`);
            for (let j = 0; j < 2; j++) {
              const cardBack = document.createElement('img');
              cardBack.className = 'seat-card-back';
              cardBack.src = '/cards/back.png';
              cardBack.alt = 'Card';
              
              // Grey out if folded
              if (player.folded) {
                cardBack.classList.add('folded');
              }
              
              cardBacksContainer.appendChild(cardBack);
            }
          }
        } else {
          debug(`‚ùå Not showing cards for seat ${i} (hasPlayer: ${!!player}, status: ${gameState.status})`);
        }
      }
    }
    
    // ============================================
    // STEP 5: CLAIM SEAT
    // ============================================
    async function claimSeat(seatIndex) {
      // Prevent duplicate calls
      if (isClaimingSeat) {
        debug('‚è∏Ô∏è  Already claiming a seat, ignoring duplicate call');
        return;
      }
      
      isClaimingSeat = true;
      debug(`ü™ë Attempting to claim seat ${seatIndex}...`);
      
      // Prompt for nickname
      const nickname = prompt(
        'üéÆ Choose your nickname (3-15 characters):\n\n' +
        'Letters, numbers, and underscores only.\n' +
        'Leave blank for auto-generated name.',
        ''
      );
      
      // User cancelled
      if (nickname === null) {
        isClaimingSeat = false;
        return;
      }
      
      // Validate nickname if provided
      if (nickname && (nickname.length < 3 || nickname.length > 15)) {
        console.error('Nickname must be 3-15 characters');
        isClaimingSeat = false;
        return;
      }
      
      if (nickname && !/^[a-zA-Z0-9_]+$/.test(nickname)) {
        console.error('Nickname can only contain letters, numbers, and underscores');
        isClaimingSeat = false;
        return;
      }
      
      try {
        const response = await fetch(`/api/engine/claim-seat`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            roomId: roomId,
            userId: userId,
            seatIndex: seatIndex,
            nickname: nickname || undefined
          })
        });
        
        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || 'Failed to claim seat');
        }
        
        const data = await response.json();
        const displayName = data.seat.nickname || `Guest_${userId.substring(0, 6)}`;
        debug('‚úÖ Seat claimed successfully', { displayName, seatIndex });
        
        // Reload room state
        setTimeout(() => {
          loadRoom();
          isClaimingSeat = false; // Reset flag after reload
        }, 500);
        
      } catch (error) {
        debug('‚ùå Claim seat error', { error: error.message });
        console.error('Failed to claim seat:', error.message);
        isClaimingSeat = false; // Reset flag on error
      }
    }
    
    // ============================================
    // STEP 6: START HAND / NEXT HAND
    // ============================================
    async function startHand() {
      const btn = document.getElementById('startBtn');
      const isNextHand = btn.textContent.includes('NEXT');
      
      debug(isNextHand ? 'üé¨ Starting NEXT hand...' : 'üéÆ Starting FIRST hand...');
      
      try {
        // Clear UI before starting new hand
        myHoleCards = null; // Clear stored hole cards
        document.getElementById('communityCards').innerHTML = '';
        document.getElementById('myCards').innerHTML = '';
        document.getElementById('potAmount').textContent = '0';
        document.getElementById('currentBet').textContent = '0';
        document.getElementById('actionButtons').style.display = 'none';
        document.getElementById('handStrength').style.display = 'none';
        document.getElementById('myCardsSection').style.display = 'none';
        
        // Use correct endpoint
        const endpoint = isNextHand ? '/api/engine/next-hand' : '/api/engine/deal-cards';
        
        const response = await fetch(endpoint, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            roomId: roomId,
            userId: userId
          })
        });
        
        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || 'Failed to start hand');
        }
        
        const data = await response.json();
        debug('‚úÖ Hand started', data);
        
        // Store game state ID
        if (data.gameStateId) {
          gameId = data.gameStateId;
        }
        
        // Show game state immediately
        if (data.gameState) {
          const gs = data.gameState;
          
          document.getElementById('communitySection').style.display = 'block';
          document.getElementById('potAmount').textContent = gs.pot || 0;
          document.getElementById('currentBet').textContent = gs.currentBet || 0;
          
          const actorText = document.getElementById('currentActor');
          if (gs.currentActorSeat !== undefined) {
            actorText.textContent = `(Seat ${gs.currentActorSeat}'s turn)`;
            actorText.style.display = 'inline';
          }
          
          // Show hand number
          if (gs.handNumber) {
            debug(`üìä Hand #${gs.handNumber}`);
          }
          
          debug('‚úÖ Game state displayed', { pot: gs.pot, currentBet: gs.currentBet, handNumber: gs.handNumber });
        }
        
        // Show cards
        if (data.cards && data.cards.length === 2) {
          myHoleCards = data.cards; // Store globally
          renderMyCards(data.cards);
        }
        
        // Reset button text
        btn.textContent = 'üéÆ START HAND';
        btn.style.display = 'none';
        
        // Reload seats to show updated chips
        setTimeout(loadRoom, 500);
        
      } catch (error) {
        debug('‚ùå Start hand error', { error: error.message });
        alert('‚ùå Failed to start hand: ' + error.message);
      }
    }
    
    // ============================================
    // STEP 7: RENDER MY CARDS
    // ============================================
    async function renderMyCards(cards) {
      debug('üÉè Rendering hole cards', { cards });
      
      const section = document.getElementById('myCardsSection');
      const cardsDiv = document.getElementById('myCards');
      
      section.style.display = 'block';
      cardsDiv.innerHTML = '';
      
      cards.forEach(card => {
        const cardImg = document.createElement('img');
        cardImg.className = 'card card-img';
        cardImg.src = getCardImagePath(card);
        cardImg.alt = card;
        cardImg.onerror = function() {
          // Fallback if image doesn't exist
          this.src = '/cards/back.png';
        };
        cardsDiv.appendChild(cardImg);
      });
      
      // Show action buttons
      document.getElementById('actionButtons').style.display = 'flex';
      
      // Fetch game state and let updateActionButtons handle everything
      try {
        const gameStateResponse = await fetch(`/api/engine/game/${roomId}`);
        if (gameStateResponse.ok) {
          const gameData = await gameStateResponse.json();
          updateActionButtons(gameData);
          evaluateHandStrength(cards, gameData.communityCards || []);
        }
      } catch (error) {
        debug('‚ö†Ô∏è Could not fetch game state', error);
      }
      
      debug('‚úÖ Cards rendered');
    }
    
    // ============================================
    // STEP 7B: FETCH MY HOLE CARDS
    // ============================================
    async function fetchMyCards() {
      debug('üîí Fetching my hole cards...');
      
      try {
        const response = await fetch(`/api/engine/my-cards/${roomId}/${userId}`);
        
        if (!response.ok) {
          const error = await response.json();
          console.log('‚ö†Ô∏è Could not fetch cards:', error.error);
          return; // Not an error - might not be in this hand
        }
        
        const data = await response.json();
        debug('‚úÖ My cards fetched', data);
        
        if (data.cards && data.cards.length === 2) {
          myHoleCards = data.cards; // Store globally
          renderMyCards(data.cards);
        }
        
      } catch (error) {
        debug('‚ö†Ô∏è Fetch my cards error', { error: error.message });
      }
    }
    
    // ============================================
    // STEP 8: PERFORM ACTION (with debounce)
    // ============================================
    let actionInProgress = false;
    
    async function performAction(action, amount) {
      if (actionInProgress) {
        debug('‚ö†Ô∏è Action in progress, blocking double-click');
        return;
      }
      
      actionInProgress = true;
      debug(`üéÆ Performing action: ${action} $${amount}`);
      
      try {
        const response = await fetch('/api/engine/action', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            roomId: roomId,
            userId: userId,
            action: action,
            amount: amount
          })
        });
        
        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || 'Failed to perform action');
        }
        
        const data = await response.json();
        debug('‚úÖ Action performed', data);
        
        // UI will update via WebSocket broadcast automatically
        
      } catch (error) {
        debug('‚ùå Action error', { error: error.message });
        // Silently ignore "Hand is complete" errors - this is expected at showdown
        if (error.message.includes('Hand is complete')) {
          debug('‚ÑπÔ∏è Hand already complete - ignoring action');
          return;
        }
        // For other errors, just log them (no blocking alert)
        console.error('Action failed:', error.message);
      } finally {
        // Reset after 500ms
        setTimeout(() => {
          actionInProgress = false;
          debug('üîì Action debounce released');
        }, 500);
      }
    }
    
    // ============================================
    // STEP 8A: UPDATE ACTION BUTTONS (Single source of truth)
    // ============================================
    function updateActionButtons(gameState) {
      // Find my player
      const myPlayer = gameState.players?.find(p => p.userId === userId);
      if (!myPlayer) return;
      
      const currentBet = gameState.currentBet || 0;
      const myBet = myPlayer.bet || 0;
      const callAmount = currentBet - myBet;
      const isMyTurn = gameState.currentActorSeat === myPlayer.seatIndex;
      
      debug('üîÑ Updating buttons', { currentBet, myBet, callAmount, isMyTurn });
      
      const foldBtn = document.getElementById('foldBtn');
      const callBtn = document.getElementById('callBtn');
      const raiseBtn = document.getElementById('raiseBtn');
      const callBtnText = document.getElementById('callBtnText');
      const callAmountSpan = document.getElementById('callAmount');
      
      // SET ONCLICK HANDLERS ONCE
      if (callAmount === 0) {
        callBtnText.textContent = 'CHECK';
        callAmountSpan.style.display = 'none';
        callBtn.onclick = () => performAction('CHECK', 0);
      } else {
        callBtnText.textContent = 'CALL';
        callAmountSpan.style.display = 'inline';
        callAmountSpan.textContent = callAmount;
        callBtn.onclick = () => performAction('CALL', callAmount);
      }
      
      foldBtn.onclick = () => performAction('FOLD', 0);
      raiseBtn.onclick = () => openRaiseModal(currentBet, myPlayer.chips);
      
      // APPLY VISUAL STATE
      if (isMyTurn) {
        // YOUR TURN - active pulse
        foldBtn.classList.add('active');
        callBtn.classList.add('active');
        raiseBtn.classList.add('active');
        foldBtn.classList.remove('not-your-turn');
        callBtn.classList.remove('not-your-turn');
        raiseBtn.classList.remove('not-your-turn');
        foldBtn.disabled = false;
        callBtn.disabled = false;
        raiseBtn.disabled = false;
        debug('‚úÖ Your turn - buttons active with pulse');
      } else {
        // NOT YOUR TURN - blur
        foldBtn.classList.remove('active');
        callBtn.classList.remove('active');
        raiseBtn.classList.remove('active');
        foldBtn.classList.add('not-your-turn');
        callBtn.classList.add('not-your-turn');
        raiseBtn.classList.add('not-your-turn');
        foldBtn.disabled = true;
        callBtn.disabled = true;
        raiseBtn.disabled = true;
        debug('‚è∏Ô∏è Not your turn - buttons blurred');
      }
      
      // HIGHLIGHT CURRENT PLAYER SEAT
      document.querySelectorAll('.seat').forEach(seat => {
        seat.classList.remove('current-turn');
      });
      
      const currentSeat = document.querySelector(`.seat[data-seat-index="${gameState.currentActorSeat}"]`);
      if (currentSeat) {
        currentSeat.classList.add('current-turn');
        debug(`üí° Highlighted seat ${gameState.currentActorSeat}`);
      }
    }
    
    // ============================================
    // STEP 8B: HANDLE HAND COMPLETE
    // ============================================
    function handleHandComplete(gameState) {
      debug('üèÜ Hand complete', gameState);
      
      // Hide action buttons
      document.getElementById('actionButtons').style.display = 'none';
      document.getElementById('handStrength').style.display = 'none';
      
      if (gameState.winners && gameState.winners.length > 0) {
        const winner = gameState.winners[0];
        const potAmount = winner.amount;
        
        debug(`üèÜ Winner: Seat ${winner.seatIndex} wins $${potAmount}`);
        
        // 1. KEEP POT VISIBLE (don't zero it yet)
        document.getElementById('potAmount').textContent = potAmount;
        
        // 2. HIGHLIGHT WINNER'S SEAT
        highlightWinnerSeat(winner.seatIndex);
        
        // 3. SHOW WINNER BANNER
        const banner = document.getElementById('winnerBanner');
        const winnerPlayer = gameState.players.find(p => p.seatIndex === winner.seatIndex);
        const winnerNickname = winnerPlayer ? `@${winnerPlayer.nickname || 'Player'}` : `Seat ${winner.seatIndex}`;
        
        banner.innerHTML = `üèÜ ${winnerNickname} WINS $${potAmount.toLocaleString()}<br><small style="font-size:1.2rem;">${winner.handDescription}</small>`;
        banner.classList.add('show');
        
        // 4. SHOW/MUCK CONTROLS FOR NON-WINNERS
        // Keep controls visible for ENTIRE 5-second countdown
        const myPlayer = gameState.players?.find(p => p.userId === userId);
        const didIWin = myPlayer && myPlayer.seatIndex === winner.seatIndex;
        const didIFold = myPlayer && myPlayer.folded;
        
        debug('üÉè Show/muck check:', {
          hasMyPlayer: !!myPlayer,
          myUserId: userId,
          mySeatIndex: myPlayer?.seatIndex,
          winnerSeatIndex: winner.seatIndex,
          didIWin,
          didIFold
        });
        
        // Only show controls if: I didn't win, I didn't fold, and I'm in the hand
        if (myPlayer && !didIWin && !didIFold) {
          debug('üÉè Showing show/muck controls (you didn\'t win)');
          document.getElementById('showdownControls').classList.add('show');
        } else {
          debug('üÉè NOT showing controls', { myPlayer: !!myPlayer, didIWin, didIFold });
        }
        
        // 5. AFTER 3 SECONDS: Hide banner, transfer chips, START COUNTDOWN
        setTimeout(() => {
          // Hide banner only (keep show/muck controls visible)
          banner.classList.remove('show');
          
          // Clear winner highlight
          clearWinnerHighlight();
          
          // Update all seat chips (show final amounts)
          updateSeatChips(gameState.players);
          
          // Zero the pot (chips now in winner's stack)
          document.getElementById('potAmount').textContent = '0';
          
          // START COUNTDOWN FOR NEXT HAND
          const startBtn = document.getElementById('startBtn');
          startBtn.style.display = 'inline-block';
          startBtn.disabled = true;
          
          let countdown = 5;
          startBtn.textContent = `‚è∞ NEXT HAND (${countdown}s)`;
          
          const countdownInterval = setInterval(() => {
            countdown--;
            if (countdown > 0) {
              startBtn.textContent = `‚è∞ NEXT HAND (${countdown}s)`;
            } else {
              clearInterval(countdownInterval);
              
              // Hide show/muck controls when countdown finishes
              document.getElementById('showdownControls').classList.remove('show');
              
              if (isHost) {
                startBtn.textContent = '‚ñ∂Ô∏è STARTING...';
                debug('üé¨ Auto-starting next hand (HOST)...');
                startHand();
              } else {
                startBtn.textContent = '‚è≥ STARTING...';
                debug('‚è≥ Waiting for host to start next hand (GUEST)');
              }
            }
          }, 1000);
          
        }, 3000); // 3 second delay to show winner
      }
    }
    
    // ============================================
    // RAISE MODAL FUNCTIONS
    // ============================================
    let raiseModalData = {
      currentBet: 0,
      pot: 0,
      stack: 0,
      minRaise: 0,
      maxRaise: 0
    };
    
    function openRaiseModal(currentBet, playerStack) {
      const pot = parseInt(document.getElementById('potAmount').textContent.replace(/\$/g, '')) || 0;
      const minRaise = currentBet * 2 || 20;
      const maxRaise = playerStack;
      
      raiseModalData = {
        currentBet,
        pot,
        stack: playerStack,
        minRaise,
        maxRaise
      };
      
      // Update panel info
      document.getElementById('raiseModalPot').textContent = '$' + pot;
      document.getElementById('raiseModalStack').textContent = '$' + playerStack;
      document.getElementById('raiseModalMin').textContent = '$' + minRaise;
      
      // Setup slider
      const slider = document.getElementById('raiseSlider');
      slider.min = minRaise;
      slider.max = maxRaise;
      slider.value = minRaise;
      
      // Setup input
      const input = document.getElementById('raiseAmount');
      input.min = minRaise;
      input.max = maxRaise;
      input.value = minRaise;
      
      // Update display
      document.getElementById('raiseSliderValue').textContent = '$' + minRaise;
      
      // Show panel
      document.getElementById('raisePanel').style.display = 'block';
      
      // Wire up slider/input sync
      slider.oninput = function() {
        const value = parseInt(this.value);
        input.value = value;
        document.getElementById('raiseSliderValue').textContent = '$' + value;
      };
      
      input.oninput = function() {
        const value = parseInt(this.value) || minRaise;
        const clamped = Math.max(minRaise, Math.min(maxRaise, value));
        slider.value = clamped;
        document.getElementById('raiseSliderValue').textContent = '$' + clamped;
      };
    }
    
    function closeRaisePanel() {
      document.getElementById('raisePanel').style.display = 'none';
    }
    
    function setRaisePreset(preset) {
      const { pot, minRaise, maxRaise } = raiseModalData;
      let amount;
      
      switch(preset) {
        case 'quarter':
          amount = Math.floor(pot * 0.25);
          break;
        case 'half':
          amount = Math.floor(pot * 0.5);
          break;
        case 'threequarter':
          amount = Math.floor(pot * 0.75);
          break;
        case 'pot':
          amount = pot;
          break;
        case 'double':
          amount = pot * 2;
          break;
        case 'allin':
          amount = maxRaise;
          break;
        default:
          amount = minRaise;
      }
      
      // Clamp to valid range
      amount = Math.max(minRaise, Math.min(maxRaise, amount));
      
      // Update UI
      document.getElementById('raiseAmount').value = amount;
      document.getElementById('raiseSlider').value = amount;
      document.getElementById('raiseSliderValue').textContent = '$' + amount;
    }
    
    function submitRaise() {
      const amount = parseInt(document.getElementById('raiseAmount').value);
      const { minRaise, maxRaise } = raiseModalData;
      
      if (amount < minRaise) {
        alert(`Minimum raise is $${minRaise}`);
        return;
      }
      
      if (amount > maxRaise) {
        alert(`Maximum raise is $${maxRaise} (your stack)`);
        return;
      }
      
      closeRaisePanel();
      performAction('RAISE', amount);
    }
    
    // Helper: Highlight winner's seat
    function highlightWinnerSeat(seatIndex) {
      const seatsDiv = document.getElementById('seats');
      const seatDivs = seatsDiv.querySelectorAll('.seat');
      
      seatDivs.forEach(seatDiv => {
        const label = seatDiv.querySelector('.seat-label');
        if (label && label.textContent === `Seat ${seatIndex}`) {
          seatDiv.classList.add('winner');
        }
      });
    }
    
    // Helper: Clear winner highlight
    function clearWinnerHighlight() {
      const seatsDiv = document.getElementById('seats');
      const seatDivs = seatsDiv.querySelectorAll('.seat.winner');
      seatDivs.forEach(seatDiv => {
        seatDiv.classList.remove('winner');
      });
    }
    
    // ============================================
    // SHOW/MUCK FUNCTIONALITY
    // ============================================
    async function showCards() {
      debug('üÉè Player chose to SHOW cards');
      
      try {
        const response = await fetch('/api/engine/showdown-action', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            roomId: roomId,
            userId: userId,
            action: 'SHOW'
          })
        });
        
        if (!response.ok) {
          const error = await response.json();
          console.error('‚ùå Show cards error:', error);
          debug('‚ùå Show cards failed', error);
          return;
        }
        
        const result = await response.json();
        debug('‚úÖ Cards shown to table', result);
        
        // Hide controls
        document.getElementById('showdownControls').classList.remove('show');
        
        // NO NEED to manually display - WebSocket will handle it for all players
        
      } catch (error) {
        console.error('‚ùå Show cards network error:', error);
        debug('‚ùå Show cards network error', { error: error.message });
      }
    }
    
    async function muckCards() {
      debug('üóëÔ∏è Player chose to MUCK cards');
      
      try {
        const response = await fetch('/api/engine/showdown-action', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            roomId: roomId,
            userId: userId,
            action: 'MUCK'
          })
        });
        
        if (!response.ok) {
          const error = await response.json();
          console.error('‚ùå Muck cards error:', error);
          debug('‚ùå Muck cards failed', error);
          return;
        }
        
        const result = await response.json();
        debug('‚úÖ Cards mucked', result);
        
        // Hide controls
        document.getElementById('showdownControls').classList.remove('show');
        
      } catch (error) {
        console.error('‚ùå Muck cards network error:', error);
        debug('‚ùå Muck cards network error', { error: error.message });
      }
    }
    
    // ============================================
    // STEP 8C: RENDER COMMUNITY CARDS
    // ============================================
    // Track previous community cards to avoid re-animating
    let previousCommunityCards = [];

    function renderCommunityCards(cards) {
      debug('üÉè Rendering community cards', { cards });
      
      const communityDiv = document.getElementById('communityCards');
      
      // Determine which cards are NEW (not in previous render)
      const newCards = cards.filter(card => !previousCommunityCards.includes(card));
      
      // Only clear and re-render if cards actually changed
      if (newCards.length > 0 || cards.length < previousCommunityCards.length) {
      communityDiv.innerHTML = '';
      
      cards.forEach(card => {
        const cardImg = document.createElement('img');
        cardImg.className = 'card-img';
          
          // Only add 'new-card' class if this card wasn't in previous render
          if (newCards.includes(card)) {
            cardImg.classList.add('new-card');
          }
          
        cardImg.src = getCardImagePath(card);
        cardImg.alt = card;
        cardImg.onerror = function() {
          this.src = '/cards/back.png';
        };
        communityDiv.appendChild(cardImg);
      });
        
        // Update tracking
        previousCommunityCards = [...cards];
      }
      
      document.getElementById('communitySection').style.display = 'block';
      
      // Re-evaluate hand strength when community cards change
      const myCardsDiv = document.getElementById('myCards');
      if (myCardsDiv && myCardsDiv.dataset.cards) {
        const myCards = JSON.parse(myCardsDiv.dataset.cards);
        evaluateHandStrength(myCards, cards);
      }
    }
    
    // ============================================
    // STEP 8D: EVALUATE AND DISPLAY HAND STRENGTH
    // ============================================
    function evaluateHandStrength(holeCards, communityCards) {
      // Store cards for re-evaluation
      const myCardsDiv = document.getElementById('myCards');
      myCardsDiv.dataset.cards = JSON.stringify(holeCards);
      
      if (!holeCards || holeCards.length !== 2) return;
      if (!communityCards) communityCards = [];
      
      const allCards = [...holeCards, ...communityCards];
      
      // Simple hand evaluation (client-side approximation)
      const handDescription = getSimpleHandDescription(allCards);
      
      // Display
      const strengthDiv = document.getElementById('handStrength');
      const textDiv = document.getElementById('handStrengthText');
      
      if (handDescription) {
        textDiv.textContent = handDescription;
        strengthDiv.style.display = 'block';
        debug('üé¥ Hand strength:', handDescription);
      }
    }
    
    /**
     * Simple client-side hand evaluation
     * Returns description like "Pair of AA", "Two Pair - QQ33"
     */
    function getSimpleHandDescription(cards) {
      if (cards.length < 2) return 'Incomplete Hand';
      
      // Parse ranks
      const rankMap = { '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, 'T': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14 };
      const rankCharMap = { 2: '2', 3: '3', 4: '4', 5: '5', 6: '6', 7: '7', 8: '8', 9: '9', 10: 'T', 11: 'J', 12: 'Q', 13: 'K', 14: 'A' };
      
      const ranks = cards.map(card => rankMap[card[0]]);
      const suits = cards.map(card => card[1]);
      
      // Count frequencies
      const rankCounts = {};
      ranks.forEach(r => rankCounts[r] = (rankCounts[r] || 0) + 1);
      
      const pairs = [];
      const trips = [];
      const quads = [];
      
      for (const [rank, count] of Object.entries(rankCounts)) {
        if (count === 4) quads.push(parseInt(rank));
        if (count === 3) trips.push(parseInt(rank));
        if (count === 2) pairs.push(parseInt(rank));
      }
      
      // Sort descending
      pairs.sort((a, b) => b - a);
      trips.sort((a, b) => b - a);
      quads.sort((a, b) => b - a);
      
      // Check flush
      const suitCounts = {};
      suits.forEach(s => suitCounts[s] = (suitCounts[s] || 0) + 1);
      const isFlush = Object.values(suitCounts).some(c => c >= 5);
      
      // Check straight (simplified)
      const uniqueRanks = [...new Set(ranks)].sort((a, b) => b - a);
      let isStraight = false;
      if (uniqueRanks.length >= 5) {
        for (let i = 0; i <= uniqueRanks.length - 5; i++) {
          if (uniqueRanks[i] - uniqueRanks[i + 4] === 4) {
            isStraight = true;
            break;
          }
        }
      }
      
      // Determine hand
      if (quads.length > 0) {
        return `Four of a Kind (${rankCharMap[quads[0]]}s)`;
      }
      if (trips.length > 0 && pairs.length > 0) {
        return `Full House (${rankCharMap[trips[0]]}${rankCharMap[trips[0]]}${rankCharMap[trips[0]]} over ${rankCharMap[pairs[0]]}${rankCharMap[pairs[0]]})`;
      }
      if (isFlush) {
        return 'Flush';
      }
      if (isStraight) {
        return 'Straight';
      }
      if (trips.length > 0) {
        return `Three of a Kind (${rankCharMap[trips[0]]}s)`;
      }
      if (pairs.length >= 2) {
        return `Two Pair (${rankCharMap[pairs[0]]}${rankCharMap[pairs[0]]} ${rankCharMap[pairs[1]]}${rankCharMap[pairs[1]]})`;
      }
      if (pairs.length === 1) {
        return `Pair (${rankCharMap[pairs[0]]}${rankCharMap[pairs[0]]})`;
      }
      
      // High card
      const highCard = Math.max(...ranks);
      return `High Card (${rankCharMap[highCard]})`;
    }
    
    // ============================================
    // STEP 9: RENDER COMMUNITY CARDS + POT
    // ============================================
    function renderCommunity(communityCards, pot, currentBet) {
      if (!communityCards || communityCards.length === 0) {
        document.getElementById('communitySection').style.display = 'none';
        return;
      }
      
      debug('üé¥ Rendering community cards', { communityCards, pot, currentBet });
      
      const section = document.getElementById('communitySection');
      const cardsDiv = document.getElementById('communityCards');
      
      section.style.display = 'block';
      cardsDiv.innerHTML = '';
      
      communityCards.forEach(card => {
        const cardDiv = document.createElement('div');
        cardDiv.className = 'card';
        cardDiv.style.backgroundImage = `url('/cards/${card}.png')`;
        cardsDiv.appendChild(cardDiv);
      });
      
      document.getElementById('potAmount').textContent = pot || 0;
      document.getElementById('currentBet').textContent = currentBet || 0;
      
      debug('‚úÖ Community cards rendered');
    }
    
    // ============================================
    // STEP 10: UPDATE TURN INDICATOR
    // ============================================
    function updateTurnIndicator(currentActorSeat) {
      const indicator = document.getElementById('turnIndicator');
      const actorText = document.getElementById('currentActor');
      
      if (currentActorSeat === null || currentActorSeat === undefined) {
        indicator.style.display = 'none';
        actorText.textContent = '';
        return;
      }
      
      // Check if it's our turn
      // (This is simplified - need to map userId to seat)
      actorText.textContent = `(Waiting for Seat ${currentActorSeat})`;
      
      // TODO: Properly detect if current actor is us
      // indicator.style.display = 'inline';
    }
    
    // ============================================
    // üéõÔ∏è HOST CONTROLS FUNCTIONS
    // ============================================
    function toggleHostControls() {
      const content = document.getElementById('hostControlsContent');
      const icon = document.getElementById('hostToggleIcon');
      content.classList.toggle('expanded');
      icon.classList.toggle('expanded');
    }
    
    function togglePlayerSettings() {
      const content = document.getElementById('playerSettingsContent');
      const icon = document.getElementById('playerSettingsToggle');
      content.classList.toggle('expanded');
      icon.classList.toggle('expanded');
    }
    
    async function loadHostControls() {
      if (!isHost) {
        document.getElementById('hostControlsPanel').style.display = 'none';
        // Show player settings for non-hosts
        document.getElementById('playerSettingsPanel').style.display = 'block';
        return;
      }
      
      debug('üéõÔ∏è Loading host controls...');
      document.getElementById('hostControlsPanel').style.display = 'block';
      document.getElementById('playerSettingsPanel').style.display = 'none';
      
      try {
        const response = await fetch(`/api/engine/host-controls/${roomId}/${userId}`);
        if (!response.ok) {
          console.error('Failed to load host controls');
          return;
        }
        
        const data = await response.json();
        debug('‚úÖ Host controls loaded', data);
        
        // Update blinds inputs
        document.getElementById('hostSmallBlindInput').value = data.room.smallBlind;
        document.getElementById('hostBigBlindInput').value = data.room.bigBlind;
        
        // Render players
        renderHostPlayerList(data.players);
        
        // Update chip adjustment dropdown
        updateChipAdjustmentDropdown(data.players);
        
      } catch (error) {
        console.error('Error loading host controls:', error);
      }
    }
    
    function renderHostPlayerList(players) {
      const container = document.getElementById('hostPlayerList');
      const countEl = document.getElementById('hostPlayerCount');
      
      countEl.textContent = players.length;
      
      if (players.length === 0) {
        container.innerHTML = '<div class="empty-state">No players seated</div>';
        return;
      }
      
      container.innerHTML = players.map(player => `
        <div class="player-item">
          <div class="player-item-info">
            <div class="player-item-name">
              @${player.nickname}
              ${player.userId === userId ? ' (YOU)' : ''}
            </div>
            <div class="player-item-details">
              <span>Seat ${player.seatIndex}</span>
              <span class="player-item-chips">$${player.chips}</span>
            </div>
          </div>
          ${player.userId !== userId ? `
            <button class="host-btn kick" onclick="kickPlayer('${player.userId}')">
              üö´ KICK
            </button>
          ` : ''}
        </div>
      `).join('');
    }
    
    async function kickPlayer(targetUserId) {
      if (!confirm('Are you sure you want to kick this player? They will be removed from their seat.')) {
        return;
      }
      
      debug('üö´ Kicking player:', targetUserId);
      
      try {
        const response = await fetch('/api/engine/host-controls/kick-player', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            roomId,
            hostId: userId,
            targetUserId
          })
        });
        
        if (!response.ok) {
          const error = await response.json();
          alert(`Failed to kick player: ${error.error}`);
          return;
        }
        
        debug('‚úÖ Player kicked');
        loadHostControls(); // Refresh panel
        loadRoom(); // Refresh seats
        
      } catch (error) {
        console.error('Error kicking player:', error);
        alert('Failed to kick player');
      }
    }
    
    async function updateBlinds() {
      const smallBlind = parseInt(document.getElementById('hostSmallBlindInput').value);
      const bigBlind = parseInt(document.getElementById('hostBigBlindInput').value);
      
      if (bigBlind <= smallBlind) {
        alert('Big blind must be greater than small blind!');
        return;
      }
      
      if (smallBlind < 1 || bigBlind < 2) {
        alert('Blinds must be positive integers!');
        return;
      }
      
      debug('üí∞ Updating blinds:', { smallBlind, bigBlind });
      
      try {
        const response = await fetch('/api/engine/host-controls/update-blinds', {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            roomId,
            hostId: userId,
            smallBlind,
            bigBlind
          })
        });
        
        if (!response.ok) {
          const error = await response.json();
          alert(`Failed to update blinds: ${error.error}`);
          return;
        }
        
        const result = await response.json();
        debug('‚úÖ Blinds updated', result);
        
        if (result.applied === 'queued') {
          alert(`‚è≥ Blinds queued: $${smallBlind}/$${bigBlind}\n\nWill apply after current hand ends.`);
        } else {
          alert(`‚úÖ Blinds updated to $${smallBlind}/$${bigBlind}`);
        }
        
      } catch (error) {
        console.error('Error updating blinds:', error);
        alert('Failed to update blinds');
      }
    }
    
    // ============================================
    // HOST: CHIP ADJUSTMENT
    // ============================================
    function updateChipAdjustmentDropdown(players) {
      const chipAdjustSeat = document.getElementById('chipAdjustSeat');
      if (!chipAdjustSeat) return;
      
      if (players.length === 0) {
        chipAdjustSeat.innerHTML = '<option value="">No players seated</option>';
        return;
      }
      
      chipAdjustSeat.innerHTML = '<option value="">Select a player...</option>' + 
        players.map(player => `
          <option value="${player.seatIndex}">
            Seat ${player.seatIndex}: @${player.nickname} ($${player.chips.toLocaleString()})
          </option>
        `).join('');
    }
    
    async function adjustPlayerChips() {
      const seatSelect = document.getElementById('chipAdjustSeat');
      const amountInput = document.getElementById('chipAdjustAmount');
      
      const seatIndex = parseInt(seatSelect.value);
      const newAmount = parseInt(amountInput.value);
      
      // Validation
      if (isNaN(seatIndex) || seatIndex === '') {
        alert('‚ùå Please select a player!');
        return;
      }
      
      if (isNaN(newAmount) || newAmount < 0) {
        alert('‚ùå Please enter a valid amount (minimum $0)!');
        return;
      }
      
      const playerName = seatSelect.options[seatSelect.selectedIndex].text;
      const confirmed = confirm(`üí∞ Adjust ${playerName}'s chips to $${newAmount.toLocaleString()}?`);
      
      if (!confirmed) return;
      
      debug('üíµ Adjusting chips:', { seatIndex, newAmount });
      
      try {
        const response = await fetch('/api/engine/host-controls/adjust-chips', {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            roomId,
            hostId: userId,
            seatIndex,
            newAmount
          })
        });
        
        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || 'Failed to adjust chips');
        }
        
        const result = await response.json();
        
        if (result.queued) {
          debug('‚è≥ Chips queued for next hand');
          alert(`‚è≥ ${playerName}'s chips will update to $${newAmount.toLocaleString()} at the end of this hand`);
        } else {
          debug('‚úÖ Chips adjusted');
          alert(`‚úÖ ${playerName}'s chips updated to $${newAmount.toLocaleString()}`);
        }
        
        // Refresh to show updated chips
        loadRoom();
        loadHostControls();
        
      } catch (error) {
        console.error('Error adjusting chips:', error);
        alert(`‚ùå Failed: ${error.message}`);
      }
    }
    
    // ============================================
    // HOST CONTROL ENHANCEMENTS
    // ============================================
    
    let gamePaused = false;
    let actionTimerSeconds = 0;
    let roomLocked = false;
    
    // Toggle Room Lock
    async function toggleRoomLock() {
      roomLocked = !roomLocked;
      const btn = document.getElementById('lockBtnText');
      
      try {
        const response = await fetch('/api/engine/host-controls/room-lock', {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            roomId, 
            hostId: userId, 
            locked: roomLocked 
          })
        });
        
        if (!response.ok) throw new Error('Failed to toggle room lock');
        
        if (roomLocked) {
          btn.textContent = 'UNLOCK ROOM';
          alert('üîí Room locked. No new players can join.');
        } else {
          btn.textContent = 'LOCK ROOM';
          alert('üîì Room unlocked. Players can join again.');
        }
        
        debug('üîí Room lock toggled:', roomLocked);
        
      } catch (error) {
        console.error('Error toggling room lock:', error);
        alert('‚ùå Failed to toggle room lock.');
        roomLocked = !roomLocked; // Revert
      }
    }
    
    // Open Kick Player Modal (simplified - just shows list in existing UI)
    function openKickPlayerModal() {
      alert('üí° Use the KICK buttons next to each player in the Current Players section below');
      // Scroll to player list
      document.getElementById('hostPlayerList')?.scrollIntoView({ behavior: 'smooth' });
    }
    
    // Toggle Pause Game
    async function togglePauseGame() {
      const btn = document.getElementById('pauseGameBtn');
      gamePaused = !gamePaused;
      
      if (gamePaused) {
        btn.querySelector('.btn-text').textContent = 'RESUME GAME';
        btn.classList.add('paused');
        alert('‚è∏Ô∏è Game paused. Players cannot take actions.');
      } else {
        btn.querySelector('.btn-text').textContent = 'PAUSE GAME';
        btn.classList.remove('paused');
        alert('‚ñ∂Ô∏è Game resumed. Players can continue.');
      }
      
      // TODO: Implement backend pause/resume logic
      // Will need to broadcast pause state to all players via socket
      debug('‚è∏Ô∏è Game pause toggled:', gamePaused);
    }
    
    // Force Next Hand
    async function forceNextHand() {
      const confirmed = confirm('‚è≠Ô∏è Skip to next hand?\n\nThis will end the current hand immediately and move to the next one.\n\nContinue?');
      if (!confirmed) return;
      
      try {
        const response = await fetch('/api/engine/host-controls/force-next-hand', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ roomId, hostId: userId })
        });
        
        if (!response.ok) throw new Error('Failed to force next hand');
        
        alert('‚è≠Ô∏è Moving to next hand...');
        loadRoom();
        
      } catch (error) {
        console.error('Error forcing next hand:', error);
        alert('‚ùå Failed to skip hand. Ensure game is in progress.');
      }
    }
    
    // Set Action Timer
    function setActionTimer(seconds) {
      actionTimerSeconds = seconds;
      
      // Update display
      const display = document.getElementById('actionTimerDisplay');
      display.textContent = seconds === 0 ? 'OFF' : `${seconds}s`;
      
      // Update button states
      document.querySelectorAll('.timer-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      event.target.classList.add('active');
      
      // Save to localStorage
      localStorage.setItem('pokergeek_action_timer', seconds);
      
      debug('‚è±Ô∏è Action timer set to:', seconds === 0 ? 'OFF' : `${seconds}s`);
      
      // TODO: Implement backend timer logic
      // Will need to track time per player action and auto-fold on timeout
    }
    
    // Toggle Auto-Start
    function toggleAutoStart() {
      const checkbox = document.getElementById('autoStartToggle');
      const autoStart = checkbox.checked;
      
      localStorage.setItem('pokergeek_auto_start', autoStart);
      
      if (autoStart) {
        debug('üîÑ Auto-start enabled');
      } else {
        debug('‚èπÔ∏è Auto-start disabled');
      }
    }
    
    // Toggle Spectator Mode
    function toggleSpectatorMode() {
      const checkbox = document.getElementById('spectatorToggle');
      const enabled = checkbox.checked;
      
      localStorage.setItem('pokergeek_spectator_mode', enabled);
      
      if (enabled) {
        debug('üëÅÔ∏è Spectator mode enabled');
      } else {
        debug('üö´ Spectator mode disabled');
      }
    }
    
    // Reset All Stacks
    async function resetAllStacks() {
      const confirmed = confirm('üîÑ RESET ALL STACKS?\n\nThis will:\n- Set all players back to starting chips\n- Keep players seated\n- Not affect current hand\n\nContinue?');
      if (!confirmed) return;
      
      try {
        const response = await fetch('/api/engine/host-controls/reset-stacks', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ roomId, hostId: userId })
        });
        
        if (!response.ok) throw new Error('Failed to reset stacks');
        
        alert('üîÑ All player stacks reset to starting amount!');
        loadRoom();
        loadHostControls();
        
      } catch (error) {
        console.error('Error resetting stacks:', error);
        alert('‚ùå Failed to reset stacks.');
      }
    }
    
    // End Game
    async function endGame() {
      const confirmed = confirm('üõë END GAME?\n\nThis will:\n- End current game immediately\n- Clear all player seats\n- Return to lobby\n\nThis CANNOT be undone.\n\nContinue?');
      if (!confirmed) return;
      
      const doubleCheck = confirm('‚ö†Ô∏è Are you ABSOLUTELY sure?\n\nAll game progress will be lost.');
      if (!doubleCheck) return;
      
      try {
        const response = await fetch('/api/engine/host-controls/end-game', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ roomId, hostId: userId })
        });
        
        if (!response.ok) throw new Error('Failed to end game');
        
        alert('üõë Game ended. Returning to lobby...');
        window.location.href = '/';
        
      } catch (error) {
        console.error('Error ending game:', error);
        alert('‚ùå Failed to end game.');
      }
    }
    
    // ============================================
    // TABLE COLOR (All Players)
    // ============================================
    function changeFeltColor(color) {
      document.body.setAttribute('data-felt', color);
      localStorage.setItem('pokergeek_felt_color', color);
      
      // Update active button
      document.querySelectorAll('.color-btn').forEach(btn => {
        btn.classList.remove('active');
        if (btn.dataset.color === color) {
          btn.classList.add('active');
        }
      });
      
      debug('üé® Felt color changed:', color);
    }
    
    // 4-Color Deck Toggle
    function toggleFourColorDeck(enabled) {
      localStorage.setItem('pokergeek_four_color', enabled);
      debug('üÉè 4-Color Deck:', enabled);
      // Implementation will be added when designs are ready
    }
    
    // Card Back Design
    function changeCardBack(design) {
      localStorage.setItem('pokergeek_card_back', design);
      debug('üé¥ Card back changed:', design);
      // Implementation will be added when designs are ready
    }
    
    // Animation Speed
    function changeAnimSpeed(speed) {
      const speeds = { fast: 200, normal: 400, slow: 600 };
      document.documentElement.style.setProperty('--anim-speed', speeds[speed] + 'ms');
      localStorage.setItem('pokergeek_anim_speed', speed);
      debug('‚ö° Animation speed:', speed);
    }
    
    // Auto-Muck Toggle
    function toggleAutoMuck(enabled) {
      localStorage.setItem('pokergeek_auto_muck', enabled);
      debug('üôà Auto-muck:', enabled);
    }
    
    // Chip Display Format
    function changeChipFormat(format) {
      localStorage.setItem('pokergeek_chip_format', format);
      debug('üí∞ Chip format:', format);
      // Refresh chip displays on seats
      const gameState = currentGameState;
      if (gameState && gameState.players) {
        updateSeatChips(gameState.players);
      }
    }
    
    // Action Confirmation Toggle
    function toggleActionConfirm(enabled) {
      localStorage.setItem('pokergeek_action_confirm', enabled);
      debug('‚ö†Ô∏è Action confirmation:', enabled);
    }
    
    // Hotkeys Toggle
    let hotkeysEnabled = false;
    function toggleHotkeys(enabled) {
      hotkeysEnabled = enabled;
      localStorage.setItem('pokergeek_hotkeys', enabled);
      debug('‚å®Ô∏è Hotkeys:', enabled);
      
      if (enabled) {
        document.addEventListener('keydown', handleHotkey);
      } else {
        document.removeEventListener('keydown', handleHotkey);
      }
    }
    
    // Hotkey Handler
    function handleHotkey(e) {
      if (!hotkeysEnabled) return;
      
      // Don't trigger if typing in input
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
      
      const key = e.key.toLowerCase();
      const foldBtn = document.getElementById('foldBtn');
      const callBtn = document.getElementById('callBtn');
      const raiseBtn = document.getElementById('raiseBtn');
      
      if (key === 'f' && foldBtn && !foldBtn.disabled) {
        e.preventDefault();
        foldBtn.click();
      } else if (key === 'c' && callBtn && !callBtn.disabled) {
        e.preventDefault();
        callBtn.click();
      } else if (key === 'r' && raiseBtn && !raiseBtn.disabled) {
        e.preventDefault();
        raiseBtn.click();
      }
    }
    
    // Load all saved settings on page load
    (function loadSavedFeltColor() {
      const savedColor = localStorage.getItem('pokergeek_felt_color') || 'green';
      document.body.setAttribute('data-felt', savedColor);
      
      // Set active button (wait for DOM to be ready)
      setTimeout(() => {
        const activeBtn = document.querySelector(`.color-btn[data-color="${savedColor}"]`);
        if (activeBtn) activeBtn.classList.add('active');
      }, 100);
      
      debug('üé® Loaded saved felt color:', savedColor);
    })();
    
    // ============================================
    // CIRCULAR SEAT POSITIONING (Proper Ellipse)
    // ============================================
    function calculateSeatPositions() {
      // üîí LOCKED POSITIONS - Final layout optimized for 1600√ó1200 table
      // Uniform 200√ó200px seats, perfectly balanced ellipse
      return [
        { index: 0, x: 805, y: 160, width: 200, height: 200 },   // Bottom center (YOU)
        { index: 1, x: 1115, y: 230, width: 200, height: 200 },  // Bottom right
        { index: 2, x: 1355, y: 410, width: 200, height: 200 },  // Right mid-upper
        { index: 3, x: 1355, y: 730, width: 200, height: 200 },  // Right mid-lower
        { index: 4, x: 1115, y: 970, width: 200, height: 200 },  // Bottom right lower
        { index: 5, x: 805, y: 1040, width: 200, height: 200 },  // Bottom center-lower
        { index: 6, x: 495, y: 970, width: 200, height: 200 },   // Bottom left lower
        { index: 7, x: 255, y: 730, width: 200, height: 200 },   // Left mid-lower
        { index: 8, x: 255, y: 410, width: 200, height: 200 },   // Left mid-upper
        { index: 9, x: 495, y: 230, width: 200, height: 200 }    // Bottom left
      ];
    }
    
    const SEAT_POSITIONS = calculateSeatPositions();

    function applySeatPositions() {
      SEAT_POSITIONS.forEach(pos => {
        const seat = document.querySelector(`.seat[data-seat-index="${pos.index}"]`);
        if (seat) {
          seat.style.left = `${pos.x}px`;
          seat.style.top = `${pos.y}px`;
          if (pos.width) seat.style.width = `${pos.width}px`;
          if (pos.height) seat.style.height = `${pos.height}px`;
        }
      });
      debug('üìç Applied custom seat positions with sizes');
    }
    
    // ============================================
    // ZOOM LOCK SYSTEM
    // ============================================
    function setupZoomLock() {
      const wrapper = document.getElementById('tableWrapper');
      const table = document.getElementById('pokerTable');
      
      if (!wrapper || !table) {
        console.warn('‚ö†Ô∏è Zoom lock elements not found');
        return;
      }

      const updateScale = () => {
        const containerWidth = wrapper.clientWidth;
        const containerHeight = wrapper.clientHeight;
        const stageWidth = 1600;
        const stageHeight = 1200;

        const scaleX = containerWidth / stageWidth;
        const scaleY = containerHeight / stageHeight;
        const scale = Math.min(scaleX, scaleY);

        const scaledWidth = stageWidth * scale;
        const scaledHeight = stageHeight * scale;
        const offsetX = (containerWidth - scaledWidth) / 2;
        const offsetY = (containerHeight - scaledHeight) / 2;

        table.style.left = `${offsetX}px`;
        table.style.top = `${offsetY}px`;
        table.style.transform = `scale(${scale})`;
        
        debug('üîç Zoom lock updated', { scale, offsetX, offsetY });
      };

      updateScale();
      window.addEventListener('resize', updateScale);
      new ResizeObserver(updateScale).observe(wrapper);
      
      debug('‚úÖ Zoom lock initialized');
    }
    
    // ============================================
    // INITIALIZE ON LOAD
    // ============================================
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        init();
        setupZoomLock();
      });
    } else {
      init();
      setupZoomLock();
    }
  </script>
</body>
</html>

