<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>PokerGeek.ai — Poker Table (Zoom-Locked)</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">

<style>
/* ===== POKER TABLE GRID - ZOOM LOCKED VERSION ===== */

/* Design Tokens */
:root{
  --bg: #0b0b12;
  --text: #e9eef7;
  --muted: #9aa3b2;
  --accent: #ff5100;
  --teal: #00d4aa;
  --error: #ff3b3b;
  --felt-current: #197a45;
  --font-main: "Inter", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  --font-mono: "JetBrains Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  --nav-h: 64px;
  --shadow-md: 0 8px 18px rgba(0,0,0,.35);
  --shadow-lg: 0 12px 28px rgba(0,0,0,.45);
  --shadow-xl: 0 18px 44px rgba(0,0,0,.55);
}

/* Felt color presets */
body[data-felt="green"] { --felt-current: #197a45; }
body[data-felt="red"] { --felt-current: #6b1414; }
body[data-felt="black"] { --felt-current: #1a1a1a; }
body[data-felt="blue"] { --felt-current: #0f2942; }
body[data-felt="grey"] { --felt-current: #2a2a2a; }
body[data-felt="tan"] { --felt-current: #6b5642; }
body[data-felt="purple"] { --felt-current: #3a1450; }

/* Basic reset */
*{
  box-sizing:border-box;
  margin:0;
  padding:0;
}

html,body{
  height:100%;
  background:var(--bg);
  color:var(--text);
  font-family:var(--font-main);
}

/* === NAVBAR === */
.navbar{
  position:sticky;
  top:0;
  z-index:100;
  background:rgba(10,10,16,.9);
  backdrop-filter:saturate(120%) blur(12px);
  border-bottom:1px solid rgba(255,255,255,.06);
}

.navbar-inner{
  height:var(--nav-h);
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:16px;
  padding-inline: clamp(16px, 3vw, 32px);
}

.navbar-brand{
  color:#fff;
  font-weight:800;
  text-decoration:none;
  letter-spacing:.4px;
}

.navbar-brand .dot{
  color:var(--accent);
}

.navbar-links{
  display:flex;
  gap:16px;
  list-style:none;
}

.navbar-links a{
  color:var(--muted);
  text-decoration:none;
  font-weight:600;
  font-size:.95rem;
}

.navbar-links a:hover{
  color:#fff;
}

.navbar-auth .navbar-btn{
  margin-left:8px;
  padding:.5rem .85rem;
  border-radius:10px;
  border:1px solid rgba(255,255,255,.08);
  color:#fff;
  text-decoration:none;
  transition: all 0.2s;
  background: transparent;
  cursor: pointer;
}

.navbar-auth .navbar-btn:hover{
  background:rgba(255,255,255,.08);
}

.navbar-auth .signup{
  background:var(--accent);
  border-color:transparent;
}

.navbar-auth .host-btn{
  background: linear-gradient(135deg, var(--accent) 0%, #ff7722 100%);
  border: none;
  font-weight: 700;
}

/* === PAGE LAYOUT === */
.poker-game{
  display:grid;
  grid-template-rows: 1fr auto;
  min-height: calc(100vh - var(--nav-h));
  background: var(--bg);
  gap: clamp(12px, 2vw, 24px);
}

/* === LETTERBOX CONTAINER === */
.table-wrapper{
  min-height:0;
  display:flex;
  align-items:center;
  justify-content:center;
  background: var(--bg); /* Letterbox/pillarbox background */
  position: relative;
  overflow: hidden;
}

/* === ZOOM-LOCKED VIRTUAL STAGE === */
.poker-table{
  position: absolute;
  /* Fixed virtual dimensions - NO responsive units! */
  width: 1680px;
  height: 800px;
  /* Scale will be applied via transform by JS */
  transform-origin: top left;
  pointer-events: auto;
}

/* Vertical mode preset */
.poker-table.vertical-mode {
  width: 600px;
  height: 1200px;
}

/* Shared reference box for both seats and board */
.table-inner{
  position:absolute;
  inset: 24px;
}

/* === FELT === */
.table-felt{
  position:absolute;
  inset:0;
  border-radius: 360px; /* Fixed pixel radius */
  border: 2px solid #0d1117;
  background: var(--felt-current);
  box-shadow: inset 0 0 0 16px rgba(0,0,0,.35), inset 0 0 80px rgba(0,0,0,.45);
}

.table-felt::after{
  content:"";
  position:absolute;
  inset: -24px;
  border-radius:inherit;
  box-shadow: 0 16px 56px rgba(0,0,0,.55);
  pointer-events:none;
}

/* Vertical mode felt shape */
.vertical-mode .table-felt {
  border-radius: 180px;
}

/* === SEATS === */
.seats-layer{
  position:absolute;
  inset:0;
}

.seat{
  position:absolute;
  transform: translate(-50%,-50%);
  display:flex;
  align-items:center;
  justify-content:center;
  /* Positions will be set via inline styles by JS */
}

/* Seat content card */
.seat-content{
  width: 130px; /* Fixed pixels */
  padding: 12px;
  border-radius: 12px;
  position: relative;
  isolation: isolate;
  border: 1px solid rgba(255,255,255,.15);
  box-shadow: inset 0 0 18px -5px rgba(255, 255, 255, 0.15), 0 8px 18px rgba(0, 0, 0, 0.4);
  backdrop-filter: blur(20px) saturate(120%);
  background: rgba(255, 255, 255, 0.03);
}

/* Main player (larger) */
.seat-main .seat-content{
  width: 260px;
  padding: 16px;
  border-color: var(--teal);
  border-width: 2px;
  box-shadow: inset 0 0 24px -6px rgba(0, 212, 170, 0.25), 0 0 0 2px rgba(0,212,170,.35), 0 0 40px rgba(0,212,170,.55);
  background: rgba(0, 212, 170, 0.08);
}

/* Empty seat styling */
.seat.empty .seat-content {
  border-style: dashed;
  opacity: 0.5;
  cursor: pointer;
}

.seat.empty:hover .seat-content {
  opacity: 1;
  border-color: var(--accent);
}

/* Player info block */
.player-info{
  display:flex;
  align-items:center;
  gap: 8px;
  margin-bottom: 8px;
  position: relative;
  z-index: 1;
}

.player-avatar{
  width: 28px;
  height: 28px;
  border-radius: 8px;
  background: linear-gradient(135deg, var(--accent) 0%, #ff7a2f 100%);
  display:flex;
  align-items:center;
  justify-content:center;
  font-size: 16px;
  box-shadow: var(--shadow-md);
  color:#fff;
}

.seat-main .player-avatar {
  width: 48px;
  height: 48px;
  font-size: 24px;
}

.player-name{
  font-size: 10px;
  font-weight:700;
  color:#fff;
  flex:1;
  text-shadow: 0 2px 8px rgba(0, 0, 0, 0.8);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.seat-main .player-name {
  font-size: 14px;
  color: var(--teal);
  text-transform: uppercase;
  letter-spacing: 0.1em;
  text-shadow: 0 2px 10px rgba(0, 0, 0, 0.9), 0 0 20px rgba(0, 212, 170, 0.3);
}

.player-chips{
  font-family: var(--font-mono);
  font-size: 9px;
  color: var(--teal);
  font-weight:700;
  text-shadow: 0 2px 6px rgba(0, 0, 0, 0.8);
  white-space: nowrap;
}

.seat-main .player-chips {
  font-size: 12px;
  text-shadow: 0 2px 8px rgba(0, 0, 0, 0.9);
}

/* Cards */
.player-cards{
  display:flex;
  gap: 6px;
  justify-content:center;
  position: relative;
  z-index: 1;
}

.player-card{
  width: 50px;
  aspect-ratio: 5 / 7;
  border-radius: 6px;
  background-size: cover;
  background-position:center;
  box-shadow: var(--shadow-lg);
}

.seat-main .player-card {
  width: 68px;
}

/* === BOARD CENTER === */
.board-center{
  position:absolute;
  inset:0;
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  gap: 16px;
  z-index: 5;
}

.community-cards{
  display:flex;
  gap: 12px;
}

.card{
  width: 80px;
  aspect-ratio: 5 / 7;
  border-radius: 8px;
  background-size: cover;
  background-position:center;
  box-shadow: var(--shadow-xl);
}

.pot-display{
  padding: 16px 32px;
  border-radius: 16px;
  background: rgba(0,0,0,.92);
  border: 1px solid rgba(255,255,255,.25);
  text-align:center;
  box-shadow: var(--shadow-xl);
}

.pot-label{
  font-size: 10px;
  color: var(--muted);
  letter-spacing: .15em;
  font-weight:800;
  margin-bottom: 4px;
}

.pot-amount{
  font-family: var(--font-mono);
  font-size: 32px;
  color: var(--teal);
  font-weight:800;
}

/* === HUD === */
.game-hud{
  position: static;
  width: min(1000px, 92vw);
  margin-inline: auto;
  padding: clamp(10px, 3cqi, 20px);
  border-radius: clamp(12px, 2cqi, 18px);
  background: rgba(10,8,22,.98);
  border: 1px solid rgba(255,255,255,.1);
  box-shadow: var(--shadow-xl);
  backdrop-filter: blur(20px);
  display:flex;
  flex-direction:column;
  gap: clamp(10px, 2.4cqi, 16px);
}

.hud-info{
  display:flex;
  justify-content:center;
  gap: clamp(8px, 2cqi, 16px);
  flex-wrap: wrap;
}

.info-chip{
  display:flex;
  flex-direction:column;
  align-items:center;
  gap: 4px;
  padding: .5rem .9rem;
  border-radius: 12px;
  background: rgba(255,255,255,.05);
  border:1px solid rgba(255,255,255,.08);
}

.info-label{
  font-size:.7rem;
  color:var(--muted);
  font-weight:800;
  letter-spacing:.12em;
}

.info-value{
  font-family:var(--font-mono);
  font-weight:800;
}

.hud-actions{
  display:flex;
  flex-direction:column;
  gap: .75rem;
}

.quick-bets{
  display:grid;
  grid-template-columns: repeat(4, 1fr);
  gap: .5rem;
}

.quick-bet{
  padding:.6rem .8rem;
  border-radius:12px;
  background: rgba(255,255,255,.06);
  border:1px solid rgba(255,255,255,.1);
  color:#fff;
  font-weight:800;
  letter-spacing:.08em;
  text-transform:uppercase;
  cursor: pointer;
}

.quick-bet:hover{
  border-color: var(--accent);
  color: var(--accent);
  background: rgba(255,81,0,.12);
}

.bet-controls{
  display:flex;
  align-items:center;
  gap:.8rem;
}

.bet-slider{
  flex:1;
  height:6px;
  background: rgba(255,255,255,.1);
  border-radius:3px;
  outline:0;
  -webkit-appearance:none;
  appearance:none;
}

.bet-slider::-webkit-slider-thumb{
  -webkit-appearance:none;
  width:20px;
  height:20px;
  border-radius:50%;
  background: var(--accent);
  box-shadow: 0 2px 8px rgba(255,81,0,.5);
  cursor: pointer;
}

.bet-slider::-moz-range-thumb{
  width:20px;
  height:20px;
  border-radius:50%;
  background: var(--accent);
  box-shadow: 0 2px 8px rgba(255,81,0,.5);
  cursor: pointer;
  border: none;
}

.bet-input-wrap{
  display:flex;
  align-items:center;
  gap:.35rem;
  padding:.45rem .7rem;
  border-radius:10px;
  background: rgba(255,255,255,.06);
  border:1px solid rgba(255,255,255,.1);
}

.bet-input-wrap input{
  width:110px;
  background:transparent;
  border:0;
  outline:0;
  color:#fff;
  font-family:var(--font-mono);
  font-weight:800;
}

.action-btns{
  display:grid;
  grid-template-columns: 100px 1fr 1fr;
  gap:.75rem;
}

.action-btn{
  border:0;
  border-radius:16px;
  padding: .9rem 1rem;
  font-weight:800;
  letter-spacing:.08em;
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  gap:.25rem;
  position:relative;
  cursor:pointer;
}

.btn-key{
  position:absolute;
  right:.5rem;
  top:.5rem;
  font-size:.65rem;
  opacity:.6;
  background: rgba(0,0,0,.3);
  padding:.2rem .35rem;
  border-radius:8px;
}

.btn-fold{
  background: rgba(255,255,255,.06);
  color:var(--muted);
  border:2px solid rgba(255,255,255,.1);
}

.btn-fold:hover{
  background: var(--error);
  color:#fff;
  border-color: var(--error);
}

.btn-call{
  background: linear-gradient(135deg, var(--teal) 0%, #00efc2 100%);
  color:#0b0b0f;
  box-shadow: 0 6px 22px rgba(0,212,170,.35);
}

.btn-raise{
  background: linear-gradient(135deg, var(--accent) 0%, #ff7a2f 100%);
  color:#0b0b0f;
  box-shadow: 0 6px 22px rgba(255,81,0,.35);
}

/* === HOST CONTROLS MODAL === */
.host-modal {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.85);
  backdrop-filter: blur(8px);
  z-index: 200;
  display: none;
  align-items: center;
  justify-content: center;
}

.host-modal.show {
  display: flex;
}

.host-modal-content {
  background: rgba(17, 16, 24, 0.98);
  border: 1px solid rgba(255, 255, 255, 0.1);
  border-radius: 16px;
  padding: 2rem;
  max-width: 500px;
  width: 90%;
  max-height: 80vh;
  overflow-y: auto;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
}

.host-modal-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 1.5rem;
  padding-bottom: 1rem;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.host-modal-title {
  font-size: 1.5rem;
  font-weight: 700;
  color: var(--accent);
}

.host-modal-close {
  width: 32px;
  height: 32px;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.05);
  border: none;
  color: var(--muted);
  font-size: 1.5rem;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s;
}

.host-modal-close:hover {
  background: var(--error);
  color: white;
}

.host-section {
  margin-bottom: 1.5rem;
}

.host-section-title {
  font-size: 0.875rem;
  color: var(--muted);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  font-weight: 600;
  margin-bottom: 0.75rem;
}

.felt-colors {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 0.5rem;
}

.felt-option {
  aspect-ratio: 1;
  border-radius: 8px;
  border: 2px solid transparent;
  cursor: pointer;
  transition: all 0.2s;
}

.felt-option:hover {
  transform: scale(1.05);
  border-color: var(--text);
}

.felt-option.active {
  border-color: var(--accent);
  box-shadow: 0 0 20px rgba(255, 81, 0, 0.5);
}

.felt-option[data-color="green"] { background: #197a45; }
.felt-option[data-color="red"] { background: #6b1414; }
.felt-option[data-color="black"] { background: #1a1a1a; }
.felt-option[data-color="blue"] { background: #0f2942; }
.felt-option[data-color="grey"] { background: #2a2a2a; }
.felt-option[data-color="tan"] { background: #6b5642; }
.felt-option[data-color="purple"] { background: #3a1450; }

.host-action-btn {
  width: 100%;
  padding: 0.875rem;
  margin-bottom: 0.5rem;
  background: rgba(255, 255, 255, 0.05);
  border: 1px solid rgba(255, 255, 255, 0.1);
  border-radius: 8px;
  color: var(--text);
  font-size: 0.875rem;
  font-weight: 600;
  cursor: pointer;
  text-align: left;
  transition: all 0.2s;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.host-action-btn:hover {
  background: rgba(255, 81, 0, 0.1);
  border-color: var(--accent);
  color: var(--accent);
}

/* === RESPONSIVE === */
@media (max-width: 900px){
  .action-btns{
    grid-template-columns: 80px 1fr 1fr;
  }
  .quick-bets{
    grid-template-columns: repeat(2, 1fr);
  }
  .navbar-links{
    display: none;
  }
}
</style>
</head>
<body data-felt="green">

<!-- NAVBAR -->
<nav class="navbar">
  <div class="navbar-inner">
    <a class="navbar-brand" href="/">PokerGeek<span class="dot">.ai</span></a>
    <ul class="navbar-links">
      <li><a href="/">Home</a></li>
      <li><a href="/play">Play Now</a></li>
      <li><a href="/friends">Friends</a></li>
      <li><a href="/ai-solver">AI Solver</a></li>
      <li><a href="/analysis">Analysis</a></li>
      <li><a href="/learning">Learning</a></li>
      <li><a href="/poker-today">Poker Today</a></li>
    </ul>
    <div class="navbar-auth">
      <button class="navbar-btn host-btn" id="hostControlsBtn" style="display: none;">
        🛡️ Host Controls
      </button>
      <a class="navbar-btn login" href="#">Log In</a>
      <a class="navbar-btn signup" href="#">Sign Up</a>
    </div>
  </div>
</nav>

<!-- PAGE: two rows (table + HUD) -->
<main class="poker-game">
  <!-- Row 1: Table area (letterbox container) -->
  <div class="table-wrapper" id="tableWrapper">
    <div class="poker-table" id="pokerTable">
      <div class="table-felt"></div>
      
      <!-- Shared inner box -->
      <div class="table-inner">
        <!-- Seats -->
        <div class="seats-layer">
          <!-- 10 seats - positions set by JS -->
          <div class="seat seat-main" data-seat="0">
            <div class="seat-content">
              <div class="player-info">
                <div class="player-avatar">👤</div>
                <div class="player-name">You</div>
                <div class="player-chips">$0</div>
              </div>
              <div class="player-cards"></div>
            </div>
          </div>

          <div class="seat" data-seat="1"><div class="seat-content"><div class="player-info"><div class="player-avatar"></div><div class="player-name"></div><div class="player-chips"></div></div><div class="player-cards"></div></div></div>
          <div class="seat" data-seat="2"><div class="seat-content"><div class="player-info"><div class="player-avatar"></div><div class="player-name"></div><div class="player-chips"></div></div><div class="player-cards"></div></div></div>
          <div class="seat" data-seat="3"><div class="seat-content"><div class="player-info"><div class="player-avatar"></div><div class="player-name"></div><div class="player-chips"></div></div><div class="player-cards"></div></div></div>
          <div class="seat" data-seat="4"><div class="seat-content"><div class="player-info"><div class="player-avatar"></div><div class="player-name"></div><div class="player-chips"></div></div><div class="player-cards"></div></div></div>
          <div class="seat" data-seat="5"><div class="seat-content"><div class="player-info"><div class="player-avatar"></div><div class="player-name"></div><div class="player-chips"></div></div><div class="player-cards"></div></div></div>
          <div class="seat" data-seat="6"><div class="seat-content"><div class="player-info"><div class="player-avatar"></div><div class="player-name"></div><div class="player-chips"></div></div><div class="player-cards"></div></div></div>
          <div class="seat" data-seat="7"><div class="seat-content"><div class="player-info"><div class="player-avatar"></div><div class="player-name"></div><div class="player-chips"></div></div><div class="player-cards"></div></div></div>
          <div class="seat" data-seat="8"><div class="seat-content"><div class="player-info"><div class="player-avatar"></div><div class="player-name"></div><div class="player-chips"></div></div><div class="player-cards"></div></div></div>
          <div class="seat" data-seat="9"><div class="seat-content"><div class="player-info"><div class="player-avatar"></div><div class="player-name"></div><div class="player-chips"></div></div><div class="player-cards"></div></div></div>
        </div>

        <!-- Board -->
        <div class="board-center">
          <div class="community-cards" id="communityCards"></div>
          <div class="pot-display">
            <div class="pot-label">POT</div>
            <div class="pot-amount" id="potAmount">$0</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Row 2: HUD -->
  <div class="game-hud">
    <div class="hud-info">
      <div class="info-chip"><span class="info-label">ROOM</span><span class="info-value" id="hudRoom">—</span></div>
      <div class="info-chip"><span class="info-label">HAND</span><span class="info-value" id="hudHand">—</span></div>
      <div class="info-chip"><span class="info-label">YOUR CHIPS</span><span class="info-value" id="hudChips">$0</span></div>
    </div>

    <div class="hud-actions">
      <div class="quick-bets">
        <button class="quick-bet" data-mult="0.5">½ POT</button>
        <button class="quick-bet" data-mult="0.75">¾ POT</button>
        <button class="quick-bet" data-mult="1">POT</button>
        <button class="quick-bet" data-mult="2">2× POT</button>
      </div>

      <div class="bet-controls">
        <input type="range" id="betSlider" class="bet-slider" min="0" max="1000" value="0" />
        <div class="bet-input-wrap">
          <span>$</span>
          <input type="number" id="betInput" value="0" min="0" />
        </div>
      </div>

      <div class="action-btns">
        <button class="action-btn btn-fold" id="foldBtn"><span class="btn-label">FOLD</span><span class="btn-key">F</span></button>
        <button class="action-btn btn-call" id="callBtn"><span class="btn-label">CALL</span><span class="btn-amount" id="callAmount">$0</span><span class="btn-key">C</span></button>
        <button class="action-btn btn-raise" id="raiseBtn"><span class="btn-label">RAISE</span><span class="btn-amount" id="raiseAmount">$0</span><span class="btn-key">R</span></button>
      </div>
    </div>
  </div>
</main>

<!-- HOST CONTROLS MODAL -->
<div class="host-modal" id="hostModal">
  <div class="host-modal-content">
    <div class="host-modal-header">
      <h2 class="host-modal-title">🛡️ Host Controls</h2>
      <button class="host-modal-close" id="closeHostModal">×</button>
    </div>

    <div class="host-section">
      <div class="host-section-title">Table Felt Color</div>
      <div class="felt-colors">
        <div class="felt-option active" data-color="green"></div>
        <div class="felt-option" data-color="red"></div>
        <div class="felt-option" data-color="black"></div>
        <div class="felt-option" data-color="blue"></div>
        <div class="felt-option" data-color="grey"></div>
        <div class="felt-option" data-color="tan"></div>
        <div class="felt-option" data-color="purple"></div>
      </div>
    </div>

    <div class="host-section">
      <div class="host-section-title">Game Controls</div>
      <button class="host-action-btn" id="startHandBtn" onclick="window.pokerTable?.startGameFromTable()">🎮 START HAND</button>
      <button class="host-action-btn" id="pauseGame">⏸️ Pause Game</button>
      <button class="host-action-btn" id="resumeGame">▶️ Resume Game</button>
      <button class="host-action-btn" id="kickPlayer">👢 Kick Player</button>
    </div>

    <div class="host-section">
      <div class="host-section-title">Chip Management</div>
      <button class="host-action-btn" id="adjustChips">💰 Adjust Player Chips</button>
      <button class="host-action-btn" id="resetChips">🔄 Reset All Chips</button>
    </div>

    <div class="host-section">
      <div class="host-section-title">Table Settings</div>
      <button class="host-action-btn" id="changeBlinds">🎲 Change Blinds</button>
      <button class="host-action-btn" id="changeTimer">⏱️ Change Turn Timer</button>
      <button class="host-action-btn" id="toggleAutoStart">🔁 Auto-Start: OFF</button>
      <button class="host-action-btn" id="showUndealt">👁️ Show Undealt Cards</button>
    </div>
  </div>
</div>

<script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
<script>
/**
 * ZOOM-LOCKED POKER TABLE
 * Uses fixed virtual canvas with uniform scaling
 */

class PokerTableGrid {
  constructor() {
    this.roomId = null;
    this.userId = null;
    this.gameState = null;
    
    // Backend connection
    this.socket = null;
    this.sequenceTracker = null;
    this.gameId = null;
    this.currentBet = 0;
    this.myTurn = false;
    this.isHydrated = false;
    this.lastHydrationTime = 0;
    
    // VIRTUAL CANVAS DIMENSIONS (fixed!)
    this.HORIZONTAL_STAGE = { width: 1680, height: 800 };
    this.VERTICAL_STAGE = { width: 600, height: 1200 };
    this.BREAKPOINT = 768;
    
    this.isVertical = false;
    this.scale = 1;
    
    // Fixed pixel positions for horizontal layout
    this.seatsHorizontal = [
      { index: 0, x: 840, y: 700 },  // Bottom (you)
      { index: 1, x: 1260, y: 624 }, // Bottom right
      { index: 2, x: 1512, y: 224 }, // Top right  
      { index: 3, x: 1512, y: 480 }, // Right middle
      { index: 4, x: 1108, y: 64 },  // Top-right
      { index: 5, x: 823, y: 104 },  // Top center
      { index: 6, x: 538, y: 64 },   // Top-left
      { index: 7, x: 185, y: 256 },  // Left top
      { index: 8, x: 185, y: 504 },  // Left bottom
      { index: 9, x: 437, y: 592 },  // Bottom left
    ];
    
    // Fixed pixel positions for vertical layout
    this.seatsVertical = [
      { index: 0, x: 300, y: 1056 }, // Bottom (you)
      { index: 1, x: 420, y: 960 },  // Bottom right
      { index: 2, x: 510, y: 780 },  // Right upper-bottom
      { index: 3, x: 510, y: 600 },  // Right middle
      { index: 4, x: 510, y: 420 },  // Right upper-middle
      { index: 5, x: 420, y: 240 },  // Top right
      { index: 6, x: 300, y: 144 },  // Top center
      { index: 7, x: 180, y: 240 },  // Top left
      { index: 8, x: 90, y: 420 },   // Left upper-middle
      { index: 9, x: 90, y: 780 },   // Left upper-bottom
    ];
    
    console.log('🎰 Zoom-Locked Poker Table initialized');
  }

  async init() {
    console.log('🎬 PokerTableGrid.init() starting...');
    
    // ✅ Apply table color if set by host
    const tableColor = sessionStorage.getItem('tableColor');
    if (tableColor) {
      document.body.setAttribute('data-felt', tableColor);
      console.log('🎨 Table color set to:', tableColor);
    }
    
    this.setupZoomLock();
    console.log('✅ Zoom lock setup complete');
    // ✅ Apply initial seat positions BEFORE backend init
    this.applySeatPositions();
    console.log('✅ Initial seat positions applied');
    await this.initWithBackend();
    this.initHostControls();
    this.setupResizeObserver();
  }

  setupZoomLock() {
    const wrapper = document.getElementById('tableWrapper');
    const table = document.getElementById('pokerTable');
    
    if (!wrapper || !table) {
      console.error('❌ tableWrapper or pokerTable not found!');
      return;
    }

    const updateScale = () => {
      const containerWidth = wrapper.clientWidth;
      const containerHeight = wrapper.clientHeight;

      // Decide which stage preset to use (mode switch at breakpoint)
      const useVertical = containerWidth < this.BREAKPOINT;
      
      if (useVertical !== this.isVertical) {
        this.isVertical = useVertical;
        table.classList.toggle('vertical-mode', useVertical);
        this.applySeatPositions(); // Reposition seats for new mode
      }

      const stage = this.isVertical ? this.VERTICAL_STAGE : this.HORIZONTAL_STAGE;

      // Calculate uniform scale (contain fit)
      const scaleX = containerWidth / stage.width;
      const scaleY = containerHeight / stage.height;
      this.scale = Math.min(scaleX, scaleY);

      // Calculate letterbox/pillarbox offsets (AFTER scaling)
      const scaledWidth = stage.width * this.scale;
      const scaledHeight = stage.height * this.scale;
      const offsetX = (containerWidth - scaledWidth) / 2;
      const offsetY = (containerHeight - scaledHeight) / 2;

      // CRITICAL FIX: Set position via left/top, NOT translate
      // This way the offset doesn't get scaled
      table.style.left = `${offsetX}px`;
      table.style.top = `${offsetY}px`;
      table.style.transform = `scale(${this.scale})`;
    };

    // Initial scale
    updateScale();

    // Update on window resize
    window.addEventListener('resize', updateScale);
    
    // Also handle when wrapper size changes
    const resizeObserver = new ResizeObserver(updateScale);
    resizeObserver.observe(wrapper);
  }

  setupResizeObserver() {
    // Additional resize observer for any dynamic content
    const wrapper = document.getElementById('tableWrapper');
    if (!wrapper) return;
    
    const observer = new ResizeObserver(() => {
      // Trigger scale recalculation
      window.dispatchEvent(new Event('resize'));
    });
    
    observer.observe(wrapper);
  }

  applySeatPositions() {
    const seats = this.isVertical ? this.seatsVertical : this.seatsHorizontal;
    
    console.log(`📍 Applying seat positions (${this.isVertical ? 'VERTICAL' : 'HORIZONTAL'} mode)`);
    
    let positioned = 0;
    seats.forEach(seatPos => {
      const seatEl = document.querySelector(`[data-seat="${seatPos.index}"]`);
      if (!seatEl) {
        console.warn(`⚠️ Seat element not found for index ${seatPos.index}`);
        return;
      }
      
      // Set fixed pixel positions
      seatEl.style.left = `${seatPos.x}px`;
      seatEl.style.top = `${seatPos.y}px`;
      positioned++;
    });
    
    console.log(`✅ Positioned ${positioned}/${seats.length} seats`);
  }

  initDemo() {
    console.log('🎬 Demo mode');
    
    // Show host button in demo
    const hostBtn = document.getElementById('hostControlsBtn');
    if (hostBtn) {
      hostBtn.style.display = 'block';
      hostBtn.addEventListener('click', () => {
        document.getElementById('hostModal').classList.add('show');
      });
    }

    const demoData = {
      seats: [
        { index: 0, name: 'WALEED', chips: 5280, avatar: '🦈', cards: ['hearts_A', 'diamonds_A'], isMe: true },
        { index: 1, name: 'ProPlayer', chips: 3750, avatar: '🎯', cards: ['back', 'back'] },
        { index: 3, name: 'RocketMan', chips: 8875, avatar: '🚀', cards: ['back', 'back'] },
        { index: 5, name: 'DiamondH', chips: 11200, avatar: '💎', cards: ['back', 'back'] },
        { index: 7, name: 'LuckyAce', chips: 2100, avatar: '🎲', cards: ['back', 'back'] }
      ],
      board: ['hearts_A', 'spades_K', 'hearts_Q', 'clubs_J', 'back'],
      pot: 3450,
      room: 'DEMO',
      hand: 42
    };

    this.applySeatPositions(); // Apply fixed positions first
    this.renderSeats(demoData.seats);
    this.renderBoard(demoData.board);
    this.renderPot(demoData.pot);
    this.renderHudInfo(demoData);
  }

  async getCurrentSeats() {
    try {
      const response = await fetch(`/api/rooms/${this.roomId}/hydrate?userId=${this.userId}`);
      const data = await response.json();
      return data.seats?.filter(s => s && s.user_id) || [];
    } catch (error) {
      console.error('Failed to get seats:', error);
      return [];
    }
  }

  initHostControls() {
    const closeBtn = document.getElementById('closeHostModal');
    const modal = document.getElementById('hostModal');
    
    if (closeBtn && modal) {
      closeBtn.addEventListener('click', () => {
        modal.classList.remove('show');
      });
      
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          modal.classList.remove('show');
        }
      });
    }

    // Felt color changing
    document.querySelectorAll('.felt-option').forEach(option => {
      option.addEventListener('click', () => {
        const color = option.dataset.color;
        document.body.dataset.felt = color;
        sessionStorage.setItem('tableColor', color);
        document.querySelectorAll('.felt-option').forEach(o => o.classList.remove('active'));
        option.classList.add('active');
        console.log(`Changed felt color to: ${color}`);
      });
    });

    // Kick Player
    document.getElementById('kickPlayer')?.addEventListener('click', async () => {
      try {
        const seats = await this.getCurrentSeats();
        if (seats.length === 0) {
          this.showToast('No players to kick', 'info');
          return;
        }
        
        const seatList = seats.map(s => `Seat ${s.seat_index}: ${s.username} ($${s.chips_in_play})`).join('\n');
        const seatIndex = prompt(`Which seat to kick?\n\n${seatList}`);
        
        if (seatIndex === null) return;
        
        const targetSeat = seats.find(s => s.seat_index === parseInt(seatIndex));
        if (!targetSeat) {
          this.showToast('Invalid seat number', 'error');
          return;
        }
        
        const response = await fetch(`/api/rooms/${this.roomId}/kick`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Idempotency-Key': `kick-${this.roomId}-${Date.now()}`.substring(0, 63)
          },
          body: JSON.stringify({
            hostId: this.userId,
            targetUserId: targetSeat.user_id
          })
        });
        
        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || 'Failed to kick player');
        }
        
        this.showToast(`Kicked ${targetSeat.username} from seat ${seatIndex}`, 'success');
        this.lastHydrationTime = 0;
        await this.fetchHydration();
        
      } catch (error) {
        console.error('Kick error:', error);
        this.showToast('Failed to kick: ' + error.message, 'error');
      }
    });

    // Adjust Chips
    document.getElementById('adjustChips')?.addEventListener('click', async () => {
      try {
        const seats = await this.getCurrentSeats();
        if (seats.length === 0) {
          this.showToast('No players to adjust', 'info');
          return;
        }
        
        const seatList = seats.map(s => `Seat ${s.seat_index}: ${s.username} ($${s.chips_in_play})`).join('\n');
        const seatIndex = prompt(`Add chips to which seat?\n\n${seatList}`);
        
        if (seatIndex === null) return;
        
        const targetSeat = seats.find(s => s.seat_index === parseInt(seatIndex));
        if (!targetSeat) {
          this.showToast('Invalid seat number', 'error');
          return;
        }
        
        const amount = prompt(`How much to add to ${targetSeat.username}?\nCurrent: $${targetSeat.chips_in_play}`);
        if (!amount || isNaN(amount)) return;
        
        const newTotal = parseInt(targetSeat.chips_in_play) + parseInt(amount);
        
        const response = await fetch(`/api/rooms/${this.roomId}/update-chips`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Idempotency-Key': `chips-${this.roomId}-${Date.now()}`.substring(0, 63)
          },
          body: JSON.stringify({
            hostId: this.userId,
            targetUserId: targetSeat.user_id,
            newAmount: newTotal
          })
        });
        
        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || 'Failed to adjust chips');
        }
        
        this.showToast(`Added $${amount} to ${targetSeat.username}`, 'success');
        this.lastHydrationTime = 0;
        await this.fetchHydration();
        
      } catch (error) {
        console.error('Adjust chips error:', error);
        this.showToast('Failed to adjust chips: ' + error.message, 'error');
      }
    });

    // Pause Game
    document.getElementById('pauseGame')?.addEventListener('click', async () => {
      try {
        const response = await fetch(`/api/rooms/${this.roomId}/pause-game`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Idempotency-Key': `pause-${this.roomId}-${Date.now()}`.substring(0, 63)
          },
          body: JSON.stringify({
            hostId: this.userId
          })
        });
        
        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || 'Failed to pause');
        }
        
        this.showToast('Game paused', 'info');
        
      } catch (error) {
        console.error('Pause error:', error);
        this.showToast('Failed to pause: ' + error.message, 'error');
      }
    });

    // Resume Game
    document.getElementById('resumeGame')?.addEventListener('click', async () => {
      try {
        const response = await fetch(`/api/rooms/${this.roomId}/resume-game`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Idempotency-Key': `resume-${this.roomId}-${Date.now()}`.substring(0, 63)
          },
          body: JSON.stringify({
            hostId: this.userId
          })
        });
        
        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || 'Failed to resume');
        }
        
        this.showToast('Game resumed', 'success');
        
      } catch (error) {
        console.error('Resume error:', error);
        this.showToast('Failed to resume: ' + error.message, 'error');
      }
    });
  }

  renderSeats(seats, enableClaiming = false) {
    seats.forEach(seat => {
      const seatEl = document.querySelector(`[data-seat="${seat.index}"]`);
      if (!seatEl) return;

      seatEl.classList.remove('empty', 'occupied');
      seatEl.onclick = null; // Clear any existing handlers
      
      if (seat.isEmpty && enableClaiming) {
        // EMPTY SEAT - Make it claimable
        seatEl.classList.add('empty');
        seatEl.style.cursor = 'pointer';
        seatEl.style.opacity = '0.7';
        seatEl.style.border = '3px dashed var(--teal)';
        seatEl.style.zIndex = '10';
        seatEl.style.pointerEvents = 'auto';
        
        // Set onclick handler
        const seatIndex = seat.index;
        seatEl.onclick = (e) => {
          e.stopPropagation();
          console.log('🖱️ SEAT CLICKED:', seatIndex);
          this.claimSeatOnTable(seatIndex);
        };
        
        console.log(`✅ Made seat ${seatIndex} clickable with onclick handler`);
        
        const avatar = seatEl.querySelector('.player-avatar');
        const name = seatEl.querySelector('.player-name');
        const chips = seatEl.querySelector('.player-chips');
        
        if (avatar) avatar.textContent = '🪑';
        if (name) {
          name.textContent = `Seat ${seat.index + 1}`;
          name.style.color = 'var(--teal)';
        }
        if (chips) {
          chips.textContent = 'Click to claim';
          chips.style.color = 'var(--teal)';
          chips.style.fontSize = '0.8rem';
        }
        
      } else {
        // OCCUPIED SEAT
      seatEl.classList.add('occupied');
        seatEl.style.cursor = 'default';
        seatEl.style.opacity = '1';
        seatEl.style.border = '';
      
      if (seat.isMe) {
        seatEl.classList.add('active', 'seat-main');
          seatEl.style.border = '3px solid gold';
      }

      const avatar = seatEl.querySelector('.player-avatar');
      const name = seatEl.querySelector('.player-name');
      const chips = seatEl.querySelector('.player-chips');
      const cardsContainer = seatEl.querySelector('.player-cards');

      if (avatar) avatar.textContent = seat.avatar;
        if (name) {
          name.textContent = seat.name;
          name.style.color = '#fff';
        }
        if (chips) {
          chips.textContent = `$${seat.chips.toLocaleString()}`;
          chips.style.color = '#FFC107';
          chips.style.fontSize = '';
        }

        if (cardsContainer && seat.cards && seat.cards.length > 0) {
        cardsContainer.innerHTML = seat.cards.map(card => 
          `<div class="player-card" style="background-image: url('/cards/${card}.png');"></div>`
        ).join('');
      }
      }
    });
  }

  renderBoard(cards) {
    const container = document.getElementById('communityCards');
    if (!container) return;

    container.innerHTML = cards.map(card => 
      `<div class="card" style="background-image: url('/cards/${card}.png');"></div>`
    ).join('');
  }

  renderPot(amount) {
    const potEl = document.getElementById('potAmount');
    if (potEl) {
      potEl.textContent = `$${amount.toLocaleString()}`;
    }
  }

  renderHudInfo(data) {
    const room = document.getElementById('hudRoom');
    const hand = document.getElementById('hudHand');
    const chips = document.getElementById('hudChips');

    if (room) room.textContent = data.room;
    if (hand) hand.textContent = `#${data.hand}`;
    if (chips && data.seats && data.seats[0]) chips.textContent = `$${data.seats[0].chips.toLocaleString()}`;
  }

  async initWithBackend() {
    console.log('🔌 Initializing with backend...');
    
    // Try multiple auth sources
    let user = null;
    
    // Source 1: window.currentUser (set by play.html)
    if (window.currentUser) {
      user = window.currentUser;
      console.log('✅ Found user from window.currentUser');
    }
    
    // Source 2: sessionStorage
    if (!user) {
      const cached = sessionStorage.getItem('currentUser');
      if (cached) {
        try {
          user = JSON.parse(cached);
          console.log('✅ Found user from sessionStorage');
        } catch (e) {
          console.warn('Failed to parse cached user');
        }
      }
    }
    
    // Source 3: Auth manager
    if (!user && window.authManager) {
      try {
        user = await window.authManager.getCurrentUser();
        if (user) {
          console.log('✅ Found user from authManager');
        }
      } catch (e) {
        console.warn('Auth manager check failed:', e);
      }
    }
    
    if (user) {
      this.userId = user.id;
      sessionStorage.setItem('userId', user.id);
      sessionStorage.setItem('currentUser', JSON.stringify(user));
      console.log('✅ User authenticated:', this.userId);
    }
    
    const urlParams = new URLSearchParams(window.location.search);
    this.roomId = urlParams.get('room');
    
    if (!this.roomId) {
      const pathMatch = window.location.pathname.match(/\/game\/([^\/]+)/);
      if (pathMatch) {
        this.roomId = pathMatch[1];
      }
    }
    
    if (!this.roomId) {
      console.error('No room ID, redirecting to /play');
      window.location.href = '/play';
      return;
    }
    
    if (!this.userId) {
      this.userId = sessionStorage.getItem('userId');
    }
    
    // Also try window.currentUser as fallback
    if (!this.userId && window.currentUser) {
      this.userId = window.currentUser.id;
      sessionStorage.setItem('userId', this.userId);
    }
    
    if (!this.userId) {
      console.error('❌ No user ID found in sessionStorage or window.currentUser');
      console.log('Available:', {
        sessionStorage: sessionStorage.getItem('userId'),
        windowCurrentUser: window.currentUser,
        authManager: window.authManager
      });
      alert('Please sign in first');
      window.location.href = '/play';
      return;
    }
    
    console.log('✅ User ID found:', this.userId);
    
    console.log(`🎮 Connecting room: ${this.roomId}, user: ${this.userId}`);
    
    this.sequenceTracker = new SequenceTracker();
    this.socket = io();
    
    this.socket.on('connect', () => {
      console.log('✅ Socket connected:', this.socket.id);
      this.authenticateSocket();
    });
    
    this.socket.on('disconnect', (reason) => {
      console.warn('🔌 Socket disconnected:', reason);
      this.showToast('Connection lost. Reconnecting...', 'error');
    });
    
    this.socket.on('authenticated', () => {
      console.log('✅ Authenticated, fetching state...');
      // Setup event handlers FIRST so we catch real-time updates
      this.setupGameEventHandlers();
      this.wireActionButtons();
      // THEN fetch initial state
      this.fetchHydration();
    });
    
    this.socket.on('state_sync', this.sequenceTracker.createHandler((data) => {
      console.log('🔄 State sync received');
      if (data.payload?.fetchViaHttp) {
        this.fetchHydration();
      }
    }));
  }

  authenticateSocket() {
    const rejoinToken = sessionStorage.getItem('rejoin_token');
    this.socket.emit('authenticate', {
      userId: this.userId,
      roomId: this.roomId,
      rejoinToken: rejoinToken
    });
    
    // CRITICAL: Explicitly join Socket.IO room to receive broadcasts
    this.socket.emit('join_room', {
      roomId: this.roomId,
      userId: this.userId
    });
    
    console.log(`🔌 [TABLE] Joining Socket.IO room: ${this.roomId}`);
  }

  async fetchHydration() {
    const now = Date.now();
    if (now - this.lastHydrationTime < 1000) {
      console.log('⏸️ Hydration debounced');
      return;
    }
    this.lastHydrationTime = now;
    
    try {
      console.log('🌊 Fetching hydration...');
      
      const response = await fetch(`/api/rooms/${this.roomId}/hydrate?userId=${this.userId}`);
      
      if (!response.ok) {
        if (response.status === 404) {
          console.warn('Room not found');
          setTimeout(() => window.location.href = '/play', 2000);
          return;
        }
        throw new Error(`Hydration failed: ${response.status}`);
      }
      
      const hydration = await response.json();
      console.log('✅ Hydration received (seq:', hydration.seq, ')');
      
      this.sequenceTracker.setSequence(hydration.seq || 0);
      
      if (hydration.game) {
        this.gameId = hydration.game.id;
      }
      
      if (hydration.me?.rejoin_token) {
        sessionStorage.setItem('rejoin_token', hydration.me.rejoin_token);
      }
      
      this.isHydrated = true;
      this.renderFromHydration(hydration);
      // Event handlers already set up in authenticated callback
      
    } catch (error) {
      console.error('❌ Hydration failed:', error);
      // Don't redirect - just show message that game will start soon
      this.showToast('Waiting for game to start...', 'info');
      // Table will show seat selection UI instead
    }
  }

  renderFromHydration(hydration) {
    console.log('🎨 Rendering from hydration...', hydration);
    console.log('📊 Hydration data:', {
      hasGame: !!hydration.game,
      hasHand: !!hydration.hand,
      seatsCount: hydration.seats?.filter(s => s && s.user_id).length || 0,
      mySeated: hydration.me?.seat_index !== undefined
    });
    
    // ✅ CRITICAL: If no game yet, show seat selection
    if (!hydration.game || !hydration.hand) {
      console.log('ℹ️ No active game - showing seat selection UI');
      this.showSeatSelection(hydration);
      return;
    }
    
    this.applySeatPositions();
    
    // Render seats with proper data structure
    if (hydration.seats) {
      const seatData = hydration.seats.map(s => {
        if (!s) return null;
        
        // Determine if this seat is me
        const isMe = s.user_id === this.userId;
        
        // Show cards: my hole cards if I have them, otherwise card backs
        let cards = ['back', 'back'];
        if (isMe && hydration.me?.hole_cards && Array.isArray(hydration.me.hole_cards)) {
          cards = hydration.me.hole_cards;
        }
        
        return {
          index: s.seat_index,
          name: s.username || `Seat ${s.seat_index + 1}`,
          chips: s.chips_in_play || s.stack || 0,
          avatar: isMe ? '🦈' : '🎯',
          cards: cards,
          isMe: isMe,
          status: s.status
        };
      }).filter(s => s !== null);
      
      this.renderSeats(seatData);
    }
    
    // Render board cards (handle empty array and null)
    if (hydration.hand?.board) {
      const board = Array.isArray(hydration.hand.board) ? hydration.hand.board : [];
      this.renderBoard(board);
    }
    
    // Render pot
    if (hydration.hand?.pot_total !== undefined) {
      this.renderPot(hydration.hand.pot_total);
    }
    
    // Render dealer button
    if (hydration.hand?.dealer_seat !== undefined) {
      this.updateDealerButton(hydration.hand.dealer_seat);
    }
    
    // Render current actor highlight
    if (hydration.hand?.actor_seat !== undefined) {
      const actorUserId = hydration.seats?.[hydration.hand.actor_seat]?.user_id;
      if (actorUserId === this.userId) {
        this.myTurn = true;
        this.enableActionButtons();
      }
    }
    
    // Update HUD
    const myChips = hydration.me?.seat_index !== undefined ? 
      (hydration.seats[hydration.me.seat_index]?.chips_in_play || 0) : 0;
    
    this.renderHudInfo({
      room: hydration.room?.code || 'Room',
      hand: hydration.hand?.hand_number || 1,
      seats: [{ chips: myChips }]
    });
  }

  wireActionButtons() {
    const foldBtn = document.getElementById('foldBtn');
    const callBtn = document.getElementById('callBtn');
    const raiseBtn = document.getElementById('raiseBtn');
    
    if (foldBtn) foldBtn.onclick = () => this.sendAction('FOLD', 0);
    if (callBtn) callBtn.onclick = () => this.sendAction('CALL', this.currentBet);
    if (raiseBtn) raiseBtn.onclick = () => {
      const amount = parseInt(document.getElementById('betInput')?.value || 0);
      this.sendAction('RAISE', amount);
    };
  }

  async sendAction(action, amount) {
    if (!this.isHydrated || !this.gameId) {
      console.error('Cannot send action: not ready');
      return;
    }
    
    this.disableActionButtons();
    console.log(`🎯 Sending: ${action} ${amount}`);
    
    try {
      const response = await fetch(`/api/games/${this.gameId}/actions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Idempotency-Key': `${this.gameId}-${this.userId}-${action}-${Date.now()}`
        },
        body: JSON.stringify({
          player_id: this.userId,
          user_id: this.userId, // Required by idempotency middleware
          action: action.toUpperCase(),
          amount: amount || 0
        })
      });
      
      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'Action failed');
      }
      
      console.log('✅ Action sent');
      
    } catch (error) {
      console.error('❌ Action failed:', error);
      this.showToast(error.message, 'error');
      this.enableActionButtons();
    }
  }

  setupGameEventHandlers() {
    console.log('🎧 Setting up game event handlers...');
    
    // ✅ CRITICAL: Listen for seat updates
    this.socket.on('seat_update', (data) => {
      console.log('🪑 RAW seat update received:', data);
      
      // Use sequence tracker
      const handler = this.sequenceTracker.createHandler((processedData) => {
        console.log('🪑 Seat update PROCESSED by sequence tracker:', processedData);
        if (processedData.payload?.roomId === this.roomId) {
          console.log('🔄 Refreshing seats...');
          this.lastHydrationTime = 0; // Force refresh
          this.fetchHydration();
        }
      });
      
      handler(data);
    });
    
    console.log('✅ seat_update listener registered');
    
    this.socket.on('hand_started', this.sequenceTracker.createHandler((data) => {
      console.log('🃏 Hand started');
      this.onHandStarted(data.payload);
    }));
    
    this.socket.on('player_action', this.sequenceTracker.createHandler((data) => {
      console.log('👤 Player action');
      this.onPlayerAction(data.payload);
    }));
    
    this.socket.on('action_required', this.sequenceTracker.createHandler((data) => {
      console.log('⚡ Your turn');
      this.onActionRequired(data.payload);
    }));
    
    this.socket.on('board_dealt', this.sequenceTracker.createHandler((data) => {
      console.log('🎴 Board dealt');
      if (data.payload?.board) this.renderBoard(data.payload.board);
    }));
    
    this.socket.on('hand_complete', this.sequenceTracker.createHandler((data) => {
      console.log('🏆 Hand complete');
      this.onHandComplete(data.payload);
    }));
    
    this.socket.on('seat_claimed', this.sequenceTracker.createHandler((data) => {
      console.log('🪑 Seat claimed by another player');
      // Refresh to show updated seats
      this.fetchHydration();
    }));
  }

  onHandStarted(data) {
    const payload = data.payload || data; // Handle both wrapped and unwrapped
    this.renderBoard([]);
    this.renderPot(payload.pot || 0);
    if (payload.dealerSeat !== undefined) this.updateDealerButton(payload.dealerSeat);
    if (payload.myCards && payload.mySeat !== undefined) {
      this.renderMyCards(payload.myCards, payload.mySeat);
    }
    this.myTurn = false;
    this.disableActionButtons();
    console.log('🃏 Hand started - rendering initial state');
  }

  onPlayerAction(data) {
    if (data.pot !== undefined) this.renderPot(data.pot);
    if (data.currentBet !== undefined) this.currentBet = data.currentBet;
    if (data.playerId === this.userId) {
      this.myTurn = false;
      this.disableActionButtons();
    }
  }

  onActionRequired(data) {
    if (data.playerId !== this.userId) return;
    this.myTurn = true;
    this.enableActionButtons();
    this.currentBet = data.callAmount || 0;
  }

  onHandComplete(data) {
    if (data.winners) {
      const winnerNames = data.winners.map(w => w.username).join(', ');
      this.showToast(`Winner: ${winnerNames}`, 'info');
    }
  }

  updateDealerButton(seatIndex) {
    document.querySelectorAll('.dealer-button').forEach(b => b.remove());
    const seat = document.querySelector(`[data-seat="${seatIndex}"]`);
    if (seat) {
      const btn = document.createElement('div');
      btn.className = 'dealer-button';
      btn.textContent = 'D';
      btn.style.cssText = 'position:absolute;top:-10px;right:-10px;width:24px;height:24px;border-radius:50%;background:var(--accent);color:white;display:flex;align-items:center;justify-content:center;font-weight:800;font-size:12px;';
      seat.appendChild(btn);
    }
  }

  renderMyCards(cards, seatIndex) {
    const seat = document.querySelector(`[data-seat="${seatIndex}"]`);
    if (!seat) return;
    const container = seat.querySelector('.player-cards');
    if (!container) return;
    container.innerHTML = cards.map(card => 
      `<div class="player-card" style="background-image: url('/cards/${card}.png');"></div>`
    ).join('');
  }

  disableActionButtons() {
    ['foldBtn', 'callBtn', 'raiseBtn'].forEach(id => {
      const btn = document.getElementById(id);
      if (btn) btn.disabled = true;
    });
  }

  enableActionButtons() {
    ['foldBtn', 'callBtn', 'raiseBtn'].forEach(id => {
      const btn = document.getElementById(id);
      if (btn) btn.disabled = false;
    });
  }

  showToast(message, type = 'info') {
    const toast = document.createElement('div');
    toast.style.cssText = `
      position: fixed;
      top: 100px;
      right: 20px;
      padding: 16px 24px;
      border-radius: 12px;
      background: ${type === 'error' ? '#ff3b3b' : '#00d4aa'};
      color: white;
      font-weight: 700;
      box-shadow: 0 18px 44px rgba(0,0,0,.55);
      z-index: 300;
      font-family: var(--font-main);
    `;
    toast.textContent = message;
    document.body.appendChild(toast);
    setTimeout(() => toast.remove(), 3000);
  }
  
  showSeatSelection(hydration) {
    console.log('🪑 Showing seat selection on table');
    
    const seatedCount = hydration.seats?.filter(s => s && s.user_id).length || 0;
    const needMore = Math.max(0, 2 - seatedCount);
    const isHost = hydration.room?.host_id === this.userId;
    const mySeated = hydration.me?.seat_index !== undefined;
    
    console.log('🎮 Seat selection state:', {
      seatedCount,
      needMore,
      isHost,
      mySeated,
      hostId: hydration.room?.host_id,
      myUserId: this.userId,
      shouldShowStartButton: seatedCount >= 2 && isHost
    });
    
    // Show seat selection UI in center of table
    const boardArea = document.querySelector('.board-center');
    if (boardArea) {
      boardArea.innerHTML = `
        <div style="text-align: center; padding: 3rem; background: rgba(0,0,0,0.8); border-radius: 20px;">
          <h2 style="color: #fff; font-size: 2.5rem; margin-bottom: 1rem;">🎰 ${mySeated ? 'Waiting for Players' : 'Select Your Seat'}</h2>
          <p style="color: rgba(255,255,255,0.7); margin-bottom: 2rem; font-size: 1.2rem;">
            ${mySeated ? 'Waiting for more players to join...' : 'Click on a seat around the table to claim it'}
          </p>
          <p style="color: var(--teal); font-size: 1rem; margin-bottom: 1rem;">
            Room Code: ${hydration.room?.code || 'N/A'}
          </p>
          <div style="color: rgba(255,255,255,0.5); font-size: 0.9rem; margin-bottom: 2rem;">
            ${seatedCount} / 2 players seated
            ${needMore > 0 ? `(Need ${needMore} more)` : ''}
          </div>
          ${isHost ? `
            <div style="margin-top: 1.5rem;">
          ${seatedCount >= 2 ? `
            <button onclick="window.pokerTable.startGameFromTable()" 
                    class="btn btn-primary" 
                        style="padding: 1.5rem 3rem; font-size: 1.5rem; background: var(--accent); border: none; cursor: pointer; border-radius: 10px; font-weight: bold; margin-bottom: 1rem;">
                  🎮 START HAND
            </button>
                <br>
          ` : ''}
              <button onclick="document.getElementById('hostModal').classList.add('show')" 
                      class="btn btn-secondary" 
                      style="padding: 1rem 2rem; font-size: 1.1rem; background: rgba(255,255,255,0.1); border: 2px solid var(--teal); cursor: pointer; border-radius: 10px; font-weight: bold; color: var(--teal);">
                🛡️ HOST CONTROLS
              </button>
            </div>
          ` : (seatedCount >= 2 ? `
            <div style="color: var(--teal); font-size: 1.2rem; margin-top: 1rem;">
              ⏳ Waiting for host to start the game...
            </div>
          ` : '')}
        </div>
      `;
    }
    
    // Render all seats - occupied and available
    this.applySeatPositions();
    
    // Create seat data array from hydration
    const seatData = [];
    for (let i = 0; i < 9; i++) {
      const seat = hydration.seats && hydration.seats.find(s => s && s.index === i);
      if (seat && seat.user_id) {
        // Seat is occupied
        const isMe = seat.user_id === this.userId;
        seatData.push({
          index: i,
          name: seat.username || `Seat ${i + 1}`,
          chips: parseInt(seat.chips_in_play) || 1000,
          avatar: isMe ? '🦈' : '🎯',
          cards: ['back', 'back'],
          isMe: isMe,
          status: seat.status
        });
      } else {
        // Seat is empty
        seatData.push({
          index: i,
          name: `Seat ${i + 1}`,
          chips: 0,
          avatar: '🪑',
          cards: [],
          isEmpty: true
        });
      }
    }
    
    // Render seats with claiming enabled (CRITICAL: Pass true to make empty seats clickable)
    this.renderSeats(seatData, true);
    
    console.log(`🪑 Seat selection rendered: ${seatData.filter(s => !s.isEmpty).length} occupied, ${seatData.filter(s => s.isEmpty).length} available`);
  }
  
  async claimSeatOnTable(seatIndex) {
    console.log('🪑 Claiming seat on table:', seatIndex);
    
    try {
      // Ask for nickname first
      const nickname = window.prompt(
        `Enter your table nickname for Seat ${seatIndex + 1}:`,
        window.currentUser?.username || window.currentUser?.email?.split('@')[0] || 'Player'
      );
      
      if (!nickname) {
        this.showToast('Seat claiming cancelled', 'info');
        return;
      }
      
      const headers = {
        'Content-Type': 'application/json',
        'X-Idempotency-Key': `seat-${this.roomId}-${this.userId}-${seatIndex}`.substring(0, 63)
      };
      
      const response = await fetch(`/api/rooms/${this.roomId}/join`, {
        method: 'POST',
        headers: headers,
        body: JSON.stringify({
          user_id: this.userId,
          seat_index: seatIndex,
          buy_in_amount: 1000,
          username: nickname
        })
      });
      
      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'Failed to claim seat');
      }
      
      const result = await response.json();
      console.log('✅ Seat claimed!', result);
      this.showToast(`Seat ${seatIndex + 1} claimed! Waiting for all players...`, 'success');
      
      // Broadcast seat update to all players
      if (this.socket && this.socket.connected) {
        this.socket.emit('seat_claimed', { roomId: this.roomId, seatIndex });
      }
      
      // Immediately refresh hydration to get updated seats (no delay!)
      console.log('🔄 Fetching updated seat state...');
      this.lastHydrationTime = 0; // Bypass debounce for immediate update
      await this.fetchHydration();
      
    } catch (error) {
      console.error('❌ Claim seat error:', error);
      this.showToast('Failed to claim seat: ' + error.message, 'error');
    }
  }
  
  async startGameFromTable() {
    console.log('🎮 Starting game from table...');
    
    try {
      this.showToast('Creating game...', 'info');
      
      // Create game
      const gameHeaders = {
        'Content-Type': 'application/json',
        'X-Idempotency-Key': `game-${this.roomId}-${Date.now()}`.substring(0, 63)
      };
      
      const gameResponse = await fetch('/api/games', {
        method: 'POST',
        headers: gameHeaders,
        body: JSON.stringify({
          small_blind: 5,
          big_blind: 10,
          max_players: 10,
          roomId: this.roomId,
          hostUserId: this.userId,
          user_id: this.userId // Required by idempotency middleware
        })
      });
      
      if (!gameResponse.ok) {
        throw new Error('Failed to create game');
      }
      
      const gameData = await gameResponse.json();
      const gameId = gameData.gameId || gameData.id;
      this.gameId = gameId;
      
      console.log('✅ Game created:', gameId);
      
      // Start first hand
      const handHeaders = {
        'Content-Type': 'application/json',
        'X-Idempotency-Key': `hand-${gameId}-${Date.now()}`.substring(0, 63)
      };
      
      // Add auth headers if available
      if (window.authManager) {
        try {
          const authHeaders = await window.authManager.getAuthHeaders();
          Object.assign(handHeaders, authHeaders);
        } catch (e) {
          console.warn('Auth headers not available, continuing anyway');
        }
      }
      
      const handResponse = await fetch(`/api/games/${gameId}/start-hand`, {
        method: 'POST',
        headers: handHeaders,
        body: JSON.stringify({
          roomId: this.roomId,
          user_id: this.userId  // Add user ID for identification
        })
      });
      
      if (!handResponse.ok) {
        const error = await handResponse.json();
        console.error('❌ Start hand failed:', error);
        throw new Error('Failed to start hand: ' + error.error);
      }
      
      console.log('✅ First hand started!');
      this.showToast('Game started! Dealing cards...', 'success');
      
      // Refresh hydration to get cards
      setTimeout(() => this.fetchHydration(), 1500);
      
    } catch (error) {
      console.error('❌ Start game error:', error);
      this.showToast('Failed to start game: ' + error.message, 'error');
    }
  }
}

// Initialize on load
document.addEventListener('DOMContentLoaded', async () => {
  window.pokerTable = new PokerTableGrid();
  await window.pokerTable.init();

  // Demo interactions
  document.querySelectorAll('.quick-bet').forEach(btn => {
    btn.addEventListener('click', (e) => {
      const mult = parseFloat(e.target.dataset.mult);
      const pot = 3450;
      const amount = Math.floor(pot * mult);
      document.getElementById('betInput').value = amount;
      document.getElementById('betSlider').value = amount;
      document.getElementById('raiseAmount').textContent = `$${amount.toLocaleString()}`;
    });
  });

  const slider = document.getElementById('betSlider');
  const input = document.getElementById('betInput');
  
  if (slider && input) {
    slider.addEventListener('input', (e) => {
      input.value = e.target.value;
      const raiseAmt = document.getElementById('raiseAmount');
      if (raiseAmt) raiseAmt.textContent = `$${parseInt(e.target.value).toLocaleString()}`;
    });

    input.addEventListener('input', (e) => {
      slider.value = e.target.value;
      const raiseAmt = document.getElementById('raiseAmount');
      if (raiseAmt) raiseAmt.textContent = `$${parseInt(e.target.value).toLocaleString()}`;
    });
  }

  // Action buttons
  document.querySelectorAll('.action-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const label = btn.querySelector('.btn-label').textContent;
      console.log(`Demo: ${label} clicked`);
    });
  });
});

console.log('✅ Zoom-Locked Poker Table script loaded');
</script>

<!-- Backend Connection Scripts -->
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script src="/socket.io/socket.io.js"></script>
<script src="/js/sequence-tracker.js"></script>
<script src="/js/auth-manager.js"></script>

</body>
</html>
