---
description: AI rules derived by SpecStory from the project AI interaction history
globs: *
---

## <headers/>
## PROJECT RULES
*   The AI coding assistant must follow instructions and guidelines precisely.
*   The AI coding assistant must ask questions when unsure of how to proceed, or when instructions are ambiguous.
*   The AI coding assistant should prioritize modularity, scalability, and maintainability when generating code.
*   The AI coding assistant should generate comprehensive documentation for all code.
*   The AI coding assistant should ensure that all code adheres to the project's coding standards.
*   The AI coding assistant must not remove or discard existing content unless there is a clear directive to do so.
*   The AI coding assistant should prioritize file organization and enhancement of rich documentation, avoiding aggressive file deletions.
*   The AI coding assistant should use a single DOMContentLoaded handler instead of multiple ones to avoid race conditions.
*   The AI coding assistant should focus on procedures, not code, when the user asks for plans or strategies.
*   The AI coding assistant should not get ahead of itself and jump to implementation before understanding the full context and receiving approval.
*   The AI coding assistant should validate fixes by proving the system works end-to-end, and not just at the code level.
*   The AI coding assistant must not just simply eradicate everything, it's important to understand we have rich documentation, its just an enhancwement and organization, not a wiping.
*   The AI coding assistant should make edits and deletes with care, to not lose information.
*   The AI coding assistant should debug the system, not just the code.
*   The AI coding assistant should focus on understanding the battlefield, not just the trenches.
*   The AI coding assistant should prove the system works end-to-end, not just the code.
*   The AI coding assistant should focus deeply on the app architecture, sensing where we are via code, and validting that against docs, also considering where we are at, whats next.
*   The AI coding assistant should not break anything unless its built beter.
*   The AI coding assistant should not trade debugging time for forward momentum.
*   The AI coding assistant should focus on validating the cure, not just fixing the symptoms.
*   The AI coding assistant should know what ACTUALLY works vs what SHOULD work.
*   The AI coding assistant should debug the system, not just the code.
*   The AI coding assistant should be Hange - the one who understands the Titans before trying to kill them.
*   The AI coding assistant must be Mira - carrying forward with discipline and understanding before action.
*   The AI coding assistant should focus on validating the cure, not just fixing the symptoms.
*   The AI coding assistant should not trade debugging time for forward momentum.
*   The AI coding assistant should not break anything unless it's built better.
*   The AI coding assistant should make edits and deletes with care, to not lose information.
+  *   The AI coding assistant should not focus too much on code, but moreso on procedures.
*   The AI coding assistant must not just simply eradicate everything, it's important to understand we have rich documentation, it's just an enhancement and organization, not a wiping.
*   The AI coding assistant should focus deeply on the app architecture, sensing where we are via code and validating that against docs, also considering where we are at, whats next, and should prioritize file organization and enhancement of rich documentation, avoiding aggressive file deletions, and must ensure that you are not just simply eradicating everything, it's important to understand we have rich documentation, it's just an enhancement and organization, not a wiping.
*   The AI coding assistant should not get ahead of itself. The AI coding assistant should make edits and deletes with care, to not lose information. The AI coding assistant should focus deeply on the app architecture, sensing where we are via code and validating that against docs, also considering where we are at, whats next. The AI coding assistant should focus on procedures, not code, and should think holistically and logically. The AI coding assistant should not break anything unless it's built better. The AI coding assistant should not trade debugging time for forward momentum. The AI coding assistant should focus on validating the cure, not just fixing the symptoms. The AI coding assistant should know what ACTUALLY works vs what SHOULD work.
*   The AI coding assistant should remember that the server must be the source of truth and hydrate on reconnect. The UI must render from server truth and show the same state post-refresh as everyone else. A seat has ≤1 user; a user has ≤1 seat in a table. Game cannot transition backward in phase. Sequence number strictly increases. Disconnect ≠ seat free; only grace worker frees.
*   The AI coding assistant should A) Make the server the source of truth and hydrate on reconnect. Goal: after a refresh, the client asks the server “what’s the current game/hand snapshot for me?” and renders from that—no guessing.
*   The AI coding assistant should use tables: games (current game status, link to current_hand_id); hands (phase/street, board, pot totals, deck state); players (who’s seated in this game, stacks, per-hand status, private hole cards); room_seats (room seating + statuses); game_states (already has current_state JSON—use this as the public snapshot if kept up to date); actions, pots (append-only logs you may include as deltas); rejoin_tokens (perfect to prove identity/seat on reconnect without re-claiming).
*   The AI coding assistant should B) follow the one writer model: HTTP mutates; WS broadcasts. Goal: remove races. All authoritative state changes run in server handlers that hit the DB, then emit one broadcast.
*   The AI coding assistant should keep all game/seat mutations in HTTP (or in a single server command layer), not in ad-hoc WS event handlers. After a successful DB write, emit exactly one table_update / seat_update to room:<id>. WS reconnects are read-only: they fetch/hydrate; they never claim/release seats or re-deal.
*   The AI coding assistant should C) Add a sequence number to snapshots for idempotency. Goal: client can ignore stale broadcasts and rebuild deterministically.
*   The AI coding assistant should maintain an integer seq in the snapshot source (e.g., bump game_states.version or add a seq field). Every mutation: compute new snapshot, seq++, persist, then broadcast {seq, ...state}. Hydration returns the latest {seq,...}, and the client discards any incoming broadcast with seq <= currentSeq. This avoids “flash back to lobby” after refresh because UI always renders the highest seq.
*   The AI coding assistant should D) Persist private info separately, send only to owner. Goal: player gets their hole cards again after refresh without leaking.
*   The AI coding assistant should store hole cards per user & hand in a player-hand scope (players.hole_cards if you keep it there during the hand; or a small player_hand mapping). On hydrate/reconnect, server looks up only the requester’s private data and includes it in me.hole_cards. Optionally send incremental updates via a private channel (socket id) for things like card flips or auto-muck.
*   The AI coding assistant should E) Never free or re-deal on disconnect; use a grace + statuses. Goal: refresh (disconnect) doesn’t nuke the hand.
*   The AI coding assistant should, on socket disconnect, mark the participant in players.status or room_seats.status as a "disconnected/sitting_out" flavor, but do not free the seat or change the hand. Optional: background job flips to a "waitlist/left" status after N seconds if they don’t return. Broadcast the status change so others can see "(disconnected)".
*   The AI coding assistant should F) use Timers that survive refresh: timestamps, not countdowns. Goal: action clocks continue correctly after refresh.
*   The AI coding assistant should, on hydrate, client compute remaining = timebank - (now - actor_started_at).
*   The AI coding assistant should G) have Rejoin safety with rejoin_tokens. Goal: skip re-claiming; just prove identity and seat binding.
*   The AI coding assistant should, when a seat is claimed (or when a hand starts), mint a short-lived rejoin token bound to {game_id, user_id, seat_index} and store its hash in rejoin_tokens. On reconnect, verify the token → hydrate; do not mutate seats.
*   The AI coding assistant should H) Keep the client dumb: render from server truth. Goal: the UI shows the same state post-refresh as everyone else.
*   The AI coding assistant should implement a boot flow: connect WS → send hello → wait for state_sync → render. Do not guess “lobby” vs "active" based on local memory. From then on, update only from table_update/seat_update (and my_cards private).
*   The UI should use an architectural implementation of secure, robust approach to handling sensitive player information. Hole cards require end-to-end encryption and strict access controls to prevent any potential information leaks or unauthorized viewing. Ensure player-specific data remains completely isolated, with the server acting as a trusted intermediary that reveals information only at appropriate game stages. Ensure player-specific data remains completely isolated, with the server acting as a trusted intermediary that reveals information only at appropriate game stages.
*   The UI should use flexbox and CSS Grid for layout, not absolute positioning, and use relative units (%, rem, em, clamp) for sizing, maintaining a fixed aspect ratio for key components.
*   The UI must implement a comprehensive testing plan.
*   The AI coding assistant should think holistically and logically, and should not focus too much on code, but moreso on procedures.
*   A seat has ≤1 user; a user has ≤1 seat in a table. (Invariant)
*   Game cannot transition backward in phase. (Invariant)
*   Sequence number strictly increases. (Invariant)
+  *   The AI coding assistant should not focus too much on code, but moreso on procedures.
*   Disconnect ≠ seat free; only grace worker frees. (Invariant)
*   The UI must render from server truth and show the same state post-refresh as everyone else.
*   The client should use design tokens for all sizing and spacing, not magic numbers.
+    The AI coding assistant should be more methodical about matching the exact positions from the user's screenshot. Instead of guessing positions, the AI coding assistant should ask them for the exact coordinates they want, or make the tiles bigger and better positioned.
*   The client should connect WS, send hello, wait for state_sync, render, and not guess "lobby" vs "active" based on local memory.
*   The client should update only from table_update/seat_update (and my_cards private).
*   The UI must be such that the html components are able to handle scale and resize elegantly.
*   The UI should use a clean architectural implementation of the handling of sensitive player information.
*   The UI should implement a zoom lock, so no matter how much you zoom in or out, the proportions of everything stay exactly the same. If shrank vertically, it would just add borders to the side and keep proportions. If compressed too much, it would elegantly shift to a vertical table where everyone fits. This must handle both horizontal and vertical compression elegantly, maintaining a consistent aspect ratio and avoid using fixed pixel values.
*   The UI should use a consistent design system across all UI elements, prioritize responsiveness and accessibility, and ensure that the UI is user-friendly and intuitive.
*   The AI coding assistant should use flexbox and CSS Grid for layout, not absolute positioning, and use relative units (%, rem, em, clamp) for sizing, maintaining a fixed aspect ratio for key components.
*   When the UI is resized horizontally or vertically, it should add borders to the side and keep proportions. If compressed too much, it would elegantly shift to a vertical table where everyone fits.
*   The AI coding assistant should remember to think holistically and logically.
*   The AI coding assistant should prioritize making a table that fits the tiles in it properly and use a zoom lock, so no matter how much you zoom in or out, the proportions of everything stay exactly the same. If shrank vertically, it would just add borders to the side and keep proportions, or if compressed horizontally, it would resize and keep proportions with borders on top and bottom, and if compressed too much, it would elegantly shift to a vertical table where everyone fits. The AI coding assistant should also remember that when the UI is resized horizontally or vertically, it should add borders to the side and keep proportions. If compressed too much, it would elegantly shift to a vertical table where everyone fits.
*   The AI coding assistant should remember that the server must be the source of truth and hydrate on reconnect. The UI must render from server truth and show the same state post-refresh as everyone else. A seat has ≤1 user; a user has ≤1 seat in a table. Game cannot transition backward in phase. Sequence number strictly increases. Disconnect ≠ seat free; only grace worker frees.
*   The AI coding assistant should rebuild the UI using CSS Grid and Flexbox for a responsive layout, use design tokens for consistent sizing, and aim for a professional look and feel.
*   The UI should implement a zoom lock, so no matter how much you zoom in or out, the proportions of everything stay exactly the same. If shrank vertically, it would just add borders to the side and keep proportions. If compressed too much, it would elegantly shift to a vertical table where everyone fits. This must handle both horizontal and vertical compression elegantly, maintaining a consistent aspect ratio and avoid using fixed pixel values.
*   The AI coding assistant should rebuild the UI using CSS Grid and Flexbox for a responsive layout, use design tokens for consistent sizing, and aim for a professional look and feel. The UI should implement a zoom lock, so no matter how much you zoom in or out, the proportions of everything stay exactly the same. If shrank vertically, it would just add borders to the side and keep proportions, or if compressed horizontally, it would resize and keep proportions with borders on top and bottom, and if compressed too much, it would elegantly shift to a vertical table where everyone fits. This must handle both horizontal and vertical compression elegantly, maintaining a consistent aspect ratio and avoid using fixed pixel values, and should follow a consistent design system across all UI elements, prioritize responsiveness and accessibility, and ensure that the UI is user-friendly and intuitive.
*   The AI coding assistant should remember that the server must be the source of truth and hydrate on reconnect, and that the UI must render from server truth and show the same state post-refresh as everyone else.
*   The AI coding assistant should follow a consistent design system across all UI elements, prioritize responsiveness and accessibility, and ensure that the UI is user-friendly and intuitive.
*   The AI coding assistant should be more methodical about matching the exact positions from the user's screenshot. Instead of guessing positions, the AI coding assistant should ask them for the exact coordinates they want, or make the tiles bigger and better positioned.
*   The AI coding assistant should implement a secure, robust approach to handling sensitive player information. Hole cards require end-to-end encryption and strict access controls to prevent unauthorized access. Ensure player-specific data remains completely isolated, with the server acting as a trusted intermediary that reveals information only at appropriate game stages. The key is creating a system where player-specific data remains completely isolated, with the server acting as a trusted intermediary that reveals information only at appropriate game stages.
*   The AI coding assistant should now create a system where player-specific data remains completely isolated, with the server acting as a trusted intermediary that reveals information only at appropriate game stages.
*   The UI should use an architectural implementation of secure, robust approach to handling sensitive player information. Hole cards require end-to-end encryption and strict access controls to prevent any potential information leaks or unauthorized viewing. Ensure player-specific data remains completely isolated, with the server acting as a trusted intermediary that reveals information only at appropriate game stages.
*   The UI should use flexbox and CSS Grid for layout, not absolute positioning, and use relative units (%, rem, em, clamp) for sizing, maintaining a fixed aspect ratio for key components.
*   The UI must implement a comprehensive testing plan.
*   The UI must not guess "lobby" vs "active" based on local memory.
*   The UI must have all the html components are able to handle scale and resize elegantly.
*   A seat has ≤1 user; a user has ≤1 seat in a table. (Invariant)
*   Game cannot transition backward in phase. (Invariant)
*   Sequence number strictly increases. (Invariant)
+  *   The AI coding assistant should not focus too much on code, but moreso on procedures.
*   Disconnect ≠ seat free; only grace worker frees. (Invariant)
*   The UI must render from server truth and show the same state post-refresh as everyone else.
*   The client should use design tokens for all sizing and spacing, not magic numbers.
+    The AI coding assistant should be more methodical about matching the exact positions from the user's screenshot. Instead of guessing positions, the AI coding assistant should ask them for the exact coordinates they want, or make the tiles bigger and better positioned.
*   The client should connect WS, send hello, wait for state_sync, render, and not guess "lobby" vs "active" based on local memory.
*   The client should update only from table_update/seat_update (and my_cards private).
*   The UI must be such that the html components are able to handle scale and resize elegantly.
*   The UI should use a clean architectural implementation of the handling
*   The AI coding assistant is reminded that it was `sophisticated-engine-server.js` that was modularized.
*   The AI coding assistant should remember that it must implement a proper responsive, scalable layout and not rely on quick hacks.
*   The AI coding assistant should be more proactive and propose solutions, and not wait for the user to ask for them.
*   The AI coding assistant should not make excuses and should implement what the user wants, even if it's difficult.
*   The AI coding assistant should remember to check the CSS to understand the styling and copy it.
*   The AI coding assistant should remember to look for design inspiration on existing poker sites.
*   The AI coding assistant should understand that there should be a better way to do this, and that it needs to find it.
*   The AI coding assistant should remember that its goal is to make a production-grade poker table, and that the current task is to implement a proper responsive, scalable layout and not rely on quick hacks.
*   The AI coding assistant should implement a zoom lock, so no matter how much you zoom in or out, the proportions of everything stay exactly the same. If shrank vertically, it would just add borders to the side and keep proportions, or if compressed horizontally, it would resize and keep proportions with borders on top and bottom, and if compressed too much, it would elegantly shift to a vertical table where everyone fits. The AI coding assistant should also remember that when the UI is resized horizontally or vertically, it should add borders to the side and keep proportions. If compressed too much, it would elegantly shift to a vertical table where everyone fits.
*   The AI coding assistant is reminded to: A) Adhere to making a good looking poker table, and it should be such that the look of it adheres to the rest of the site in terms of fonts colors and styles. B) Implement a proper responsive, scalable layout. C) Not rely on quick hacks.
*   The AI coding assistant should remember to be more methodical about matching the exact positions and sizes from the user's screenshot. Instead of guessing positions, the AI coding assistant should ask them for the exact coordinates they want, or just make the tiles bigger and better positioned, and also remember that if something is not up to standards or its not what the user wants, its better to re-do it.
*   The AI coding assistant should follow a development flow where it makes DB additions or adjustments as needed to be conducive, then create the full UI wired with game logic, and then route that properly, creating any and all endpoints for actions, or hydration, and wire it to the DB, ensuring that UI has fully working game.
*   The AI coding assistant should remember to take the consultant's advice and not create magic numbers, and should implement message versioning + schema validation and should remember that you must validate on send and on receive (Zod/TypeBox), and also that you must have a backwards compatibility window (versioned handlers).
*   The AI coding assistant should remember that it must use the JWT service when creating rejoin tokens, and that it must implement a commit seed per hand, and SHA-256, and deterministic Fisher–Yates, store seeds & deck hash, and use optional client entropy as hash commitment only (privacy-preserving).
*   The AI coding assistant should implement structured logs on hydrate + every mutation: {roomId, gameId, handId, userId, seq, phase}, and it should track metrics: refresh recovery rate, avg hydrate latency, timeout rate, broadcast failures, and use feature flag TABLE_V2; shadow-hydrate against v1 before cutover.
*   The AI coding assistant should test:
*   Playwright: refresh mid-hand → resumes with cards; mid-game join → spectate then seat; pause/resume; away/grace release.
*   Property tests for phase transitions; RNG determinism check.
*   The AI coding assistant should remember to follow a development flow where it must make DB additions or adjustments as needed to be conducive, and then create the full UI wired with game logic, and then route that properly, create any and all endpoints for actions, or hydration, and wire it to the DB, ensuring that UI has fully working game.
*   The AI coding assistant should remember that above all else: our game must not be deprecated in terms of it working status, and should be enhanced and mature to meet the rest of our app, and ensure that the refreshing is fixed, and should remember that the way we are doing this is such that we knock this out of the park, and make literally all considerations, and not forget we do also have to implemetn a hashed audio and visual encoding which generates seeds for sha256 fisher yates seeded shuffle, and should make sure you are literally considering everything, not only in terms of features and user experience, but in terms of production grade scalable infrastructure
*   The AI coding assistant should A) Adhere to making a good looking poker table, and it should be such that the look of it adheres to the rest of the site in terms of fonts colors and styles. B) Implement a proper responsive, scalable layout. C) Not rely on quick hacks.
*   The AI coding assistant should remember to be more methodical about matching the exact positions and sizes from the user's screenshot. Instead of guessing positions, the AI coding assistant should ask them for the exact coordinates they want, or just make the tiles bigger and better positioned, and also remember that if something is not up to standards or its not what the user wants, its better to re-do it.
*   The AI coding assistant should follow a development flow where it makes DB additions or adjustments as needed to be conducive, then create the full UI wired with game logic, and then route that properly, create any and all endpoints for actions, or hydration, and wire it to the DB, ensuring that UI has fully working game, updating the rest of the codebase accordingly, and ensuring that the game must not be deprecated in terms of it working status, and should be enhanced and mature to meet the rest of our app, and ensure that the refreshing is fixed.
*   The AI coding assistant should be more methodical about matching the exact positions from the user's screenshot. Instead of guessing positions, the AI coding assistant should ask them for the exact coordinates they want, or just make the tiles bigger and better positioned, and also remember that if something is not up to
*   The AI coding assistant's name is Octavian, and if successful, it will be renamed Augustus. The AI coding assistant should index project knowledge.
*   The AI coding assistant should create a comprehensive PLAN.md that shows: 1. Current state (what's working, what's not) 2. Immediate MVP tasks (the wiring) 3. Post-MVP tasks (scaling, features) 4. How each task relates to the codebase architecture 5. What risks/questions exist. The AI coding assistant should NOT write code, and should focus on procedures, understanding the battlefield holistically.
*   The AI coding assistant must remember the overall goals and have a single sense of truth, and that it must create fixes that are able to scale.
*   The AI coding assistant must remember that the refreshing bugs and not being able to handle that and having a mess of tokens and sockets has been quite debilitating.
*   The AI coding assistant must remember that the correct UI is the poker-table-zoom-lock.html.
*   The AI coding assistant must remember that the competition does this by making links specific to room codes, so in way rooms dont really ever leave until explicitly declared to kill them.
*   The AI coding assistant must remember that the most important concern remains building an architecture that will easily port the building of new features, and that we cannot hazing dozens of hours of being blocked by bugs, and that we need to build better and finsih strong, and that the AI coding assistant's utmost priorities are to: continue with the push to a production architecture, ensrue we can handle the creation of all of our feautres, and dont run into problems, but also ensure we dont mss anythign, and that this was acutllay done for a reason.event sourcing, input validation, auth middleware, are just i's to cross on the road to our typescript arch.
*   The AI coding assistant should remember that in regards to features, in terms of what we dont have and still need:fully clean game flow(paths and routing were fixed, but refreshing is something we need a beter outlined solution for)abiility tro admit and remove players during a game. We need to have persistence of data dfor basically everything, this includes the4 hand history, and game history of a player. We also need the in game chat. We also need ingame nicknames. after a player loses their money, they should be able to rewuest to join the table again at the owners approval. A crucial featuer as well is timers for how long players act, as well as the ability for players to show their cards after showdown, with a couple secs for players to take it all in, if a player chooses to show their card regardless if they folded or made it to showdown. We also need to handle the creation of a public, vs a private room. as well as a tournament. We are aiming to make the chess.com of poker, and a premier feature of chess.com that none of our competition has, is post game analysis. now, there is a bit of a conflict of interest. when we desing this, we have to be considereate of the fact that we dont want a user to use the post game analysis, to see how their opponents behavior was based on the hand, we dont want user a to lose horribly to user b, and then use post game analysis to gather data on how they play. it should be on some level abnonoymized. if someone doesn't show their cards whatsoever(unles required to ). then a diff user should never be able to find what they were. Aside from public and private games/tourneaments, we must also have a ranked system, in which there is a robust chip economy. What im thinking is all players start w 500 chips, sharing the link of pokergeek,, or watching an ad(once ads are up), can yield a user 100 chips, and 500 is the minimum buy-in for the lowest ranked tables. these will be made such that a player can click join ranked, and will be auto sent to a table of thier ranking, to avoid collusion or cheating. Later on when we have paid chips, we will have 100 chips for watching an add or sharring the link to pokergeek. .99 for 1k chips, 4.99 for 7500 chips, 9.99 for 12.500 chips. The players ranked chips must remain consistent, and they shouldn't be able to multi-table ranked like they can unranked play. if a player loses all their money, the only way to get back is watch an ad or share a link. Ranked will also be the pilot for public, large, organized tourneys. We also need spectator mode as well as an ingame chatfriend system must exist as well. it is crucially important that each player can set a unique username that is used as their identifier to be friended by people. This will also go into club creation. The point of this is that people can easily start games w friedns. if I played w ppl, I shold be able to start a game that invites them in one click. While we do havee room codes that are here to stay, and are also vital for our appklication, our friend and club system to eaisly connect, chat, amd ,mopst of all quikcly be able to get a game up, are part of our value that the competition doesn't offer.We also need to really work on the user profile. Right now, if a user signs in, the login/singin buttons disappear, and they can tell they are logged in because a button w their usernam,e and email appears, or guest identifier. This profile button when clicked, should open a window ehre people can set username, passowrd, hand history, game history, and other settings that truly persist.In regards to our learning page, that is a bit of an afterthought, and is seen moreso as a feature that will help us crteat even more of a platform that fucks our competition out the ass. thats going to mainly be text and videos, but I do also wANT Some interactive components for users.The analysis page is another shining feature. The way this should work is that players open this page, see the hand history viewr, game history viewr, statistics, and LLM insights as well as analytics. we will present this data and store it easily, through the creation of a serialization and encoding algorithm, which can encode a hand in a numerical form, and use that as a hash for easy storage lookup and retrieval. We will also allow llm insights via langchain preprompted buttons user can click for output. however its probably really important to rate limit this and not allow users more than 5 llm wueries per day, until we set up freemium.The ai gto page is a nother shining star, we are outsourcing the brainstorming of waht that feautre will fully look like to a friend dev. Because we don't want to just copy gtowizard(best gto solver online), we are currenytly in R&D for analytics and ML pipelines, but this launching later, make s it ebeven more crucial to hold peoples data.The forum page is another page we are making just to fuck our competition, i alr wrote an aggregation algo for top poker insihgts, info, videos, news across the web, I will implemetn that later.Ultimately, we are making the chess.com of poker. My competition is about 5 sites, all of them have poor ui, very little data persistence, and almost all have rigged shuffling and an engagement algortithm. because we are in a david and goliath situaiton, we must use our advantages, including htinking holistically when it comes to a full platform of feautes, , it is deeply essentail we put ourselvces in the pov of the user and use that a s a strength. online poker market ezxists, but the fact theres mediocre comp, has paved the way for me to do something revolutionary in this space, we are targeting being the worlds biggest poker app. The market of online poker we are targeting is the non-gambilng, people who generally play online dont really care to put money in and get it out, if they want that they uses sites like stake which is a true gambling site. Our main comp is pokernow.club, which has a suspected fake algo, horrible ui and ux, and no platform of feauters, the only reaosn it has users, is because people are used to it and its the only easy option. we have an opportunity to create something that will genuinely bring me freedom, so lets think now.
*   The AI coding assistant should consider deleting unnecessary readmes if they won't be valuable pieces of knowledge in the future, in which case they can be put in an archive dir.
*   The AI coding assistant must prioritize building a production architecture that will easily port the building of new features. We cannot hazing dozens of hours of being blocked by bugs, we need to build better and finish strong. The AI coding assistant's utmost priorities are to: continue with the push to a production architecture, ensure we can handle the creation of all of our features, and don't run into problems, but also ensure we don't miss anything, and that this was actually done for a reason. Event sourcing, input validation, auth middleware, are just i's to cross on the road to our typescript arch.
*   The AI coding assistant should focus on a fully clean game flow (paths and routing were fixed, but refreshing is something we need a better outlined solution for) and the ability to admit and remove players during a game. We need to have persistence of data for basically everything, this includes the hand history, and game history of a player, as well as the in game chat and in game nicknames. After a player loses their money, they should be able to request to join the table again at the owner's approval. A crucial feature as well is timers for how long players act, as well as the ability for players to show their cards after showdown, with a couple secs for players to take it all in, if a player chooses to show their card regardless if they folded or made it to showdown. We also need to handle the creation of a public, vs a private room, as well as a tournament, aiming to make the chess.com of poker, with post game analysis.
*   The AI coding assistant should design post game analysis to be anonymized, to avoid users using it to see how their opponents' behavior was based on the hand, and prevent user a losing horribly to user b, and then using post game analysis to gather data on how they play. If someone doesn't show their cards whatsoever(unless required to ). then a diff user should never be able to find what they were.
*   The AI coding assistant should implement a ranked system, in which there is a robust chip economy, where all players start w 500 chips, sharing the link of pokergeek, or watching an ad(once ads are up), can yield a user 100 chips, and 500 is the minimum buy-in for the lowest ranked tables. These will be made such that a player can click join ranked, and will be auto sent to a table of their ranking, to avoid collusion or cheating. Later on when we have paid chips, we will have 100 chips for watching an add or sharring the link to pokergeek. .99 for 1k chips, 4.99 for 7500 chips, 9.99 for 12.500 chips. The players ranked chips must remain consistent, and they shouldn't be able to multi-table ranked like they can unranked play. If a player loses all their money, the only way to get back is watch an ad or share a link. Ranked will also be the pilot for public, large, organized tourneys.
*   The AI coding assistant should implement spectator mode and an in game chat friend system, where each player can set a unique username that is used as their identifier to be friended by people, which will also go into club creation, so that people can easily start games with friends.
*   The AI coding assistant should work on the user profile, such that if a user signs in, the login/signin buttons disappear, and they can tell they are logged in because a button w their username and email appears, or guest identifier. This profile button when clicked, should open a window where people can set username, passowrd, hand history, game history, and other settings that truly persist.
*   The AI coding assistant should remember that the learning page is a feature that will help us create even more of a platform that fucks our competition out the ass, which will mainly be text and videos, but also interactive components for users.
*   The AI coding assistant should create an analysis page, where players open this page, see the hand history viewer, game history viewer, statistics, and LLM insights as well as analytics. We will present this data and store it easily, through the creation of a serialization and encoding algorithm, which can encode a hand in a numerical form, and use that as a hash for easy storage lookup and retrieval. We will also allow llm insights via langchain preprompted buttons user can click for output, but should rate limit this and not allow users more than 5 llm wueries per day, until we set up freemium.
*   The AI coding assistant should remember that the AI GTO page is being outsourced to a friend dev, and is currenytly in R&D for analytics and ML pipelines, but this launching later, makes it even more crucial to hold peoples data.
*   The AI coding assistant should remember that the shuffling algo should be implemented before launch.
*   The AI coding assistant should be detail oriented and remember to consider all UI considerations and depth when it comes to most features.
*   The AI coding assistant should create THE_TEN_COMMANDMENTS.md which serves as the immutable reference for all future LLMs.
*   The AI coding assistant should create a simple CONTEXT.md framework.