---
description: AI rules derived by SpecStory from the project AI interaction history
globs: *
---

## <headers/>
## PROJECT RULES
*   The AI coding assistant must follow instructions and guidelines precisely.
*   The AI coding assistant must ask questions when unsure of how to proceed, or when instructions are ambiguous.
*   The AI coding assistant should prioritize modularity, scalability, and maintainability when generating code.
*   The AI coding assistant should generate comprehensive documentation for all code.
*   The AI coding assistant should ensure that all code adheres to the project's coding standards.
*   The AI coding assistant must not remove or discard existing content unless there is a clear directive to do so.
*   The AI coding assistant should use a single DOMContentLoaded handler instead of multiple ones to avoid race conditions.
## TECH STACK
*   Node.js
*   Express
*   PostgreSQL (Supabase)
*   Socket.IO
*   TypeScript (for game engine)
*   Vanilla JavaScript (for now, transition to React/Vue/Svelte considered)
*   bcrypt
*   cors
*   dotenv
*   zod
*   express-rate-limit
*   CDN for Socket.IO and Supabase client

## PROJECT DOCUMENTATION & CONTEXT SYSTEM
*   The project uses markdown files for documentation.
*   Key files include: `README.md`, `ARCHITECTURE_MIGRATION_GUIDE.md`, `PROJECT_MASTER.md`, and various files in the `archive/docs-history/` directory.
*   When creating new documentation, use clear and concise language.
*   Always provide context and reasoning for design decisions.
*   Reference existing documentation where appropriate.
*   All files should be carefully organized and named for easy retrieval.
*   Root Directory (KEEP 4 CORE DOCS):
    ```
    README.md                    ← Quick start, project overview
    PRODUCTION_BATTLEPLAN.md     ← THIS DOCUMENT (replaces 12 others)
    Schemasnapshot.txt           ← Database reference
    .env.example                 ← Config template
    ```

## WORKFLOW & RELEASE RULES
*   All code must be reviewed before merging.
*   Automated tests should be implemented for all core functionality.
*   Use feature flags to enable/disable new features in production.
*   Monitor key metrics to track performance and identify issues.
*   Implement a rollback strategy for any new deployment.
*   Strive for continuous integration and continuous delivery (CI/CD).
*   Always make sure new code does not break existing functionality.

## DEBUGGING
*   Use structured logging for all components.
*   Include trace IDs to track requests across services.
*   Monitor key metrics to identify performance bottlenecks.
*   Implement a robust error handling strategy.
*   When debugging the refresh bug, follow the steps outlined in SYSTEM_ARCHITECTURE_MAP.md.
*   When debugging new features, check the server logs and browser console for errors.
## CODING STANDARDS
*   Follow the principle of least privilege.
*   Validate all inputs.
*   Use prepared statements to prevent SQL injection.
*   Hash passwords using bcrypt.
*   Enforce rate limits to prevent abuse.
*   Use JWT tokens for authentication.
*   Enable CORS to allow cross-origin requests.
*   Use `app.locals` for dependency injection.
*   Follow a modular architecture with well-defined components.
*   Use TypeScript for the game engine to ensure type safety.
## FRONTEND GUIDELINES
*   Use Vanilla JavaScript for now. Transition to a component-based framework like React/Vue/Svelte is under consideration.
*   Follow a "dumb client" architecture - the client should only render what the server tells it.
*   Use optimistic updates to improve perceived performance.
*   Implement proper state management using a library like Zustand or Redux.
*   Ensure that the UI is responsive and accessible.
## DATABASE GUIDELINES
*   Use PostgreSQL with Supabase.
*   Implement a dual-write pattern to ensure data persistence.
*   Use a consistent naming convention for tables and columns.
*   Foreign key relationships must be enforced.
*   Use JSONB columns for flexible data storage.
*   Enable row-level security (RLS) to protect data.
*   Implement database migrations for schema changes.
*   Use connection pooling to improve performance.
*   Keep database transactions short and atomic.
## DEPRECATED
*   The strategy of aggressive file deletions should not be followed. Rich documentation should be organized and enhanced instead.