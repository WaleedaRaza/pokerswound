-- Extensions (safe if already installed)
create extension if not exists pgcrypto;

-- Hands table (per-hand state)
create table if not exists public.hands (
  id uuid primary key default gen_random_uuid(),
  game_id uuid not null references public.games(id) on delete cascade,
  hand_no int not null,
  dealer_btn int not null,
  sb_pos int not null,
  bb_pos int not null,
  current_street text not null check (current_street in ('PREFLOP','FLOP','TURN','RIVER','SHOWDOWN')),
  to_act_player_id uuid references public.players(id) on delete set null,
  started_at timestamptz not null default now(),
  ended_at timestamptz,
  deck_seed text,
  version int not null default 0,
  unique (game_id, hand_no)
);

create index if not exists idx_hands_game on public.hands (game_id);
create index if not exists idx_hands_game_no on public.hands (game_id, hand_no);

-- Players seating/flags
alter table public.players add column if not exists active boolean not null default true;
alter table public.players add column if not exists left_at timestamptz;
alter table public.players add column if not exists rejoin_token uuid;
create index if not exists idx_players_game_seat on public.players (game_id, seat_index);

-- Games optimistic version
alter table public.games add column if not exists version int not null default 0;

-- Pots and contributions
create table if not exists public.pots (
  id bigint generated by default as identity primary key,
  hand_id uuid not null references public.hands(id) on delete cascade,
  pot_index int not null,
  cap_amount int,
  unique (hand_id, pot_index)
);
create index if not exists idx_pots_hand on public.pots (hand_id);

create table if not exists public.pot_contributions (
  id bigint generated by default as identity primary key,
  pot_id bigint not null references public.pots(id) on delete cascade,
  player_id uuid not null references public.players(id) on delete cascade,
  contributed int not null check (contributed >= 0),
  unique (pot_id, player_id)
);
create index if not exists idx_pot_contrib_pot_player on public.pot_contributions (pot_id, player_id);

-- Link logs & snapshots to hand and add strict ordering
alter table public.game_actions add column if not exists hand_id uuid references public.hands(id) on delete cascade;
alter table public.game_actions add column if not exists seq bigint generated by default as identity;
create index if not exists idx_actions_hand_seq on public.game_actions (hand_id, seq);

alter table public.game_histories add column if not exists hand_id uuid references public.hands(id) on delete cascade;
create index if not exists idx_histories_hand_time on public.game_histories (hand_id, created_at);

-- RLS: helper function to check membership in a game
create or replace function public.is_player_in_game(gid uuid)
returns boolean
language sql
stable
as $$
  select exists (
    select 1
    from public.players p
    where p.game_id = gid and p.user_id = auth.uid()
  );
$$;

-- Enable RLS
alter table public.games enable row level security;
alter table public.players enable row level security;
alter table public.game_actions enable row level security;
alter table public.game_histories enable row level security;
alter table public.hands enable row level security;
alter table public.pots enable row level security;
alter table public.pot_contributions enable row level security;

-- Policies: read access for authenticated users; writes via service role only
-- Games: allow authenticated users to list/read games (adjust later if you add is_public)
create policy if not exists games_select_auth on public.games
  for select using (true);

-- Players: a user can read their own player rows
create policy if not exists players_select_self on public.players
  for select using (user_id = auth.uid());

-- Hands: readable if the user is seated in the game
create policy if not exists hands_select_in_game on public.hands
  for select using (public.is_player_in_game(game_id));

-- Actions/Histories: readable if user is in the hand's game
create policy if not exists actions_select_in_game on public.game_actions
  for select using (
    hand_id is null OR exists (
      select 1 from public.hands h where h.id = hand_id and public.is_player_in_game(h.game_id)
    )
  );

create policy if not exists histories_select_in_game on public.game_histories
  for select using (
    hand_id is null OR exists (
      select 1 from public.hands h where h.id = hand_id and public.is_player_in_game(h.game_id)
    )
  );

-- Pots and contributions: readable if user in game
create policy if not exists pots_select_in_game on public.pots
  for select using (
    exists (select 1 from public.hands h where h.id = hand_id and public.is_player_in_game(h.game_id))
  );

create policy if not exists pot_contrib_select_in_game on public.pot_contributions
  for select using (
    exists (
      select 1 from public.pots pt
      join public.hands h on h.id = pt.hand_id
      where pt.id = pot_id and public.is_player_in_game(h.game_id)
    )
  );

-- NOTE: inserts/updates/deletes are intentionally not granted; use service role (bypasses RLS)
