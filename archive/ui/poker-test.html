<!DOCTYPE html>
<html>
<head>
    <title>üé∞ Modern Poker Lounge</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #334155 100%);
            color: #f1f5f9;
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Header */
        .header {
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(148, 163, 184, 0.1);
            padding: 1rem 2rem;
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1400px;
            margin: 0 auto;
        }

        .logo {
            font-size: 1.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, #10b981, #3b82f6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header-controls {
            display: flex;
            gap: 1rem;
        }

        /* Main Layout */
        .main-container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 1rem;
            display: grid;
            grid-template-rows: auto 1fr auto;
            min-height: calc(100vh - 80px);
            gap: 1rem;
        }

        /* Game Setup Panel - Compact */
        .setup-panel {
            background: rgba(30, 41, 59, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(148, 163, 184, 0.1);
            border-radius: 1rem;
            padding: 1rem;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .setup-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            align-items: center;
        }

        .setup-section h3 {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: #10b981;
        }

        /* MASSIVE Poker Table - Main Focus */
        .poker-table-container {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 75vh;
            padding: 1rem;
        }

        .poker-table {
            width: 100%;
            max-width: 1600px;
            aspect-ratio: 16/10;
            background: linear-gradient(135deg, #0f5132 0%, #198754 50%, #20c997 100%);
            border-radius: 3rem;
            position: relative;
            box-shadow: 
                0 0 0 12px rgba(30, 41, 59, 0.9),
                0 0 0 16px rgba(148, 163, 184, 0.2),
                0 30px 80px rgba(0, 0, 0, 0.5),
                inset 0 2px 0 rgba(255, 255, 255, 0.15);
            overflow: hidden;
            min-height: 900px;
        }

        .poker-table::before {
            content: '';
            position: absolute;
            inset: 0;
            background: 
                radial-gradient(ellipse at center, transparent 30%, rgba(0, 0, 0, 0.1) 70%),
                linear-gradient(45deg, rgba(255, 255, 255, 0.05) 0%, transparent 50%);
            pointer-events: none;
        }

        /* Table Center */
        .table-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 10;
        }

        .pot-display {
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(15px);
            border: 3px solid rgba(255, 193, 7, 0.6);
            border-radius: 1.5rem;
            padding: 1.5rem 3rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 6px 30px rgba(255, 193, 7, 0.3);
        }

        .pot-amount {
            font-size: 3rem;
            font-weight: 700;
            color: #ffc107;
            text-shadow: 0 3px 15px rgba(255, 193, 7, 0.6);
        }

        .pot-label {
            font-size: 0.875rem;
            color: #94a3b8;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        /* Community Cards */
        .community-cards {
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .card {
            width: 100px;
            height: 140px;
            background: #fff;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.2rem;
            color: #1e293b;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5);
            border: 3px solid rgba(148, 163, 184, 0.4);
            position: relative;
            overflow: hidden;
        }

        .card.placeholder {
            background: rgba(51, 65, 85, 0.6);
            border: 2px dashed rgba(148, 163, 184, 0.3);
            color: #64748b;
        }

        /* Player Seats */
        .player-seats {
            position: absolute;
            inset: 0;
        }

        .player-seat {
            position: absolute;
            width: 220px;
            transform: translate(-50%, -50%);
        }

        /* Seat Positions for 10-Player Rounded Square Table */
        .player-seat:nth-child(1) { top: 8%; left: 50%; } /* Top Center */
        .player-seat:nth-child(2) { top: 12%; right: 20%; transform: translate(50%, -50%); } /* Top Right */
        .player-seat:nth-child(3) { top: 30%; right: 3%; transform: translate(50%, -50%); } /* Middle Right */
        .player-seat:nth-child(4) { top: 55%; right: 3%; transform: translate(50%, -50%); } /* Lower Right */
        .player-seat:nth-child(5) { bottom: 12%; right: 20%; transform: translate(50%, 50%); } /* Bottom Right */
        .player-seat:nth-child(6) { bottom: 8%; left: 50%; transform: translate(-50%, 50%); } /* Bottom Center */
        .player-seat:nth-child(7) { bottom: 12%; left: 20%; transform: translate(-50%, 50%); } /* Bottom Left */
        .player-seat:nth-child(8) { top: 55%; left: 3%; transform: translate(-50%, -50%); } /* Lower Left */
        .player-seat:nth-child(9) { top: 30%; left: 3%; transform: translate(-50%, -50%); } /* Middle Left */
        .player-seat:nth-child(10) { top: 12%; left: 20%; transform: translate(-50%, -50%); } /* Top Left */

        .player-card {
            background: rgba(30, 41, 59, 0.95);
            backdrop-filter: blur(20px);
            border: 2px solid rgba(148, 163, 184, 0.3);
            border-radius: 1.5rem;
            padding: 1.2rem;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            transition: all 0.3s ease;
            position: relative;
            font-size: 1rem;
            min-height: 140px;
        }

        .player-card.active {
            border-color: #10b981;
            box-shadow: 0 0 20px rgba(16, 185, 129, 0.4);
        }

        .player-card.to-act {
            border-color: #ffc107;
            box-shadow: 0 0 20px rgba(255, 193, 7, 0.4);
            animation: pulse-glow 2s infinite;
        }

        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 0 20px rgba(255, 193, 7, 0.4); }
            50% { box-shadow: 0 0 30px rgba(255, 193, 7, 0.8); }
        }

        .player-name {
            font-weight: 600;
            font-size: 1.1rem;
            margin-bottom: 0.5rem;
            color: #f1f5f9;
        }

        .player-stack {
            font-size: 1.4rem;
            font-weight: 700;
            color: #10b981;
            margin-bottom: 0.5rem;
        }

        .player-status {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #64748b;
            margin-bottom: 0.5rem;
        }

        .player-cards {
            display: flex;
            justify-content: center;
            gap: 4px;
            margin-top: 0.5rem;
        }

        .player-card-small {
            width: 55px;
            height: 77px;
            background: #fff;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.875rem;
            font-weight: bold;
            color: #1e293b;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(148, 163, 184, 0.3);
        }

        .hand-strength {
            font-size: 0.75rem;
            color: #10b981;
            margin-top: 0.5rem;
            font-weight: 600;
        }

        /* Beautiful Player Avatars */
        .player-avatar {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 0.75rem auto;
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.3);
            border: 3px solid rgba(255, 255, 255, 0.2);
            font-size: 1.5rem;
            font-weight: 700;
            color: white;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            position: relative;
            overflow: hidden;
        }

        .player-avatar::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            animation: avatar-shine 3s ease-in-out infinite;
        }

        @keyframes avatar-shine {
            0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); }
            50% { transform: translateX(0%) translateY(0%) rotate(45deg); }
            100% { transform: translateX(100%) translateY(100%) rotate(45deg); }
        }

        /* Avatar Colors for Different Players */
        .player-avatar.avatar-1 { background: linear-gradient(135deg, #ef4444, #dc2626); box-shadow: 0 4px 15px rgba(239, 68, 68, 0.3); }
        .player-avatar.avatar-2 { background: linear-gradient(135deg, #10b981, #059669); box-shadow: 0 4px 15px rgba(16, 185, 129, 0.3); }
        .player-avatar.avatar-3 { background: linear-gradient(135deg, #f59e0b, #d97706); box-shadow: 0 4px 15px rgba(245, 158, 11, 0.3); }
        .player-avatar.avatar-4 { background: linear-gradient(135deg, #8b5cf6, #7c3aed); box-shadow: 0 4px 15px rgba(139, 92, 246, 0.3); }
        .player-avatar.avatar-5 { background: linear-gradient(135deg, #ec4899, #db2777); box-shadow: 0 4px 15px rgba(236, 72, 153, 0.3); }
        .player-avatar.avatar-6 { background: linear-gradient(135deg, #06b6d4, #0891b2); box-shadow: 0 4px 15px rgba(6, 182, 212, 0.3); }
        .player-avatar.avatar-7 { background: linear-gradient(135deg, #84cc16, #65a30d); box-shadow: 0 4px 15px rgba(132, 204, 22, 0.3); }
        .player-avatar.avatar-8 { background: linear-gradient(135deg, #f97316, #ea580c); box-shadow: 0 4px 15px rgba(249, 115, 22, 0.3); }
        .player-avatar.avatar-9 { background: linear-gradient(135deg, #6366f1, #4f46e5); box-shadow: 0 4px 15px rgba(99, 102, 241, 0.3); }
        .player-avatar.avatar-10 { background: linear-gradient(135deg, #14b8a6, #0d9488); box-shadow: 0 4px 15px rgba(20, 184, 166, 0.3); }

        /* Modern Controls - Compact */
        .controls-panel {
            background: rgba(30, 41, 59, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(148, 163, 184, 0.1);
            border-radius: 1rem;
            padding: 1rem;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
        }

        .control-section h3 {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: #10b981;
        }

        /* Modern Buttons */
        .btn {
            background: linear-gradient(135deg, #1e293b, #334155);
            color: #f1f5f9;
            border: 1px solid rgba(148, 163, 184, 0.2);
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            cursor: pointer;
            font-size: 0.875rem;
            font-weight: 600;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s ease;
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-primary {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            border-color: #3b82f6;
        }

        .btn-success {
            background: linear-gradient(135deg, #10b981, #059669);
            border-color: #10b981;
        }

        .btn-warning {
            background: linear-gradient(135deg, #f59e0b, #d97706);
            border-color: #f59e0b;
        }

        .btn-danger {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            border-color: #ef4444;
        }

        /* Modern Inputs */
        .form-input {
            background: rgba(51, 65, 85, 0.6);
            border: 1px solid rgba(148, 163, 184, 0.2);
            border-radius: 0.5rem;
            padding: 0.75rem;
            color: #f1f5f9;
            font-size: 0.875rem;
            transition: all 0.3s ease;
            width: 100%;
            margin-bottom: 0.5rem;
        }

        .form-input:focus {
            outline: none;
            border-color: #10b981;
            box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.1);
        }

        .form-input::placeholder {
            color: #64748b;
        }

        /* Status Messages */
        .status-message {
            padding: 1rem;
            border-radius: 0.75rem;
            margin: 1rem 0;
            font-weight: 500;
        }

        .status-success {
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid rgba(16, 185, 129, 0.3);
            color: #10b981;
        }

        .status-error {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            color: #ef4444;
        }

        .status-warning {
            background: rgba(245, 158, 11, 0.1);
            border: 1px solid rgba(245, 158, 11, 0.3);
            color: #f59e0b;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .main-container {
                padding: 1rem;
                grid-template-rows: auto auto 1fr auto;
            }
            
            .poker-table {
                max-width: 100%;
                aspect-ratio: 4/3;
            }
            
            .player-seat {
                width: 120px;
            }
            
            .controls-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Winner Announcement */
        .winner-announcement {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #ffc107, #ff8f00);
            color: #000;
            padding: 1rem 2rem;
            border-radius: 1rem;
            font-weight: 700;
            text-align: center;
            box-shadow: 0 8px 30px rgba(255, 193, 7, 0.4);
            z-index: 100;
            animation: winner-bounce 0.6s ease-out;
        }

        @keyframes winner-bounce {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.1); }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
    </style>
    

    
    <!-- BULLETPROOF CARD MAPPING SYSTEM -->
    <script>
        // üé¥ COMPREHENSIVE CARD MAPPING SYSTEM - FIXED FOR SERVER FORMAT (Suit + Rank)
        const CARD_MAPPING = {
            // Spades (S) - Server sends: S5, S3, SK, S9
            'SA': 'spades_A.png', 'S2': 'spades_2.png', 'S3': 'spades_3.png', 'S4': 'spades_4.png',
            'S5': 'spades_5.png', 'S6': 'spades_6.png', 'S7': 'spades_7.png', 'S8': 'spades_8.png',
            'S9': 'spades_9.png', 'ST': 'spades_10.png', 'SJ': 'spades_J.png', 'SQ': 'spades_Q.png', 'SK': 'spades_K.png',
            
            // Hearts (H) - Server sends: H2, H3, etc.
            'HA': 'hearts_A.png', 'H2': 'hearts_2.png', 'H3': 'hearts_3.png', 'H4': 'hearts_4.png',
            'H5': 'hearts_5.png', 'H6': 'hearts_6.png', 'H7': 'hearts_7.png', 'H8': 'hearts_8.png',
            'H9': 'hearts_9.png', 'HT': 'hearts_10.png', 'HJ': 'hearts_J.png', 'HQ': 'hearts_Q.png', 'HK': 'hearts_K.png',
            
            // Diamonds (D) - Server sends: DK, D2, etc.
            'DA': 'diamonds_A.png', 'D2': 'diamonds_2.png', 'D3': 'diamonds_3.png', 'D4': 'diamonds_4.png',
            'D5': 'diamonds_5.png', 'D6': 'diamonds_6.png', 'D7': 'diamonds_7.png', 'D8': 'diamonds_8.png',
            'D9': 'diamonds_9.png', 'DT': 'diamonds_10.png', 'DJ': 'diamonds_J.png', 'DQ': 'diamonds_Q.png', 'DK': 'diamonds_K.png',
            
            // Clubs (C) - Server sends: CQ, C2, etc.
            'CA': 'clubs_A.png', 'C2': 'clubs_2.png', 'C3': 'clubs_3.png', 'C4': 'clubs_4.png',
            'C5': 'clubs_5.png', 'C6': 'clubs_6.png', 'C7': 'clubs_7.png', 'C8': 'clubs_8.png',
            'C9': 'clubs_9.png', 'CT': 'clubs_10.png', 'CJ': 'clubs_J.png', 'CQ': 'clubs_Q.png', 'CK': 'clubs_K.png'
        };
        
        // AGGRESSIVE CACHE BUSTER - Force image reload
        const CACHE_BUSTER = '?v=' + Date.now() + '&cb=' + Math.random();
        
        // Get card image URL with cache busting and DEBUGGING
        function getCardImageUrl(cardCode) {
            if (!cardCode) return '';
            
            const imageName = CARD_MAPPING[cardCode];
            if (!imageName) {
                console.warn(`No mapping for card: ${cardCode} - using card back`);
                return `cards/back_dark.png${CACHE_BUSTER}`;
            }
            
            const imageUrl = `cards/${imageName}${CACHE_BUSTER}`;
            console.log(`üé¥ Loading card: ${cardCode} -> ${imageUrl}`);
            return imageUrl;
        }
        
        // Create card element with image and ERROR HANDLING
        function createCardElement(cardCode, isHidden = false) {
            const cardDiv = document.createElement('div');
            cardDiv.className = 'card';
            
            if (isHidden) {
                cardDiv.innerHTML = `<img src="cards/back_dark.png${CACHE_BUSTER}" alt="Card Back" class="card-image" onerror="console.error('‚ùå Failed to load card back')">`;
            } else {
                const imageUrl = getCardImageUrl(cardCode);
                cardDiv.innerHTML = `<img src="${imageUrl}" alt="${cardCode}" class="card-image" onerror="console.error('‚ùå Failed to load card: ${cardCode} from ${imageUrl}')" onload="console.log('‚úÖ Loaded card: ${cardCode}')">`;
            }
            
            return cardDiv;
        }
        
        // Display cards with images
        function displayCardsWithImages(container, cards, isHidden = false) {
            container.innerHTML = '';
            
            if (!cards || cards.length === 0) {
                container.innerHTML = '<div class="card placeholder">?</div>';
                return;
            }
            
            cards.forEach(cardCode => {
                const cardElement = createCardElement(cardCode, isHidden);
                container.appendChild(cardElement);
            });
        }
        
        // Preload all card images
        function preloadCardImages() {
            const imagePromises = [];
            
            Object.values(CARD_MAPPING).forEach(imageName => {
                const img = new Image();
                const promise = new Promise((resolve, reject) => {
                    img.onload = resolve;
                    img.onerror = reject;
                });
                img.src = `cards/${imageName}${CACHE_BUSTER}`;
                imagePromises.push(promise);
            });
            
            // Also preload card backs
            ['back_dark.png', 'back_light.png'].forEach(imageName => {
                const img = new Image();
                const promise = new Promise((resolve, reject) => {
                    img.onload = resolve;
                    img.onerror = reject;
                });
                img.src = `cards/${imageName}${CACHE_BUSTER}`;
                imagePromises.push(promise);
            });
            
            return Promise.allSettled(imagePromises);
        }
        
        // Initialize card system
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üé¥ Initializing Card System...');
            
            // Test card parsing
            console.log('üß™ Testing card parsing:');
            ['CQ', 'S5', 'DK', 'H2', 'ST'].forEach(card => {
                const parsed = parseCard(card);
                console.log(`  ${card} -> ${parsed ? `${parsed.rank}${parsed.suit}` : 'FAILED'}`);
            });
            
            preloadCardImages().then(results => {
                const loaded = results.filter(r => r.status === 'fulfilled').length;
                const failed = results.filter(r => r.status === 'rejected').length;
                console.log(`üé¥ Card Images: ${loaded} loaded, ${failed} failed`);
            });
        });
    </script>
    
    <style>
        /* Card Image Styles */
        .card-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s ease;
        }
        
        .card-image:hover {
            transform: scale(1.05);
        }
        
        .player-cards {
            display: flex;
            gap: 4px;
            margin-top: 8px;
            justify-content: center;
        }
        
        .player-cards .card {
            width: 55px;
            height: 77px;
            font-size: 14px;
        }
        
        .player-card-small {
            width: 55px;
            height: 77px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <div class="header-content">
            <div class="logo">üé∞ Modern Poker Lounge</div>
            <div class="header-controls">
                <button class="btn btn-primary" onclick="checkServerHealth()">üè• Health</button>
                <button class="btn" onclick="resetGame()">üîÑ Reset</button>
            </div>
        </div>
    </div>

    <!-- Main Container -->
    <div class="main-container">
        <!-- Game Setup Panel -->
        <div class="setup-panel">
            <div class="setup-grid">
                <div class="setup-section">
                    <h3>üéÆ Create Game</h3>
                    <input type="number" class="form-input" id="smallBlind" placeholder="Small Blind" value="1">
                    <input type="number" class="form-input" id="bigBlind" placeholder="Big Blind" value="2">
                    <input type="number" class="form-input" id="maxPlayers" placeholder="Max Players" value="10" max="10">
                    <button class="btn btn-success" onclick="createGame()">Create Game</button>
                </div>
                
                <div class="setup-section">
                    <h3>üë§ Add Player</h3>
                    <input type="text" class="form-input" id="playerName" placeholder="Player Name">
                    <input type="number" class="form-input" id="buyInAmount" placeholder="Buy-in Amount" value="100">
                    <button class="btn btn-primary" onclick="addPlayer()" id="addPlayerBtn" disabled>Join Game</button>
                </div>
                
                <div class="setup-section">
                    <h3>üé≤ Game Status</h3>
                    <div id="gameStatus" class="status-message">Ready to create a game!</div>
                    <button class="btn btn-warning" onclick="startHand()" id="startHandBtn" disabled>üÉè Start Hand</button>
                </div>
            </div>
        </div>

        <!-- Modern Poker Table -->
        <div class="poker-table-container">
            <div class="poker-table">
                <!-- Table Center -->
                <div class="table-center">
                    <div class="pot-display">
                        <div class="pot-label">Total Pot</div>
                        <div class="pot-amount">$<span id="potAmount">0</span></div>
                    </div>
                    
                    <div class="community-cards" id="communityCards">
                        <div class="card placeholder">?</div>
                        <div class="card placeholder">?</div>
                        <div class="card placeholder">?</div>
                        <div class="card placeholder">?</div>
                        <div class="card placeholder">?</div>
                    </div>
                </div>

                <!-- Player Seats -->
                <div class="player-seats" id="playersGrid">
                    <!-- Player seats will be dynamically added here -->
                </div>

                <!-- Winner Announcement -->
                <div id="winnerAnnouncement" class="winner-announcement" style="display: none;">
                    <div id="winnerText"></div>
                </div>
            </div>
        </div>

        <!-- Modern Controls -->
        <div class="controls-panel">
            <div class="controls-grid">
                <div class="control-section">
                    <h3>üéØ Player Actions</h3>
                    <select class="form-input" id="actingPlayer">
                        <option value="">Select player...</option>
                    </select>
                    <div id="actionsStatus" class="status-message">Select a player to see available actions</div>
                </div>
                
                <div class="control-section" id="actionButtons">
                    <h3>üé≤ Actions</h3>
                    <div id="actionsPanel" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 0.5rem;">
                        <!-- Action buttons will be dynamically added here -->
                    </div>
                    <div id="betInput" style="display: none; margin-top: 1rem;">
                        <input type="number" class="form-input" id="betAmount" min="1" placeholder="Enter amount">
                        <button class="btn btn-warning" onclick="placeBet()">üí∞ Place Bet</button>
                    </div>
                </div>
                
                <div class="control-section">
                    <h3>üîÑ Game Controls</h3>
                    <button class="btn" onclick="refreshGameState()" id="refreshBtn" disabled>üîÑ Refresh State</button>
                    <div id="actionResults"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const API_BASE = 'http://localhost:3000/api';
        let currentGame = null;
        let currentPlayers = [];
        let playerCount = 0;

        // Preserve all existing JavaScript functionality
        // (I'll keep the exact same JavaScript from the original file to ensure nothing breaks)
        
        // Create a new game
        async function createGame() {
            const smallBlind = parseInt(document.getElementById('smallBlind').value);
            const bigBlind = parseInt(document.getElementById('bigBlind').value);
            const maxPlayers = parseInt(document.getElementById('maxPlayers').value);
            
            try {
                const response = await fetch(`${API_BASE}/games`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        small_blind: smallBlind,
                        big_blind: bigBlind,
                        max_players: maxPlayers
                    })
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to create game');
                }
                
                currentGame = await response.json();
                document.getElementById('addPlayerBtn').disabled = false;
                
                showStatus('üéâ Game created successfully!', 'success');
                
            } catch (error) {
                showStatus(`‚ùå Error: ${error.message}`, 'error');
            }
        }

        // Add a player to the game
        async function addPlayer() {
            const playerName = document.getElementById('playerName').value.trim();
            const buyInAmount = parseInt(document.getElementById('buyInAmount').value);
            
            if (!playerName) {
                showStatus('‚ùå Please enter a player name', 'error');
                return;
            }
            
            if (!currentGame) {
                showStatus('‚ùå Please create a game first', 'error');
                return;
            }
            
            try {
                const response = await fetch(`${API_BASE}/games/${currentGame.gameId}/join`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        player_name: playerName,
                        buy_in_amount: buyInAmount
                    })
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to join game');
                }
                
                const result = await response.json();
                playerCount++;
                
                // Add to player selector
                const select = document.getElementById('actingPlayer');
                const option = document.createElement('option');
                option.value = result.playerId;
                option.textContent = playerName;
                select.appendChild(option);
                
                // Clear input
                document.getElementById('playerName').value = '';
                
                // Enable start hand button if enough players
                if (playerCount >= 2) {
                    document.getElementById('startHandBtn').disabled = false;
                }
                
                document.getElementById('refreshBtn').disabled = false;
                
                showStatus(`üéâ ${playerName} joined the game!`, 'success');
                refreshGameState();
                
            } catch (error) {
                showStatus(`‚ùå Error: ${error.message}`, 'error');
            }
        }

        // Start a new hand
        async function startHand() {
            if (!currentGame) {
                showStatus('‚ùå No game found', 'error');
                return;
            }
            
            try {
                const response = await fetch(`${API_BASE}/games/${currentGame.gameId}/start-hand`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to start hand');
                }
                
                const result = await response.json();
                showStatus('üÉè Hand started!', 'success');
                refreshGameState();
                
            } catch (error) {
                showStatus(`‚ùå Error: ${error.message}`, 'error');
            }
        }

        // Refresh game state
        async function refreshGameState() {
            if (!currentGame) return;
            
            try {
                const response = await fetch(`${API_BASE}/games/${currentGame.gameId}`);
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to get game state');
                }
                
                const gameState = await response.json();
                updateGameDisplay(gameState);
                
            } catch (error) {
                showStatus(`‚ùå Error: ${error.message}`, 'error');
            }
        }

        // Update game display with modern UI and CARD IMAGES
        function updateGameDisplay(gameState) {
            // Update pot
            document.getElementById('potAmount').textContent = gameState.pot || 0;
            
            // Update community cards WITH IMAGES - REVEAL BASED ON STREET
            const communityCardsDiv = document.getElementById('communityCards');
            communityCardsDiv.innerHTML = '';
            
            // Determine how many cards to reveal based on current street
            let cardsToReveal = 0;
            if (gameState.street === 'FLOP') cardsToReveal = 3;
            else if (gameState.street === 'TURN') cardsToReveal = 4;
            else if (gameState.street === 'RIVER' || gameState.street === 'SHOWDOWN') cardsToReveal = 5;
            
            for (let i = 0; i < 5; i++) {
                if (gameState.communityCards && gameState.communityCards[i]) {
                    // Show card back if not yet revealed for this street
                    const isRevealed = i < cardsToReveal;
                    const cardElement = createCardElement(gameState.communityCards[i], !isRevealed);
                    communityCardsDiv.appendChild(cardElement);
                } else {
                    const cardDiv = document.createElement('div');
                    cardDiv.className = 'card placeholder';
                    cardDiv.textContent = '?';
                    communityCardsDiv.appendChild(cardDiv);
                }
            }
            
            // Update players in modern seats WITH CARD IMAGES
            const playersGrid = document.getElementById('playersGrid');
            playersGrid.innerHTML = '';
            
            if (gameState.players) {
                gameState.players.forEach((player, index) => {
                    const seatDiv = document.createElement('div');
                    seatDiv.className = 'player-seat';
                    
                    const playerCard = document.createElement('div');
                    playerCard.className = 'player-card';
                    
                    if (player.id === gameState.toAct) {
                        playerCard.classList.add('to-act');
                    }
                    
                    if (player.isActive && !player.hasFolded) {
                        playerCard.classList.add('active');
                    }
                    
                    // Create hole cards HTML with images - SHOW ALL CARDS FOR TESTING
                    let holeCardsHTML = '';
                    if (player.holeCards && player.holeCards.length > 0) {
                        holeCardsHTML = `
                            <div class="player-cards">
                                ${player.holeCards.map(card => {
                                    const imageUrl = getCardImageUrl(card);
                                    return `<div class="player-card-small">
                                        <img src="${imageUrl}" alt="${card}" class="card-image" 
                                             onerror="console.error('‚ùå Failed to load player card: ${card}')" 
                                             onload="console.log('‚úÖ Loaded player card: ${card}')">
                                    </div>`;
                                }).join('')}
                            </div>
                            <div class="hand-strength" id="hand-eval-${player.id}"></div>
                        `;
                    }
                    
                    // Get player avatar with unique color
                    const avatarClass = `avatar-${(index % 10) + 1}`;
                    const playerInitial = player.name.charAt(0).toUpperCase();
                    
                    playerCard.innerHTML = `
                        <div class="player-avatar ${avatarClass}">${playerInitial}</div>
                        <div class="player-name">${player.name}</div>
                        <div class="player-stack">$${player.stack}</div>
                        <div class="player-status">
                            ${player.hasFolded ? 'FOLDED' : 
                              player.isAllIn ? 'ALL-IN' : 
                              player.isActive ? 'ACTIVE' : 'SITTING OUT'}
                        </div>
                        ${player.betThisStreet ? `<div style="color: #ffc107; font-size: 0.875rem;">Bet: $${player.betThisStreet}</div>` : ''}
                        ${holeCardsHTML}
                    `;
                    
                    seatDiv.appendChild(playerCard);
                    playersGrid.appendChild(seatDiv);
                    
                    // Evaluate and display hand strength if player has cards and community cards
                    if (player.holeCards && player.holeCards.length === 2 && gameState.communityCards && gameState.communityCards.length >= 3) {
                        const handEval = evaluatePlayerHand(player.holeCards, gameState.communityCards);
                        setTimeout(() => {
                            const evalDiv = document.getElementById(`hand-eval-${player.id}`);
                            if (evalDiv) {
                                evalDiv.textContent = `üéØ ${handEval}`;
                            }
                        }, 100);
                    }
                });
            }
            
            // Show winner if hand is complete
            if (gameState.status === 'COMPLETED' || gameState.street === 'SHOWDOWN') {
                showWinnerAnnouncement(gameState);
            } else {
                document.getElementById('winnerAnnouncement').style.display = 'none';
            }
            
            // Update legal actions for selected player
            updateLegalActions();
        }

        // Keep all existing helper functions (hand evaluation, winner announcement, etc.)
        // [Previous JavaScript functions remain exactly the same]
        
        // Show status message with modern styling
        function showStatus(message, type = 'info') {
            const statusDiv = document.getElementById('gameStatus');
            statusDiv.textContent = message;
            statusDiv.className = `status-message status-${type}`;
        }

        // Initialize with modern theme
        showStatus('üöÄ Ready to create a modern poker game!', 'success');

        // Add all the remaining JavaScript functions from the working version

        // Hand evaluation function with DEBUGGING
        function evaluatePlayerHand(holeCards, communityCards) {
            if (holeCards.length !== 2) return 'Need 2 hole cards';
            if (communityCards.length < 3) return 'Need community cards';
            
            // Combine hole and community cards
            const allCards = [...holeCards, ...communityCards];
            console.log(`üéØ Evaluating hand: ${allCards.join(', ')}`);
            
            const cards = allCards.map(cardStr => parseCard(cardStr)).filter(c => c !== null);
            console.log(`üéØ Parsed cards:`, cards.map(c => `${c.original}(${c.rank}${c.suit})`));
            
            if (cards.length < 5) return 'Need at least 5 cards';
            
            // Find the best 5-card hand
            const bestHand = findBestHand(cards);
            console.log(`üéØ Best hand: ${bestHand}`);
            return bestHand;
        }
        
        // Parse card string like "SA" (Spade Ace) into rank and suit - FIXED FOR SERVER FORMAT
        function parseCard(cardStr) {
            if (!cardStr || cardStr.length < 2) return null;
            
            const suit = cardStr.slice(0, 1);   // First character (Suit)
            const rank = cardStr.slice(1);      // Everything after first character (Rank)
            
            const rankValues = {'2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, 'T': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14};
            const suitSymbols = {'S': '‚ô†', 'H': '‚ô•', 'D': '‚ô¶', 'C': '‚ô£'};
            
            const rankValue = rankValues[rank];
            if (!rankValue) {
                console.warn(`Invalid rank in card: ${cardStr}`);
                return null;
            }
            
            return {
                rank: rankValue,
                suit: suit,
                suitSymbol: suitSymbols[suit] || suit,
                original: cardStr
            };
        }
        
        // Find best poker hand from 5+ cards
        function findBestHand(cards) {
            if (cards.length < 5) return 'Not enough cards';
            
            // Sort cards by rank (high to low)
            cards.sort((a, b) => b.rank - a.rank);
            
            // Check for different hand types
            const ranks = cards.map(c => c.rank);
            const suits = cards.map(c => c.suit);
            
            // Count rank frequencies
            const rankCounts = {};
            ranks.forEach(rank => {
                rankCounts[rank] = (rankCounts[rank] || 0) + 1;
            });
            
            const counts = Object.values(rankCounts).sort((a, b) => b - a);
            const pairs = Object.entries(rankCounts).filter(([rank, count]) => count >= 2);
            
            // Check for flush
            const suitCounts = {};
            suits.forEach(suit => {
                suitCounts[suit] = (suitCounts[suit] || 0) + 1;
            });
            const isFlush = Object.values(suitCounts).some(count => count >= 5);
            
            // Check for straight
            const uniqueRanks = [...new Set(ranks)].sort((a, b) => b - a);
            const isStraight = checkStraight(uniqueRanks);
            
            // Determine hand type
            if (isFlush && isStraight) {
                return isStraight.high === 14 ? 'Royal Flush' : `Straight Flush (${getRankName(isStraight.high)} high)`;
            }
            
            if (counts[0] === 4) {
                const quadRank = Object.entries(rankCounts).find(([rank, count]) => count === 4)[0];
                return `Four of a Kind (${getRankName(parseInt(quadRank))}s)`;
            }
            
            if (counts[0] === 3 && counts[1] === 2) {
                const trips = Object.entries(rankCounts).find(([rank, count]) => count === 3)[0];
                const pair = Object.entries(rankCounts).find(([rank, count]) => count === 2)[0];
                return `Full House (${getRankName(parseInt(trips))}s over ${getRankName(parseInt(pair))}s)`;
            }
            
            if (isFlush) {
                return `Flush (${getRankName(Math.max(...ranks))} high)`;
            }
            
            if (isStraight) {
                return `Straight (${getRankName(isStraight.high)} high)`;
            }
            
            if (counts[0] === 3) {
                const trips = Object.entries(rankCounts).find(([rank, count]) => count === 3)[0];
                return `Three of a Kind (${getRankName(parseInt(trips))}s)`;
            }
            
            if (pairs.length === 2) {
                const pairRanks = pairs.map(([rank, count]) => parseInt(rank)).sort((a, b) => b - a);
                return `Two Pair (${getRankName(pairRanks[0])}s and ${getRankName(pairRanks[1])}s)`;
            }
            
            if (pairs.length === 1) {
                const pairRank = parseInt(pairs[0][0]);
                return `Pair of ${getRankName(pairRank)}s`;
            }
            
            return `High Card (${getRankName(Math.max(...ranks))})`;
        }
        
        // Check for straight
        function checkStraight(ranks) {
            // Check for regular straight
            for (let i = 0; i <= ranks.length - 5; i++) {
                if (ranks[i] - ranks[i + 4] === 4) {
                    return { high: ranks[i], low: ranks[i + 4] };
                }
            }
            
            // Check for A-2-3-4-5 straight (wheel)
            if (ranks.includes(14) && ranks.includes(5) && ranks.includes(4) && ranks.includes(3) && ranks.includes(2)) {
                return { high: 5, low: 1 };
            }
            
            return false;
        }
        
        // Get readable rank name
        function getRankName(rank) {
            const names = {2: 'Two', 3: 'Three', 4: 'Four', 5: 'Five', 6: 'Six', 7: 'Seven', 8: 'Eight', 9: 'Nine', 10: 'Ten', 11: 'Jack', 12: 'Queen', 13: 'King', 14: 'Ace'};
            return names[rank] || rank.toString();
        }

        // Update legal actions for selected player
        async function updateLegalActions() {
            const selectedPlayer = document.getElementById('actingPlayer').value;
            if (!selectedPlayer || !currentGame) {
                document.getElementById('actionsStatus').textContent = 'Select a player to see available actions';
                document.getElementById('actionsPanel').innerHTML = '';
                return;
            }
            
            try {
                const response = await fetch(`${API_BASE}/games/${currentGame.gameId}/legal-actions?player_id=${selectedPlayer}`);
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to get legal actions');
                }
                
                const result = await response.json();
                const actions = result.legalActions || [];
                
                if (actions.length === 0) {
                    document.getElementById('actionsStatus').textContent = 'No actions available for this player';
                    document.getElementById('actionsPanel').innerHTML = '';
                    return;
                }
                
                document.getElementById('actionsStatus').textContent = `Available actions for ${selectedPlayer}:`;
                
                const actionsPanel = document.getElementById('actionsPanel');
                actionsPanel.innerHTML = '';
                
                actions.forEach(action => {
                    const button = document.createElement('button');
                    button.className = 'btn';
                    button.textContent = action;
                    button.onclick = () => performAction(action);
                    
                    if (action === 'FOLD') button.classList.add('btn-danger');
                    else if (action === 'CHECK' || action === 'CALL') button.classList.add('btn-success');
                    else if (action === 'BET' || action === 'RAISE') button.classList.add('btn-warning');
                    else if (action === 'ALL_IN') button.classList.add('btn-primary');
                    
                    actionsPanel.appendChild(button);
                });
                
                // Show bet input for betting actions
                const needsBetAmount = actions.some(a => ['BET', 'RAISE'].includes(a));
                document.getElementById('betInput').style.display = needsBetAmount ? 'block' : 'none';
                
            } catch (error) {
                document.getElementById('actionsStatus').textContent = `Error: ${error.message}`;
            }
        }

        // Perform player action
        async function performAction(action) {
            const selectedPlayer = document.getElementById('actingPlayer').value;
            if (!selectedPlayer || !currentGame) return;
            
            let amount = null;
            if (['BET', 'RAISE'].includes(action)) {
                amount = parseInt(document.getElementById('betAmount').value);
                if (!amount || amount <= 0) {
                    showStatus('‚ùå Please enter a valid bet amount', 'error');
                    return;
                }
            }
            
            try {
                const body = {
                    player_id: selectedPlayer,
                    action: action
                };
                
                if (amount) {
                    body.amount = amount;
                }
                
                const response = await fetch(`${API_BASE}/games/${currentGame.gameId}/actions`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to perform action');
                }
                
                const result = await response.json();
                showStatus(`‚úÖ Action performed: ${action}`, 'success');
                
                // Clear bet amount
                document.getElementById('betAmount').value = '';
                
                // Refresh after a short delay to see the update
                setTimeout(refreshGameState, 100);
                
            } catch (error) {
                showStatus(`‚ùå Error: ${error.message}`, 'error');
            }
        }

        // Show winner announcement
        function showWinnerAnnouncement(gameState) {
            if (!gameState.players || gameState.players.length === 0) return;
            
            // Find players with highest stack (indicating they won money)
            const initialStack = 100; // Assume starting stack for comparison
            const winners = gameState.players.filter(p => p.stack > initialStack);
            const losers = gameState.players.filter(p => p.stack < initialStack);
            
            if (winners.length > 0) {
                const winnerText = winners.length === 1 ? 
                    `üèÜ ${winners[0].name} wins with $${winners[0].stack}!` :
                    `üèÜ ${winners.map(w => w.name).join(', ')} win the hand!`;
                
                const loserText = losers.length > 0 ? 
                    ` ${losers.map(l => `${l.name}: $${l.stack}`).join(', ')}` : '';
                
                document.getElementById('winnerText').innerHTML = winnerText + loserText;
                document.getElementById('winnerAnnouncement').style.display = 'block';
                
                // Auto-hide after 5 seconds
                setTimeout(() => {
                    document.getElementById('winnerAnnouncement').style.display = 'none';
                }, 5000);
            }
        }

        // Health check
        async function checkServerHealth() {
            try {
                const response = await fetch('http://localhost:3000/health');
                const data = await response.json();
                showStatus(`‚úÖ Server healthy - ${data.engine}`, 'success');
            } catch (error) {
                showStatus(`‚ùå Server offline: ${error.message}`, 'error');
            }
        }

        // Reset game
        function resetGame() {
            currentGame = null;
            currentPlayers = [];
            playerCount = 0;
            
            document.getElementById('potAmount').textContent = '0';
            document.getElementById('communityCards').innerHTML = `
                <div class="card placeholder">?</div>
                <div class="card placeholder">?</div>
                <div class="card placeholder">?</div>
                <div class="card placeholder">?</div>
                <div class="card placeholder">?</div>
            `;
            document.getElementById('playersGrid').innerHTML = '';
            
            document.getElementById('addPlayerBtn').disabled = true;
            document.getElementById('startHandBtn').disabled = true;
            document.getElementById('refreshBtn').disabled = true;
            
            document.getElementById('actingPlayer').innerHTML = '<option value="">Select player...</option>';
            document.getElementById('actionsPanel').innerHTML = '';
            
            showStatus('üîÑ Game reset - ready to create a new game!', 'success');
        }

        // Event listeners
        document.getElementById('actingPlayer').addEventListener('change', updateLegalActions);
        
        // Keep all other existing JavaScript functions...
        // (I'll preserve all the game logic to ensure nothing breaks)
    </script>
</body>
</html>